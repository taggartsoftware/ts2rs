// generated by ts2rs 0.2.0
// https://ts2rs.ctaggart.com/

#[wasm_bindgen(module = "vm")]
extern "C" {
    pub type Context;
    pub type BaseOptions;
    #[doc = "Specifies the filename used in stack traces produced by this script."]
    #[doc = "Default: `''`."]
    #[wasm_bindgen(method, getter)]
    pub fn filename(this: &BaseOptions) -> Option<String>;
    #[wasm_bindgen(method, setter)]
    pub fn set_filename(this: &BaseOptions, value: Option<&str>);
    #[doc = "Specifies the line number offset that is displayed in stack traces produced by this script."]
    #[doc = "Default: `0`."]
    # [ wasm_bindgen ( method , getter , js_name = lineOffset ) ]
    pub fn line_offset(this: &BaseOptions) -> Option<f64>;
    # [ wasm_bindgen ( method , setter , js_name = lineOffset ) ]
    pub fn set_line_offset(this: &BaseOptions, value: Option<f64>);
    #[doc = "Specifies the column number offset that is displayed in stack traces produced by this script."]
    #[doc = "Default: `0`"]
    # [ wasm_bindgen ( method , getter , js_name = columnOffset ) ]
    pub fn column_offset(this: &BaseOptions) -> Option<f64>;
    # [ wasm_bindgen ( method , setter , js_name = columnOffset ) ]
    pub fn set_column_offset(this: &BaseOptions, value: Option<f64>);
    pub type ScriptOptions;
    # [ wasm_bindgen ( method , getter , js_name = displayErrors ) ]
    pub fn display_errors(this: &ScriptOptions) -> Option<bool>;
    # [ wasm_bindgen ( method , setter , js_name = displayErrors ) ]
    pub fn set_display_errors(this: &ScriptOptions, value: Option<bool>);
    #[wasm_bindgen(method, getter)]
    pub fn timeout(this: &ScriptOptions) -> Option<f64>;
    #[wasm_bindgen(method, setter)]
    pub fn set_timeout(this: &ScriptOptions, value: Option<f64>);
    # [ wasm_bindgen ( method , getter , js_name = cachedData ) ]
    pub fn cached_data(this: &ScriptOptions) -> Option<Buffer>;
    # [ wasm_bindgen ( method , setter , js_name = cachedData ) ]
    pub fn set_cached_data(this: &ScriptOptions, value: Option<&Buffer>);
    # [ wasm_bindgen ( method , getter , js_name = produceCachedData ) ]
    pub fn produce_cached_data(this: &ScriptOptions) -> Option<bool>;
    # [ wasm_bindgen ( method , setter , js_name = produceCachedData ) ]
    pub fn set_produce_cached_data(this: &ScriptOptions, value: Option<bool>);
    pub type RunningScriptOptions;
    #[doc = "When `true`, if an `Error` occurs while compiling the `code`, the line of code causing the error is attached to the stack trace."]
    #[doc = "Default: `true`."]
    # [ wasm_bindgen ( method , getter , js_name = displayErrors ) ]
    pub fn display_errors(this: &RunningScriptOptions) -> Option<bool>;
    # [ wasm_bindgen ( method , setter , js_name = displayErrors ) ]
    pub fn set_display_errors(this: &RunningScriptOptions, value: Option<bool>);
    #[doc = "Specifies the number of milliseconds to execute code before terminating execution."]
    #[doc = "If execution is terminated, an `Error` will be thrown. This value must be a strictly positive integer."]
    #[wasm_bindgen(method, getter)]
    pub fn timeout(this: &RunningScriptOptions) -> Option<f64>;
    #[wasm_bindgen(method, setter)]
    pub fn set_timeout(this: &RunningScriptOptions, value: Option<f64>);
    #[doc = "If `true`, the execution will be terminated when `SIGINT` (Ctrl+C) is received."]
    #[doc = "Existing handlers for the event that have been attached via `process.on('SIGINT')` will be disabled during script execution, but will continue to work after that."]
    #[doc = "If execution is terminated, an `Error` will be thrown."]
    #[doc = "Default: `false`."]
    # [ wasm_bindgen ( method , getter , js_name = breakOnSigint ) ]
    pub fn break_on_sigint(this: &RunningScriptOptions) -> Option<bool>;
    # [ wasm_bindgen ( method , setter , js_name = breakOnSigint ) ]
    pub fn set_break_on_sigint(this: &RunningScriptOptions, value: Option<bool>);
    pub type CompileFunctionOptions;
    #[doc = "Provides an optional data with V8's code cache data for the supplied source."]
    # [ wasm_bindgen ( method , getter , js_name = cachedData ) ]
    pub fn cached_data(this: &CompileFunctionOptions) -> Option<Buffer>;
    # [ wasm_bindgen ( method , setter , js_name = cachedData ) ]
    pub fn set_cached_data(this: &CompileFunctionOptions, value: Option<&Buffer>);
    #[doc = "Specifies whether to produce new cache data."]
    #[doc = "Default: `false`,"]
    # [ wasm_bindgen ( method , getter , js_name = produceCachedData ) ]
    pub fn produce_cached_data(this: &CompileFunctionOptions) -> Option<bool>;
    # [ wasm_bindgen ( method , setter , js_name = produceCachedData ) ]
    pub fn set_produce_cached_data(this: &CompileFunctionOptions, value: Option<bool>);
    #[doc = "The sandbox/context in which the said function should be compiled in."]
    # [ wasm_bindgen ( method , getter , js_name = parsingContext ) ]
    pub fn parsing_context(this: &CompileFunctionOptions) -> Option<Context>;
    # [ wasm_bindgen ( method , setter , js_name = parsingContext ) ]
    pub fn set_parsing_context(this: &CompileFunctionOptions, value: Option<&Context>);
    #[doc = "An array containing a collection of context extensions (objects wrapping the current scope) to be applied while compiling"]
    # [ wasm_bindgen ( method , getter , js_name = contextExtensions ) ]
    pub fn context_extensions(this: &CompileFunctionOptions) -> Option<Array>;
    # [ wasm_bindgen ( method , setter , js_name = contextExtensions ) ]
    pub fn set_context_extensions(this: &CompileFunctionOptions, value: Option<&Array>);
    pub type CreateContextOptions;
    #[doc = "Human-readable name of the newly created context."]
    #[wasm_bindgen(method, getter)]
    pub fn name(this: &CreateContextOptions) -> Option<String>;
    #[wasm_bindgen(method, setter)]
    pub fn set_name(this: &CreateContextOptions, value: Option<&str>);
    #[doc = "Corresponds to the newly created context for display purposes."]
    #[doc = "The origin should be formatted like a `URL`, but with only the scheme, host, and port (if necessary),"]
    #[doc = "like the value of the `url.origin` property of a URL object."]
    #[doc = "Most notably, this string should omit the trailing slash, as that denotes a path."]
    #[wasm_bindgen(method, getter)]
    pub fn origin(this: &CreateContextOptions) -> Option<String>;
    #[wasm_bindgen(method, setter)]
    pub fn set_origin(this: &CreateContextOptions, value: Option<&str>);
    # [ wasm_bindgen ( method , getter , js_name = codeGeneration ) ]
    pub fn code_generation(this: &CreateContextOptions) -> JsValue;
    # [ wasm_bindgen ( method , setter , js_name = codeGeneration ) ]
    pub fn set_code_generation(this: &CreateContextOptions, value: &JsValue);
    pub type Script;
    #[wasm_bindgen(constructor)]
    pub fn new_script(code: &str, options: Option<&ScriptOptions>) -> Script;
    # [ wasm_bindgen ( method , js_name = runInContext ) ]
    pub fn run_in_context(
        this: &Script,
        contextified_sandbox: &Context,
        options: Option<&RunningScriptOptions>,
    ) -> JsValue;
    # [ wasm_bindgen ( method , setter , js_name = runInContext ) ]
    pub fn set_run_in_context(this: &Script, value: &Function);
    # [ wasm_bindgen ( method , js_name = runInNewContext ) ]
    pub fn run_in_new_context(
        this: &Script,
        sandbox: Option<&Context>,
        options: Option<&RunningScriptOptions>,
    ) -> JsValue;
    # [ wasm_bindgen ( method , setter , js_name = runInNewContext ) ]
    pub fn set_run_in_new_context(this: &Script, value: &Function);
    # [ wasm_bindgen ( method , js_name = runInThisContext ) ]
    pub fn run_in_this_context(this: &Script, options: Option<&RunningScriptOptions>) -> JsValue;
    # [ wasm_bindgen ( method , setter , js_name = runInThisContext ) ]
    pub fn set_run_in_this_context(this: &Script, value: &Function);
    # [ wasm_bindgen ( method , js_name = createCachedData ) ]
    pub fn create_cached_data(this: &Script) -> Buffer;
    # [ wasm_bindgen ( method , setter , js_name = createCachedData ) ]
    pub fn set_create_cached_data(this: &Script, value: &Function);
    # [ wasm_bindgen ( js_name = createContext ) ]
    pub fn create_context(
        sandbox: Option<&Context>,
        options: Option<&CreateContextOptions>,
    ) -> Context;
    # [ wasm_bindgen ( js_name = isContext ) ]
    pub fn is_context(sandbox: &Context) -> bool;
    # [ wasm_bindgen ( js_name = runInContext ) ]
    pub fn run_in_context(code: &str, contextified_sandbox: &Context, options: &JsValue)
    -> JsValue;
    # [ wasm_bindgen ( js_name = runInNewContext ) ]
    pub fn run_in_new_context(code: &str, sandbox: Option<&Context>, options: &JsValue) -> JsValue;
    # [ wasm_bindgen ( js_name = runInThisContext ) ]
    pub fn run_in_this_context(code: &str, options: &JsValue) -> JsValue;
    # [ wasm_bindgen ( js_name = compileFunction ) ]
    pub fn compile_function(
        code: &str,
        params: Option<&Array>,
        options: Option<&CompileFunctionOptions>,
    ) -> Function;
}
