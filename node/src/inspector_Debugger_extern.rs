// generated by ts2rs 0.1.4
// https://ts2rs.ctaggart.com/

#[wasm_bindgen(module = "Debugger")]
extern "C" {
    #[doc = "Breakpoint identifier."]
    pub type BreakpointId;
    #[doc = "Call frame identifier."]
    pub type CallFrameId;
    #[doc = "Location in the source code."]
    pub type Location;
    #[doc = "Script identifier as reported in the <code>Debugger.scriptParsed</code>."]
    # [ wasm_bindgen ( method , getter , js_name = scriptId ) ]
    pub fn script_id(this: &Location) -> crate::inspector::runtime::ScriptId;
    # [ wasm_bindgen ( method , setter , js_name = scriptId ) ]
    pub fn set_script_id(this: &Location, value: &crate::inspector::runtime::ScriptId);
    #[doc = "Line number in the script (0-based)."]
    # [ wasm_bindgen ( method , getter , js_name = lineNumber ) ]
    pub fn line_number(this: &Location) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = lineNumber ) ]
    pub fn set_line_number(this: &Location, value: f64);
    #[doc = "Column number in the script (0-based)."]
    # [ wasm_bindgen ( method , getter , js_name = columnNumber ) ]
    pub fn column_number(this: &Location) -> Option<f64>;
    # [ wasm_bindgen ( method , setter , js_name = columnNumber ) ]
    pub fn set_column_number(this: &Location, value: Option<f64>);
    #[doc = "Location in the source code."]
    pub type ScriptPosition;
    # [ wasm_bindgen ( method , getter , js_name = lineNumber ) ]
    pub fn line_number(this: &ScriptPosition) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = lineNumber ) ]
    pub fn set_line_number(this: &ScriptPosition, value: f64);
    # [ wasm_bindgen ( method , getter , js_name = columnNumber ) ]
    pub fn column_number(this: &ScriptPosition) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = columnNumber ) ]
    pub fn set_column_number(this: &ScriptPosition, value: f64);
    #[doc = "JavaScript call frame. Array of call frames form the call stack."]
    pub type CallFrame;
    #[doc = "Call frame identifier. This identifier is only valid while the virtual machine is paused."]
    # [ wasm_bindgen ( method , getter , js_name = callFrameId ) ]
    pub fn call_frame_id(this: &CallFrame) -> crate::inspector::debugger::CallFrameId;
    # [ wasm_bindgen ( method , setter , js_name = callFrameId ) ]
    pub fn set_call_frame_id(this: &CallFrame, value: &crate::inspector::debugger::CallFrameId);
    #[doc = "Name of the JavaScript function called on this call frame."]
    # [ wasm_bindgen ( method , getter , js_name = functionName ) ]
    pub fn function_name(this: &CallFrame) -> String;
    # [ wasm_bindgen ( method , setter , js_name = functionName ) ]
    pub fn set_function_name(this: &CallFrame, value: &str);
    #[doc = "Location in the source code."]
    # [ wasm_bindgen ( method , getter , js_name = functionLocation ) ]
    pub fn function_location(this: &CallFrame) -> Option<crate::inspector::debugger::Location>;
    # [ wasm_bindgen ( method , setter , js_name = functionLocation ) ]
    pub fn set_function_location(
        this: &CallFrame,
        value: Option<&crate::inspector::debugger::Location>,
    );
    #[doc = "Location in the source code."]
    #[wasm_bindgen(method, getter)]
    pub fn location(this: &CallFrame) -> crate::inspector::debugger::Location;
    #[wasm_bindgen(method, setter)]
    pub fn set_location(this: &CallFrame, value: &crate::inspector::debugger::Location);
    #[doc = "JavaScript script name or url."]
    #[wasm_bindgen(method, getter)]
    pub fn url(this: &CallFrame) -> String;
    #[wasm_bindgen(method, setter)]
    pub fn set_url(this: &CallFrame, value: &str);
    #[doc = "Scope chain for this call frame."]
    # [ wasm_bindgen ( method , getter , js_name = scopeChain ) ]
    pub fn scope_chain(this: &CallFrame) -> Array;
    # [ wasm_bindgen ( method , setter , js_name = scopeChain ) ]
    pub fn set_scope_chain(this: &CallFrame, value: &Array);
    #[doc = "<code>this</code> object for this call frame."]
    #[wasm_bindgen(method, getter)]
    pub fn this(this: &CallFrame) -> crate::inspector::runtime::RemoteObject;
    #[wasm_bindgen(method, setter)]
    pub fn set_this(this: &CallFrame, value: &crate::inspector::runtime::RemoteObject);
    #[doc = "The value being returned, if the function is at return point."]
    # [ wasm_bindgen ( method , getter , js_name = returnValue ) ]
    pub fn return_value(this: &CallFrame) -> Option<crate::inspector::runtime::RemoteObject>;
    # [ wasm_bindgen ( method , setter , js_name = returnValue ) ]
    pub fn set_return_value(
        this: &CallFrame,
        value: Option<&crate::inspector::runtime::RemoteObject>,
    );
    #[doc = "Scope description."]
    pub type Scope;
    #[doc = "Scope type."]
    # [ wasm_bindgen ( method , getter , js_name = type ) ]
    pub fn type_(this: &Scope) -> String;
    # [ wasm_bindgen ( method , setter , js_name = type ) ]
    pub fn set_type_(this: &Scope, value: &str);
    #[doc = "Object representing the scope. For <code>global</code> and <code>with</code> scopes it represents the actual object; for the rest of the scopes, it is artificial transient object enumerating scope variables as its properties."]
    #[wasm_bindgen(method, getter)]
    pub fn object(this: &Scope) -> crate::inspector::runtime::RemoteObject;
    #[wasm_bindgen(method, setter)]
    pub fn set_object(this: &Scope, value: &crate::inspector::runtime::RemoteObject);
    #[wasm_bindgen(method, getter)]
    pub fn name(this: &Scope) -> Option<String>;
    #[wasm_bindgen(method, setter)]
    pub fn set_name(this: &Scope, value: Option<&str>);
    #[doc = "Location in the source code where scope starts"]
    # [ wasm_bindgen ( method , getter , js_name = startLocation ) ]
    pub fn start_location(this: &Scope) -> Option<crate::inspector::debugger::Location>;
    # [ wasm_bindgen ( method , setter , js_name = startLocation ) ]
    pub fn set_start_location(this: &Scope, value: Option<&crate::inspector::debugger::Location>);
    #[doc = "Location in the source code where scope ends"]
    # [ wasm_bindgen ( method , getter , js_name = endLocation ) ]
    pub fn end_location(this: &Scope) -> Option<crate::inspector::debugger::Location>;
    # [ wasm_bindgen ( method , setter , js_name = endLocation ) ]
    pub fn set_end_location(this: &Scope, value: Option<&crate::inspector::debugger::Location>);
    #[doc = "Search match for resource."]
    pub type SearchMatch;
    #[doc = "Line number in resource content."]
    # [ wasm_bindgen ( method , getter , js_name = lineNumber ) ]
    pub fn line_number(this: &SearchMatch) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = lineNumber ) ]
    pub fn set_line_number(this: &SearchMatch, value: f64);
    #[doc = "Line with match content."]
    # [ wasm_bindgen ( method , getter , js_name = lineContent ) ]
    pub fn line_content(this: &SearchMatch) -> String;
    # [ wasm_bindgen ( method , setter , js_name = lineContent ) ]
    pub fn set_line_content(this: &SearchMatch, value: &str);
    pub type BreakLocation;
    #[doc = "Script identifier as reported in the <code>Debugger.scriptParsed</code>."]
    # [ wasm_bindgen ( method , getter , js_name = scriptId ) ]
    pub fn script_id(this: &BreakLocation) -> crate::inspector::runtime::ScriptId;
    # [ wasm_bindgen ( method , setter , js_name = scriptId ) ]
    pub fn set_script_id(this: &BreakLocation, value: &crate::inspector::runtime::ScriptId);
    #[doc = "Line number in the script (0-based)."]
    # [ wasm_bindgen ( method , getter , js_name = lineNumber ) ]
    pub fn line_number(this: &BreakLocation) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = lineNumber ) ]
    pub fn set_line_number(this: &BreakLocation, value: f64);
    #[doc = "Column number in the script (0-based)."]
    # [ wasm_bindgen ( method , getter , js_name = columnNumber ) ]
    pub fn column_number(this: &BreakLocation) -> Option<f64>;
    # [ wasm_bindgen ( method , setter , js_name = columnNumber ) ]
    pub fn set_column_number(this: &BreakLocation, value: Option<f64>);
    # [ wasm_bindgen ( method , getter , js_name = type ) ]
    pub fn type_(this: &BreakLocation) -> Option<String>;
    # [ wasm_bindgen ( method , setter , js_name = type ) ]
    pub fn set_type_(this: &BreakLocation, value: Option<&str>);
    pub type SetBreakpointsActiveParameterType;
    #[doc = "New value for breakpoints active state."]
    #[wasm_bindgen(method, getter)]
    pub fn active(this: &SetBreakpointsActiveParameterType) -> bool;
    #[wasm_bindgen(method, setter)]
    pub fn set_active(this: &SetBreakpointsActiveParameterType, value: bool);
    pub type SetSkipAllPausesParameterType;
    #[doc = "New value for skip pauses state."]
    #[wasm_bindgen(method, getter)]
    pub fn skip(this: &SetSkipAllPausesParameterType) -> bool;
    #[wasm_bindgen(method, setter)]
    pub fn set_skip(this: &SetSkipAllPausesParameterType, value: bool);
    pub type SetBreakpointByUrlParameterType;
    #[doc = "Line number to set breakpoint at."]
    # [ wasm_bindgen ( method , getter , js_name = lineNumber ) ]
    pub fn line_number(this: &SetBreakpointByUrlParameterType) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = lineNumber ) ]
    pub fn set_line_number(this: &SetBreakpointByUrlParameterType, value: f64);
    #[doc = "URL of the resources to set breakpoint on."]
    #[wasm_bindgen(method, getter)]
    pub fn url(this: &SetBreakpointByUrlParameterType) -> Option<String>;
    #[wasm_bindgen(method, setter)]
    pub fn set_url(this: &SetBreakpointByUrlParameterType, value: Option<&str>);
    #[doc = "Regex pattern for the URLs of the resources to set breakpoints on. Either <code>url</code> or <code>urlRegex</code> must be specified."]
    # [ wasm_bindgen ( method , getter , js_name = urlRegex ) ]
    pub fn url_regex(this: &SetBreakpointByUrlParameterType) -> Option<String>;
    # [ wasm_bindgen ( method , setter , js_name = urlRegex ) ]
    pub fn set_url_regex(this: &SetBreakpointByUrlParameterType, value: Option<&str>);
    #[doc = "Script hash of the resources to set breakpoint on."]
    # [ wasm_bindgen ( method , getter , js_name = scriptHash ) ]
    pub fn script_hash(this: &SetBreakpointByUrlParameterType) -> Option<String>;
    # [ wasm_bindgen ( method , setter , js_name = scriptHash ) ]
    pub fn set_script_hash(this: &SetBreakpointByUrlParameterType, value: Option<&str>);
    #[doc = "Offset in the line to set breakpoint at."]
    # [ wasm_bindgen ( method , getter , js_name = columnNumber ) ]
    pub fn column_number(this: &SetBreakpointByUrlParameterType) -> Option<f64>;
    # [ wasm_bindgen ( method , setter , js_name = columnNumber ) ]
    pub fn set_column_number(this: &SetBreakpointByUrlParameterType, value: Option<f64>);
    #[doc = "Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true."]
    #[wasm_bindgen(method, getter)]
    pub fn condition(this: &SetBreakpointByUrlParameterType) -> Option<String>;
    #[wasm_bindgen(method, setter)]
    pub fn set_condition(this: &SetBreakpointByUrlParameterType, value: Option<&str>);
    pub type SetBreakpointParameterType;
    #[doc = "Location to set breakpoint in."]
    #[wasm_bindgen(method, getter)]
    pub fn location(this: &SetBreakpointParameterType) -> crate::inspector::debugger::Location;
    #[wasm_bindgen(method, setter)]
    pub fn set_location(
        this: &SetBreakpointParameterType,
        value: &crate::inspector::debugger::Location,
    );
    #[doc = "Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true."]
    #[wasm_bindgen(method, getter)]
    pub fn condition(this: &SetBreakpointParameterType) -> Option<String>;
    #[wasm_bindgen(method, setter)]
    pub fn set_condition(this: &SetBreakpointParameterType, value: Option<&str>);
    pub type RemoveBreakpointParameterType;
    # [ wasm_bindgen ( method , getter , js_name = breakpointId ) ]
    pub fn breakpoint_id(
        this: &RemoveBreakpointParameterType,
    ) -> crate::inspector::debugger::BreakpointId;
    # [ wasm_bindgen ( method , setter , js_name = breakpointId ) ]
    pub fn set_breakpoint_id(
        this: &RemoveBreakpointParameterType,
        value: &crate::inspector::debugger::BreakpointId,
    );
    pub type GetPossibleBreakpointsParameterType;
    #[doc = "Start of range to search possible breakpoint locations in."]
    #[wasm_bindgen(method, getter)]
    pub fn start(
        this: &GetPossibleBreakpointsParameterType,
    ) -> crate::inspector::debugger::Location;
    #[wasm_bindgen(method, setter)]
    pub fn set_start(
        this: &GetPossibleBreakpointsParameterType,
        value: &crate::inspector::debugger::Location,
    );
    #[doc = "End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range."]
    #[wasm_bindgen(method, getter)]
    pub fn end(
        this: &GetPossibleBreakpointsParameterType,
    ) -> Option<crate::inspector::debugger::Location>;
    #[wasm_bindgen(method, setter)]
    pub fn set_end(
        this: &GetPossibleBreakpointsParameterType,
        value: Option<&crate::inspector::debugger::Location>,
    );
    #[doc = "Only consider locations which are in the same (non-nested) function as start."]
    # [ wasm_bindgen ( method , getter , js_name = restrictToFunction ) ]
    pub fn restrict_to_function(this: &GetPossibleBreakpointsParameterType) -> Option<bool>;
    # [ wasm_bindgen ( method , setter , js_name = restrictToFunction ) ]
    pub fn set_restrict_to_function(
        this: &GetPossibleBreakpointsParameterType,
        value: Option<bool>,
    );
    pub type ContinueToLocationParameterType;
    #[doc = "Location to continue to."]
    #[wasm_bindgen(method, getter)]
    pub fn location(this: &ContinueToLocationParameterType)
    -> crate::inspector::debugger::Location;
    #[wasm_bindgen(method, setter)]
    pub fn set_location(
        this: &ContinueToLocationParameterType,
        value: &crate::inspector::debugger::Location,
    );
    # [ wasm_bindgen ( method , getter , js_name = targetCallFrames ) ]
    pub fn target_call_frames(this: &ContinueToLocationParameterType) -> Option<String>;
    # [ wasm_bindgen ( method , setter , js_name = targetCallFrames ) ]
    pub fn set_target_call_frames(this: &ContinueToLocationParameterType, value: Option<&str>);
    pub type PauseOnAsyncCallParameterType;
    #[doc = "Debugger will pause when async call with given stack trace is started."]
    # [ wasm_bindgen ( method , getter , js_name = parentStackTraceId ) ]
    pub fn parent_stack_trace_id(
        this: &PauseOnAsyncCallParameterType,
    ) -> crate::inspector::runtime::StackTraceId;
    # [ wasm_bindgen ( method , setter , js_name = parentStackTraceId ) ]
    pub fn set_parent_stack_trace_id(
        this: &PauseOnAsyncCallParameterType,
        value: &crate::inspector::runtime::StackTraceId,
    );
    pub type StepIntoParameterType;
    #[doc = "Debugger will issue additional Debugger.paused notification if any async task is scheduled before next pause."]
    # [ wasm_bindgen ( method , getter , js_name = breakOnAsyncCall ) ]
    pub fn break_on_async_call(this: &StepIntoParameterType) -> Option<bool>;
    # [ wasm_bindgen ( method , setter , js_name = breakOnAsyncCall ) ]
    pub fn set_break_on_async_call(this: &StepIntoParameterType, value: Option<bool>);
    pub type GetStackTraceParameterType;
    # [ wasm_bindgen ( method , getter , js_name = stackTraceId ) ]
    pub fn stack_trace_id(
        this: &GetStackTraceParameterType,
    ) -> crate::inspector::runtime::StackTraceId;
    # [ wasm_bindgen ( method , setter , js_name = stackTraceId ) ]
    pub fn set_stack_trace_id(
        this: &GetStackTraceParameterType,
        value: &crate::inspector::runtime::StackTraceId,
    );
    pub type SearchInContentParameterType;
    #[doc = "Id of the script to search in."]
    # [ wasm_bindgen ( method , getter , js_name = scriptId ) ]
    pub fn script_id(this: &SearchInContentParameterType) -> crate::inspector::runtime::ScriptId;
    # [ wasm_bindgen ( method , setter , js_name = scriptId ) ]
    pub fn set_script_id(
        this: &SearchInContentParameterType,
        value: &crate::inspector::runtime::ScriptId,
    );
    #[doc = "String to search for."]
    #[wasm_bindgen(method, getter)]
    pub fn query(this: &SearchInContentParameterType) -> String;
    #[wasm_bindgen(method, setter)]
    pub fn set_query(this: &SearchInContentParameterType, value: &str);
    #[doc = "If true, search is case sensitive."]
    # [ wasm_bindgen ( method , getter , js_name = caseSensitive ) ]
    pub fn case_sensitive(this: &SearchInContentParameterType) -> Option<bool>;
    # [ wasm_bindgen ( method , setter , js_name = caseSensitive ) ]
    pub fn set_case_sensitive(this: &SearchInContentParameterType, value: Option<bool>);
    #[doc = "If true, treats string parameter as regex."]
    # [ wasm_bindgen ( method , getter , js_name = isRegex ) ]
    pub fn is_regex(this: &SearchInContentParameterType) -> Option<bool>;
    # [ wasm_bindgen ( method , setter , js_name = isRegex ) ]
    pub fn set_is_regex(this: &SearchInContentParameterType, value: Option<bool>);
    pub type SetScriptSourceParameterType;
    #[doc = "Id of the script to edit."]
    # [ wasm_bindgen ( method , getter , js_name = scriptId ) ]
    pub fn script_id(this: &SetScriptSourceParameterType) -> crate::inspector::runtime::ScriptId;
    # [ wasm_bindgen ( method , setter , js_name = scriptId ) ]
    pub fn set_script_id(
        this: &SetScriptSourceParameterType,
        value: &crate::inspector::runtime::ScriptId,
    );
    #[doc = "New content of the script."]
    # [ wasm_bindgen ( method , getter , js_name = scriptSource ) ]
    pub fn script_source(this: &SetScriptSourceParameterType) -> String;
    # [ wasm_bindgen ( method , setter , js_name = scriptSource ) ]
    pub fn set_script_source(this: &SetScriptSourceParameterType, value: &str);
    #[doc = "If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code."]
    # [ wasm_bindgen ( method , getter , js_name = dryRun ) ]
    pub fn dry_run(this: &SetScriptSourceParameterType) -> Option<bool>;
    # [ wasm_bindgen ( method , setter , js_name = dryRun ) ]
    pub fn set_dry_run(this: &SetScriptSourceParameterType, value: Option<bool>);
    pub type RestartFrameParameterType;
    #[doc = "Call frame identifier to evaluate on."]
    # [ wasm_bindgen ( method , getter , js_name = callFrameId ) ]
    pub fn call_frame_id(
        this: &RestartFrameParameterType,
    ) -> crate::inspector::debugger::CallFrameId;
    # [ wasm_bindgen ( method , setter , js_name = callFrameId ) ]
    pub fn set_call_frame_id(
        this: &RestartFrameParameterType,
        value: &crate::inspector::debugger::CallFrameId,
    );
    pub type GetScriptSourceParameterType;
    #[doc = "Id of the script to get source for."]
    # [ wasm_bindgen ( method , getter , js_name = scriptId ) ]
    pub fn script_id(this: &GetScriptSourceParameterType) -> crate::inspector::runtime::ScriptId;
    # [ wasm_bindgen ( method , setter , js_name = scriptId ) ]
    pub fn set_script_id(
        this: &GetScriptSourceParameterType,
        value: &crate::inspector::runtime::ScriptId,
    );
    pub type SetPauseOnExceptionsParameterType;
    #[doc = "Pause on exceptions mode."]
    #[wasm_bindgen(method, getter)]
    pub fn state(this: &SetPauseOnExceptionsParameterType) -> String;
    #[wasm_bindgen(method, setter)]
    pub fn set_state(this: &SetPauseOnExceptionsParameterType, value: &str);
    pub type EvaluateOnCallFrameParameterType;
    #[doc = "Call frame identifier to evaluate on."]
    # [ wasm_bindgen ( method , getter , js_name = callFrameId ) ]
    pub fn call_frame_id(
        this: &EvaluateOnCallFrameParameterType,
    ) -> crate::inspector::debugger::CallFrameId;
    # [ wasm_bindgen ( method , setter , js_name = callFrameId ) ]
    pub fn set_call_frame_id(
        this: &EvaluateOnCallFrameParameterType,
        value: &crate::inspector::debugger::CallFrameId,
    );
    #[doc = "Expression to evaluate."]
    #[wasm_bindgen(method, getter)]
    pub fn expression(this: &EvaluateOnCallFrameParameterType) -> String;
    #[wasm_bindgen(method, setter)]
    pub fn set_expression(this: &EvaluateOnCallFrameParameterType, value: &str);
    #[doc = "String object group name to put result into (allows rapid releasing resulting object handles using <code>releaseObjectGroup</code>)."]
    # [ wasm_bindgen ( method , getter , js_name = objectGroup ) ]
    pub fn object_group(this: &EvaluateOnCallFrameParameterType) -> Option<String>;
    # [ wasm_bindgen ( method , setter , js_name = objectGroup ) ]
    pub fn set_object_group(this: &EvaluateOnCallFrameParameterType, value: Option<&str>);
    #[doc = "Specifies whether command line API should be available to the evaluated expression, defaults to false."]
    # [ wasm_bindgen ( method , getter , js_name = includeCommandLineAPI ) ]
    pub fn include_command_line_api(this: &EvaluateOnCallFrameParameterType) -> Option<bool>;
    # [ wasm_bindgen ( method , setter , js_name = includeCommandLineAPI ) ]
    pub fn set_include_command_line_api(
        this: &EvaluateOnCallFrameParameterType,
        value: Option<bool>,
    );
    #[doc = "In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state."]
    #[wasm_bindgen(method, getter)]
    pub fn silent(this: &EvaluateOnCallFrameParameterType) -> Option<bool>;
    #[wasm_bindgen(method, setter)]
    pub fn set_silent(this: &EvaluateOnCallFrameParameterType, value: Option<bool>);
    #[doc = "Whether the result is expected to be a JSON object that should be sent by value."]
    # [ wasm_bindgen ( method , getter , js_name = returnByValue ) ]
    pub fn return_by_value(this: &EvaluateOnCallFrameParameterType) -> Option<bool>;
    # [ wasm_bindgen ( method , setter , js_name = returnByValue ) ]
    pub fn set_return_by_value(this: &EvaluateOnCallFrameParameterType, value: Option<bool>);
    #[doc = "Whether preview should be generated for the result."]
    # [ wasm_bindgen ( method , getter , js_name = generatePreview ) ]
    pub fn generate_preview(this: &EvaluateOnCallFrameParameterType) -> Option<bool>;
    # [ wasm_bindgen ( method , setter , js_name = generatePreview ) ]
    pub fn set_generate_preview(this: &EvaluateOnCallFrameParameterType, value: Option<bool>);
    #[doc = "Whether to throw an exception if side effect cannot be ruled out during evaluation."]
    # [ wasm_bindgen ( method , getter , js_name = throwOnSideEffect ) ]
    pub fn throw_on_side_effect(this: &EvaluateOnCallFrameParameterType) -> Option<bool>;
    # [ wasm_bindgen ( method , setter , js_name = throwOnSideEffect ) ]
    pub fn set_throw_on_side_effect(this: &EvaluateOnCallFrameParameterType, value: Option<bool>);
    pub type SetVariableValueParameterType;
    #[doc = "0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually."]
    # [ wasm_bindgen ( method , getter , js_name = scopeNumber ) ]
    pub fn scope_number(this: &SetVariableValueParameterType) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = scopeNumber ) ]
    pub fn set_scope_number(this: &SetVariableValueParameterType, value: f64);
    #[doc = "Variable name."]
    # [ wasm_bindgen ( method , getter , js_name = variableName ) ]
    pub fn variable_name(this: &SetVariableValueParameterType) -> String;
    # [ wasm_bindgen ( method , setter , js_name = variableName ) ]
    pub fn set_variable_name(this: &SetVariableValueParameterType, value: &str);
    #[doc = "New variable value."]
    # [ wasm_bindgen ( method , getter , js_name = newValue ) ]
    pub fn new_value(
        this: &SetVariableValueParameterType,
    ) -> crate::inspector::runtime::CallArgument;
    # [ wasm_bindgen ( method , setter , js_name = newValue ) ]
    pub fn set_new_value(
        this: &SetVariableValueParameterType,
        value: &crate::inspector::runtime::CallArgument,
    );
    #[doc = "Id of callframe that holds variable."]
    # [ wasm_bindgen ( method , getter , js_name = callFrameId ) ]
    pub fn call_frame_id(
        this: &SetVariableValueParameterType,
    ) -> crate::inspector::debugger::CallFrameId;
    # [ wasm_bindgen ( method , setter , js_name = callFrameId ) ]
    pub fn set_call_frame_id(
        this: &SetVariableValueParameterType,
        value: &crate::inspector::debugger::CallFrameId,
    );
    pub type SetReturnValueParameterType;
    #[doc = "New return value."]
    # [ wasm_bindgen ( method , getter , js_name = newValue ) ]
    pub fn new_value(this: &SetReturnValueParameterType)
    -> crate::inspector::runtime::CallArgument;
    # [ wasm_bindgen ( method , setter , js_name = newValue ) ]
    pub fn set_new_value(
        this: &SetReturnValueParameterType,
        value: &crate::inspector::runtime::CallArgument,
    );
    pub type SetAsyncCallStackDepthParameterType;
    #[doc = "Maximum depth of async call stacks. Setting to <code>0</code> will effectively disable collecting async call stacks (default)."]
    # [ wasm_bindgen ( method , getter , js_name = maxDepth ) ]
    pub fn max_depth(this: &SetAsyncCallStackDepthParameterType) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = maxDepth ) ]
    pub fn set_max_depth(this: &SetAsyncCallStackDepthParameterType, value: f64);
    pub type SetBlackboxPatternsParameterType;
    #[doc = "Array of regexps that will be used to check script url for blackbox state."]
    #[wasm_bindgen(method, getter)]
    pub fn patterns(this: &SetBlackboxPatternsParameterType) -> Array;
    #[wasm_bindgen(method, setter)]
    pub fn set_patterns(this: &SetBlackboxPatternsParameterType, value: &Array);
    pub type SetBlackboxedRangesParameterType;
    #[doc = "Id of the script."]
    # [ wasm_bindgen ( method , getter , js_name = scriptId ) ]
    pub fn script_id(
        this: &SetBlackboxedRangesParameterType,
    ) -> crate::inspector::runtime::ScriptId;
    # [ wasm_bindgen ( method , setter , js_name = scriptId ) ]
    pub fn set_script_id(
        this: &SetBlackboxedRangesParameterType,
        value: &crate::inspector::runtime::ScriptId,
    );
    #[wasm_bindgen(method, getter)]
    pub fn positions(this: &SetBlackboxedRangesParameterType) -> Array;
    #[wasm_bindgen(method, setter)]
    pub fn set_positions(this: &SetBlackboxedRangesParameterType, value: &Array);
    pub type EnableReturnType;
    #[doc = "Unique identifier of the debugger."]
    # [ wasm_bindgen ( method , getter , js_name = debuggerId ) ]
    pub fn debugger_id(this: &EnableReturnType) -> crate::inspector::runtime::UniqueDebuggerId;
    # [ wasm_bindgen ( method , setter , js_name = debuggerId ) ]
    pub fn set_debugger_id(
        this: &EnableReturnType,
        value: &crate::inspector::runtime::UniqueDebuggerId,
    );
    pub type SetBreakpointByUrlReturnType;
    #[doc = "Id of the created breakpoint for further reference."]
    # [ wasm_bindgen ( method , getter , js_name = breakpointId ) ]
    pub fn breakpoint_id(
        this: &SetBreakpointByUrlReturnType,
    ) -> crate::inspector::debugger::BreakpointId;
    # [ wasm_bindgen ( method , setter , js_name = breakpointId ) ]
    pub fn set_breakpoint_id(
        this: &SetBreakpointByUrlReturnType,
        value: &crate::inspector::debugger::BreakpointId,
    );
    #[doc = "List of the locations this breakpoint resolved into upon addition."]
    #[wasm_bindgen(method, getter)]
    pub fn locations(this: &SetBreakpointByUrlReturnType) -> Array;
    #[wasm_bindgen(method, setter)]
    pub fn set_locations(this: &SetBreakpointByUrlReturnType, value: &Array);
    pub type SetBreakpointReturnType;
    #[doc = "Id of the created breakpoint for further reference."]
    # [ wasm_bindgen ( method , getter , js_name = breakpointId ) ]
    pub fn breakpoint_id(
        this: &SetBreakpointReturnType,
    ) -> crate::inspector::debugger::BreakpointId;
    # [ wasm_bindgen ( method , setter , js_name = breakpointId ) ]
    pub fn set_breakpoint_id(
        this: &SetBreakpointReturnType,
        value: &crate::inspector::debugger::BreakpointId,
    );
    #[doc = "Location this breakpoint resolved into."]
    # [ wasm_bindgen ( method , getter , js_name = actualLocation ) ]
    pub fn actual_location(this: &SetBreakpointReturnType) -> crate::inspector::debugger::Location;
    # [ wasm_bindgen ( method , setter , js_name = actualLocation ) ]
    pub fn set_actual_location(
        this: &SetBreakpointReturnType,
        value: &crate::inspector::debugger::Location,
    );
    pub type GetPossibleBreakpointsReturnType;
    #[doc = "List of the possible breakpoint locations."]
    #[wasm_bindgen(method, getter)]
    pub fn locations(this: &GetPossibleBreakpointsReturnType) -> Array;
    #[wasm_bindgen(method, setter)]
    pub fn set_locations(this: &GetPossibleBreakpointsReturnType, value: &Array);
    pub type GetStackTraceReturnType;
    # [ wasm_bindgen ( method , getter , js_name = stackTrace ) ]
    pub fn stack_trace(this: &GetStackTraceReturnType) -> crate::inspector::runtime::StackTrace;
    # [ wasm_bindgen ( method , setter , js_name = stackTrace ) ]
    pub fn set_stack_trace(
        this: &GetStackTraceReturnType,
        value: &crate::inspector::runtime::StackTrace,
    );
    pub type SearchInContentReturnType;
    #[doc = "List of search matches."]
    #[wasm_bindgen(method, getter)]
    pub fn result(this: &SearchInContentReturnType) -> Array;
    #[wasm_bindgen(method, setter)]
    pub fn set_result(this: &SearchInContentReturnType, value: &Array);
    pub type SetScriptSourceReturnType;
    #[doc = "New stack trace in case editing has happened while VM was stopped."]
    # [ wasm_bindgen ( method , getter , js_name = callFrames ) ]
    pub fn call_frames(this: &SetScriptSourceReturnType) -> Option<Array>;
    # [ wasm_bindgen ( method , setter , js_name = callFrames ) ]
    pub fn set_call_frames(this: &SetScriptSourceReturnType, value: Option<&Array>);
    #[doc = "Whether current call stack  was modified after applying the changes."]
    # [ wasm_bindgen ( method , getter , js_name = stackChanged ) ]
    pub fn stack_changed(this: &SetScriptSourceReturnType) -> Option<bool>;
    # [ wasm_bindgen ( method , setter , js_name = stackChanged ) ]
    pub fn set_stack_changed(this: &SetScriptSourceReturnType, value: Option<bool>);
    #[doc = "Async stack trace, if any."]
    # [ wasm_bindgen ( method , getter , js_name = asyncStackTrace ) ]
    pub fn async_stack_trace(
        this: &SetScriptSourceReturnType,
    ) -> Option<crate::inspector::runtime::StackTrace>;
    # [ wasm_bindgen ( method , setter , js_name = asyncStackTrace ) ]
    pub fn set_async_stack_trace(
        this: &SetScriptSourceReturnType,
        value: Option<&crate::inspector::runtime::StackTrace>,
    );
    #[doc = "Async stack trace, if any."]
    # [ wasm_bindgen ( method , getter , js_name = asyncStackTraceId ) ]
    pub fn async_stack_trace_id(
        this: &SetScriptSourceReturnType,
    ) -> Option<crate::inspector::runtime::StackTraceId>;
    # [ wasm_bindgen ( method , setter , js_name = asyncStackTraceId ) ]
    pub fn set_async_stack_trace_id(
        this: &SetScriptSourceReturnType,
        value: Option<&crate::inspector::runtime::StackTraceId>,
    );
    #[doc = "Exception details if any."]
    # [ wasm_bindgen ( method , getter , js_name = exceptionDetails ) ]
    pub fn exception_details(
        this: &SetScriptSourceReturnType,
    ) -> Option<crate::inspector::runtime::ExceptionDetails>;
    # [ wasm_bindgen ( method , setter , js_name = exceptionDetails ) ]
    pub fn set_exception_details(
        this: &SetScriptSourceReturnType,
        value: Option<&crate::inspector::runtime::ExceptionDetails>,
    );
    pub type RestartFrameReturnType;
    #[doc = "New stack trace."]
    # [ wasm_bindgen ( method , getter , js_name = callFrames ) ]
    pub fn call_frames(this: &RestartFrameReturnType) -> Array;
    # [ wasm_bindgen ( method , setter , js_name = callFrames ) ]
    pub fn set_call_frames(this: &RestartFrameReturnType, value: &Array);
    #[doc = "Async stack trace, if any."]
    # [ wasm_bindgen ( method , getter , js_name = asyncStackTrace ) ]
    pub fn async_stack_trace(
        this: &RestartFrameReturnType,
    ) -> Option<crate::inspector::runtime::StackTrace>;
    # [ wasm_bindgen ( method , setter , js_name = asyncStackTrace ) ]
    pub fn set_async_stack_trace(
        this: &RestartFrameReturnType,
        value: Option<&crate::inspector::runtime::StackTrace>,
    );
    #[doc = "Async stack trace, if any."]
    # [ wasm_bindgen ( method , getter , js_name = asyncStackTraceId ) ]
    pub fn async_stack_trace_id(
        this: &RestartFrameReturnType,
    ) -> Option<crate::inspector::runtime::StackTraceId>;
    # [ wasm_bindgen ( method , setter , js_name = asyncStackTraceId ) ]
    pub fn set_async_stack_trace_id(
        this: &RestartFrameReturnType,
        value: Option<&crate::inspector::runtime::StackTraceId>,
    );
    pub type GetScriptSourceReturnType;
    #[doc = "Script source."]
    # [ wasm_bindgen ( method , getter , js_name = scriptSource ) ]
    pub fn script_source(this: &GetScriptSourceReturnType) -> String;
    # [ wasm_bindgen ( method , setter , js_name = scriptSource ) ]
    pub fn set_script_source(this: &GetScriptSourceReturnType, value: &str);
    pub type EvaluateOnCallFrameReturnType;
    #[doc = "Object wrapper for the evaluation result."]
    #[wasm_bindgen(method, getter)]
    pub fn result(this: &EvaluateOnCallFrameReturnType) -> crate::inspector::runtime::RemoteObject;
    #[wasm_bindgen(method, setter)]
    pub fn set_result(
        this: &EvaluateOnCallFrameReturnType,
        value: &crate::inspector::runtime::RemoteObject,
    );
    #[doc = "Exception details."]
    # [ wasm_bindgen ( method , getter , js_name = exceptionDetails ) ]
    pub fn exception_details(
        this: &EvaluateOnCallFrameReturnType,
    ) -> Option<crate::inspector::runtime::ExceptionDetails>;
    # [ wasm_bindgen ( method , setter , js_name = exceptionDetails ) ]
    pub fn set_exception_details(
        this: &EvaluateOnCallFrameReturnType,
        value: Option<&crate::inspector::runtime::ExceptionDetails>,
    );
    pub type ScriptParsedEventDataType;
    #[doc = "Identifier of the script parsed."]
    # [ wasm_bindgen ( method , getter , js_name = scriptId ) ]
    pub fn script_id(this: &ScriptParsedEventDataType) -> crate::inspector::runtime::ScriptId;
    # [ wasm_bindgen ( method , setter , js_name = scriptId ) ]
    pub fn set_script_id(
        this: &ScriptParsedEventDataType,
        value: &crate::inspector::runtime::ScriptId,
    );
    #[doc = "URL or name of the script parsed (if any)."]
    #[wasm_bindgen(method, getter)]
    pub fn url(this: &ScriptParsedEventDataType) -> String;
    #[wasm_bindgen(method, setter)]
    pub fn set_url(this: &ScriptParsedEventDataType, value: &str);
    #[doc = "Line offset of the script within the resource with given URL (for script tags)."]
    # [ wasm_bindgen ( method , getter , js_name = startLine ) ]
    pub fn start_line(this: &ScriptParsedEventDataType) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = startLine ) ]
    pub fn set_start_line(this: &ScriptParsedEventDataType, value: f64);
    #[doc = "Column offset of the script within the resource with given URL."]
    # [ wasm_bindgen ( method , getter , js_name = startColumn ) ]
    pub fn start_column(this: &ScriptParsedEventDataType) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = startColumn ) ]
    pub fn set_start_column(this: &ScriptParsedEventDataType, value: f64);
    #[doc = "Last line of the script."]
    # [ wasm_bindgen ( method , getter , js_name = endLine ) ]
    pub fn end_line(this: &ScriptParsedEventDataType) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = endLine ) ]
    pub fn set_end_line(this: &ScriptParsedEventDataType, value: f64);
    #[doc = "Length of the last line of the script."]
    # [ wasm_bindgen ( method , getter , js_name = endColumn ) ]
    pub fn end_column(this: &ScriptParsedEventDataType) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = endColumn ) ]
    pub fn set_end_column(this: &ScriptParsedEventDataType, value: f64);
    #[doc = "Specifies script creation context."]
    # [ wasm_bindgen ( method , getter , js_name = executionContextId ) ]
    pub fn execution_context_id(
        this: &ScriptParsedEventDataType,
    ) -> crate::inspector::runtime::ExecutionContextId;
    # [ wasm_bindgen ( method , setter , js_name = executionContextId ) ]
    pub fn set_execution_context_id(
        this: &ScriptParsedEventDataType,
        value: &crate::inspector::runtime::ExecutionContextId,
    );
    #[doc = "Content hash of the script."]
    #[wasm_bindgen(method, getter)]
    pub fn hash(this: &ScriptParsedEventDataType) -> String;
    #[wasm_bindgen(method, setter)]
    pub fn set_hash(this: &ScriptParsedEventDataType, value: &str);
    #[doc = "Embedder-specific auxiliary data."]
    # [ wasm_bindgen ( method , getter , js_name = executionContextAuxData ) ]
    pub fn execution_context_aux_data(this: &ScriptParsedEventDataType) -> JsValue;
    # [ wasm_bindgen ( method , setter , js_name = executionContextAuxData ) ]
    pub fn set_execution_context_aux_data(this: &ScriptParsedEventDataType, value: &JsValue);
    #[doc = "True, if this script is generated as a result of the live edit operation."]
    # [ wasm_bindgen ( method , getter , js_name = isLiveEdit ) ]
    pub fn is_live_edit(this: &ScriptParsedEventDataType) -> Option<bool>;
    # [ wasm_bindgen ( method , setter , js_name = isLiveEdit ) ]
    pub fn set_is_live_edit(this: &ScriptParsedEventDataType, value: Option<bool>);
    #[doc = "URL of source map associated with script (if any)."]
    # [ wasm_bindgen ( method , getter , js_name = sourceMapURL ) ]
    pub fn source_map_url(this: &ScriptParsedEventDataType) -> Option<String>;
    # [ wasm_bindgen ( method , setter , js_name = sourceMapURL ) ]
    pub fn set_source_map_url(this: &ScriptParsedEventDataType, value: Option<&str>);
    #[doc = "True, if this script has sourceURL."]
    # [ wasm_bindgen ( method , getter , js_name = hasSourceURL ) ]
    pub fn has_source_url(this: &ScriptParsedEventDataType) -> Option<bool>;
    # [ wasm_bindgen ( method , setter , js_name = hasSourceURL ) ]
    pub fn set_has_source_url(this: &ScriptParsedEventDataType, value: Option<bool>);
    #[doc = "True, if this script is ES6 module."]
    # [ wasm_bindgen ( method , getter , js_name = isModule ) ]
    pub fn is_module(this: &ScriptParsedEventDataType) -> Option<bool>;
    # [ wasm_bindgen ( method , setter , js_name = isModule ) ]
    pub fn set_is_module(this: &ScriptParsedEventDataType, value: Option<bool>);
    #[doc = "This script length."]
    #[wasm_bindgen(method, getter)]
    pub fn length(this: &ScriptParsedEventDataType) -> Option<f64>;
    #[wasm_bindgen(method, setter)]
    pub fn set_length(this: &ScriptParsedEventDataType, value: Option<f64>);
    #[doc = "JavaScript top stack frame of where the script parsed event was triggered if available."]
    # [ wasm_bindgen ( method , getter , js_name = stackTrace ) ]
    pub fn stack_trace(
        this: &ScriptParsedEventDataType,
    ) -> Option<crate::inspector::runtime::StackTrace>;
    # [ wasm_bindgen ( method , setter , js_name = stackTrace ) ]
    pub fn set_stack_trace(
        this: &ScriptParsedEventDataType,
        value: Option<&crate::inspector::runtime::StackTrace>,
    );
    pub type ScriptFailedToParseEventDataType;
    #[doc = "Identifier of the script parsed."]
    # [ wasm_bindgen ( method , getter , js_name = scriptId ) ]
    pub fn script_id(
        this: &ScriptFailedToParseEventDataType,
    ) -> crate::inspector::runtime::ScriptId;
    # [ wasm_bindgen ( method , setter , js_name = scriptId ) ]
    pub fn set_script_id(
        this: &ScriptFailedToParseEventDataType,
        value: &crate::inspector::runtime::ScriptId,
    );
    #[doc = "URL or name of the script parsed (if any)."]
    #[wasm_bindgen(method, getter)]
    pub fn url(this: &ScriptFailedToParseEventDataType) -> String;
    #[wasm_bindgen(method, setter)]
    pub fn set_url(this: &ScriptFailedToParseEventDataType, value: &str);
    #[doc = "Line offset of the script within the resource with given URL (for script tags)."]
    # [ wasm_bindgen ( method , getter , js_name = startLine ) ]
    pub fn start_line(this: &ScriptFailedToParseEventDataType) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = startLine ) ]
    pub fn set_start_line(this: &ScriptFailedToParseEventDataType, value: f64);
    #[doc = "Column offset of the script within the resource with given URL."]
    # [ wasm_bindgen ( method , getter , js_name = startColumn ) ]
    pub fn start_column(this: &ScriptFailedToParseEventDataType) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = startColumn ) ]
    pub fn set_start_column(this: &ScriptFailedToParseEventDataType, value: f64);
    #[doc = "Last line of the script."]
    # [ wasm_bindgen ( method , getter , js_name = endLine ) ]
    pub fn end_line(this: &ScriptFailedToParseEventDataType) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = endLine ) ]
    pub fn set_end_line(this: &ScriptFailedToParseEventDataType, value: f64);
    #[doc = "Length of the last line of the script."]
    # [ wasm_bindgen ( method , getter , js_name = endColumn ) ]
    pub fn end_column(this: &ScriptFailedToParseEventDataType) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = endColumn ) ]
    pub fn set_end_column(this: &ScriptFailedToParseEventDataType, value: f64);
    #[doc = "Specifies script creation context."]
    # [ wasm_bindgen ( method , getter , js_name = executionContextId ) ]
    pub fn execution_context_id(
        this: &ScriptFailedToParseEventDataType,
    ) -> crate::inspector::runtime::ExecutionContextId;
    # [ wasm_bindgen ( method , setter , js_name = executionContextId ) ]
    pub fn set_execution_context_id(
        this: &ScriptFailedToParseEventDataType,
        value: &crate::inspector::runtime::ExecutionContextId,
    );
    #[doc = "Content hash of the script."]
    #[wasm_bindgen(method, getter)]
    pub fn hash(this: &ScriptFailedToParseEventDataType) -> String;
    #[wasm_bindgen(method, setter)]
    pub fn set_hash(this: &ScriptFailedToParseEventDataType, value: &str);
    #[doc = "Embedder-specific auxiliary data."]
    # [ wasm_bindgen ( method , getter , js_name = executionContextAuxData ) ]
    pub fn execution_context_aux_data(this: &ScriptFailedToParseEventDataType) -> JsValue;
    # [ wasm_bindgen ( method , setter , js_name = executionContextAuxData ) ]
    pub fn set_execution_context_aux_data(this: &ScriptFailedToParseEventDataType, value: &JsValue);
    #[doc = "URL of source map associated with script (if any)."]
    # [ wasm_bindgen ( method , getter , js_name = sourceMapURL ) ]
    pub fn source_map_url(this: &ScriptFailedToParseEventDataType) -> Option<String>;
    # [ wasm_bindgen ( method , setter , js_name = sourceMapURL ) ]
    pub fn set_source_map_url(this: &ScriptFailedToParseEventDataType, value: Option<&str>);
    #[doc = "True, if this script has sourceURL."]
    # [ wasm_bindgen ( method , getter , js_name = hasSourceURL ) ]
    pub fn has_source_url(this: &ScriptFailedToParseEventDataType) -> Option<bool>;
    # [ wasm_bindgen ( method , setter , js_name = hasSourceURL ) ]
    pub fn set_has_source_url(this: &ScriptFailedToParseEventDataType, value: Option<bool>);
    #[doc = "True, if this script is ES6 module."]
    # [ wasm_bindgen ( method , getter , js_name = isModule ) ]
    pub fn is_module(this: &ScriptFailedToParseEventDataType) -> Option<bool>;
    # [ wasm_bindgen ( method , setter , js_name = isModule ) ]
    pub fn set_is_module(this: &ScriptFailedToParseEventDataType, value: Option<bool>);
    #[doc = "This script length."]
    #[wasm_bindgen(method, getter)]
    pub fn length(this: &ScriptFailedToParseEventDataType) -> Option<f64>;
    #[wasm_bindgen(method, setter)]
    pub fn set_length(this: &ScriptFailedToParseEventDataType, value: Option<f64>);
    #[doc = "JavaScript top stack frame of where the script parsed event was triggered if available."]
    # [ wasm_bindgen ( method , getter , js_name = stackTrace ) ]
    pub fn stack_trace(
        this: &ScriptFailedToParseEventDataType,
    ) -> Option<crate::inspector::runtime::StackTrace>;
    # [ wasm_bindgen ( method , setter , js_name = stackTrace ) ]
    pub fn set_stack_trace(
        this: &ScriptFailedToParseEventDataType,
        value: Option<&crate::inspector::runtime::StackTrace>,
    );
    pub type BreakpointResolvedEventDataType;
    #[doc = "Breakpoint unique identifier."]
    # [ wasm_bindgen ( method , getter , js_name = breakpointId ) ]
    pub fn breakpoint_id(
        this: &BreakpointResolvedEventDataType,
    ) -> crate::inspector::debugger::BreakpointId;
    # [ wasm_bindgen ( method , setter , js_name = breakpointId ) ]
    pub fn set_breakpoint_id(
        this: &BreakpointResolvedEventDataType,
        value: &crate::inspector::debugger::BreakpointId,
    );
    #[doc = "Actual breakpoint location."]
    #[wasm_bindgen(method, getter)]
    pub fn location(this: &BreakpointResolvedEventDataType)
    -> crate::inspector::debugger::Location;
    #[wasm_bindgen(method, setter)]
    pub fn set_location(
        this: &BreakpointResolvedEventDataType,
        value: &crate::inspector::debugger::Location,
    );
    pub type PausedEventDataType;
    #[doc = "Call stack the virtual machine stopped on."]
    # [ wasm_bindgen ( method , getter , js_name = callFrames ) ]
    pub fn call_frames(this: &PausedEventDataType) -> Array;
    # [ wasm_bindgen ( method , setter , js_name = callFrames ) ]
    pub fn set_call_frames(this: &PausedEventDataType, value: &Array);
    #[doc = "Pause reason."]
    #[wasm_bindgen(method, getter)]
    pub fn reason(this: &PausedEventDataType) -> String;
    #[wasm_bindgen(method, setter)]
    pub fn set_reason(this: &PausedEventDataType, value: &str);
    #[doc = "Object containing break-specific auxiliary properties."]
    #[wasm_bindgen(method, getter)]
    pub fn data(this: &PausedEventDataType) -> JsValue;
    #[wasm_bindgen(method, setter)]
    pub fn set_data(this: &PausedEventDataType, value: &JsValue);
    #[doc = "Hit breakpoints IDs"]
    # [ wasm_bindgen ( method , getter , js_name = hitBreakpoints ) ]
    pub fn hit_breakpoints(this: &PausedEventDataType) -> Option<Array>;
    # [ wasm_bindgen ( method , setter , js_name = hitBreakpoints ) ]
    pub fn set_hit_breakpoints(this: &PausedEventDataType, value: Option<&Array>);
    #[doc = "Async stack trace, if any."]
    # [ wasm_bindgen ( method , getter , js_name = asyncStackTrace ) ]
    pub fn async_stack_trace(
        this: &PausedEventDataType,
    ) -> Option<crate::inspector::runtime::StackTrace>;
    # [ wasm_bindgen ( method , setter , js_name = asyncStackTrace ) ]
    pub fn set_async_stack_trace(
        this: &PausedEventDataType,
        value: Option<&crate::inspector::runtime::StackTrace>,
    );
    #[doc = "Async stack trace, if any."]
    # [ wasm_bindgen ( method , getter , js_name = asyncStackTraceId ) ]
    pub fn async_stack_trace_id(
        this: &PausedEventDataType,
    ) -> Option<crate::inspector::runtime::StackTraceId>;
    # [ wasm_bindgen ( method , setter , js_name = asyncStackTraceId ) ]
    pub fn set_async_stack_trace_id(
        this: &PausedEventDataType,
        value: Option<&crate::inspector::runtime::StackTraceId>,
    );
    #[doc = "Just scheduled async call will have this stack trace as parent stack during async execution. This field is available only after <code>Debugger.stepInto</code> call with <code>breakOnAsynCall</code> flag."]
    # [ wasm_bindgen ( method , getter , js_name = asyncCallStackTraceId ) ]
    pub fn async_call_stack_trace_id(
        this: &PausedEventDataType,
    ) -> Option<crate::inspector::runtime::StackTraceId>;
    # [ wasm_bindgen ( method , setter , js_name = asyncCallStackTraceId ) ]
    pub fn set_async_call_stack_trace_id(
        this: &PausedEventDataType,
        value: Option<&crate::inspector::runtime::StackTraceId>,
    );
}
