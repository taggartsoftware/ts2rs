// generated by ts2rs 0.1.4
// https://ts2rs.ctaggart.com/

#[wasm_bindgen(module = "tls")]
extern "C" {
    pub static CLIENT_RENEG_LIMIT: String;
    pub static CLIENT_RENEG_WINDOW: String;
    pub type Certificate;
    #[doc = "Country code."]
    # [ wasm_bindgen ( method , getter , js_name = C ) ]
    pub fn c(this: &Certificate) -> String;
    # [ wasm_bindgen ( method , setter , js_name = C ) ]
    pub fn set_c(this: &Certificate, value: &str);
    #[doc = "Street."]
    # [ wasm_bindgen ( method , getter , js_name = ST ) ]
    pub fn st(this: &Certificate) -> String;
    # [ wasm_bindgen ( method , setter , js_name = ST ) ]
    pub fn set_st(this: &Certificate, value: &str);
    #[doc = "Locality."]
    # [ wasm_bindgen ( method , getter , js_name = L ) ]
    pub fn l(this: &Certificate) -> String;
    # [ wasm_bindgen ( method , setter , js_name = L ) ]
    pub fn set_l(this: &Certificate, value: &str);
    #[doc = "Organization."]
    # [ wasm_bindgen ( method , getter , js_name = O ) ]
    pub fn o(this: &Certificate) -> String;
    # [ wasm_bindgen ( method , setter , js_name = O ) ]
    pub fn set_o(this: &Certificate, value: &str);
    #[doc = "Organizational unit."]
    # [ wasm_bindgen ( method , getter , js_name = OU ) ]
    pub fn ou(this: &Certificate) -> String;
    # [ wasm_bindgen ( method , setter , js_name = OU ) ]
    pub fn set_ou(this: &Certificate, value: &str);
    #[doc = "Common name."]
    # [ wasm_bindgen ( method , getter , js_name = CN ) ]
    pub fn cn(this: &Certificate) -> String;
    # [ wasm_bindgen ( method , setter , js_name = CN ) ]
    pub fn set_cn(this: &Certificate, value: &str);
    pub type PeerCertificate;
    #[wasm_bindgen(method, getter)]
    pub fn subject(this: &PeerCertificate) -> Certificate;
    #[wasm_bindgen(method, setter)]
    pub fn set_subject(this: &PeerCertificate, value: &Certificate);
    #[wasm_bindgen(method, getter)]
    pub fn issuer(this: &PeerCertificate) -> Certificate;
    #[wasm_bindgen(method, setter)]
    pub fn set_issuer(this: &PeerCertificate, value: &Certificate);
    #[wasm_bindgen(method, getter)]
    pub fn subjectaltname(this: &PeerCertificate) -> String;
    #[wasm_bindgen(method, setter)]
    pub fn set_subjectaltname(this: &PeerCertificate, value: &str);
    # [ wasm_bindgen ( method , getter , js_name = infoAccess ) ]
    pub fn info_access(this: &PeerCertificate) -> JsValue;
    # [ wasm_bindgen ( method , setter , js_name = infoAccess ) ]
    pub fn set_info_access(this: &PeerCertificate, value: &JsValue);
    #[wasm_bindgen(method, getter)]
    pub fn modulus(this: &PeerCertificate) -> String;
    #[wasm_bindgen(method, setter)]
    pub fn set_modulus(this: &PeerCertificate, value: &str);
    #[wasm_bindgen(method, getter)]
    pub fn exponent(this: &PeerCertificate) -> String;
    #[wasm_bindgen(method, setter)]
    pub fn set_exponent(this: &PeerCertificate, value: &str);
    #[wasm_bindgen(method, getter)]
    pub fn valid_from(this: &PeerCertificate) -> String;
    #[wasm_bindgen(method, setter)]
    pub fn set_valid_from(this: &PeerCertificate, value: &str);
    #[wasm_bindgen(method, getter)]
    pub fn valid_to(this: &PeerCertificate) -> String;
    #[wasm_bindgen(method, setter)]
    pub fn set_valid_to(this: &PeerCertificate, value: &str);
    #[wasm_bindgen(method, getter)]
    pub fn fingerprint(this: &PeerCertificate) -> String;
    #[wasm_bindgen(method, setter)]
    pub fn set_fingerprint(this: &PeerCertificate, value: &str);
    #[wasm_bindgen(method, getter)]
    pub fn fingerprint256(this: &PeerCertificate) -> String;
    #[wasm_bindgen(method, setter)]
    pub fn set_fingerprint256(this: &PeerCertificate, value: &str);
    #[wasm_bindgen(method, getter)]
    pub fn ext_key_usage(this: &PeerCertificate) -> Array;
    #[wasm_bindgen(method, setter)]
    pub fn set_ext_key_usage(this: &PeerCertificate, value: &Array);
    # [ wasm_bindgen ( method , getter , js_name = serialNumber ) ]
    pub fn serial_number(this: &PeerCertificate) -> String;
    # [ wasm_bindgen ( method , setter , js_name = serialNumber ) ]
    pub fn set_serial_number(this: &PeerCertificate, value: &str);
    #[wasm_bindgen(method, getter)]
    pub fn raw(this: &PeerCertificate) -> Buffer;
    #[wasm_bindgen(method, setter)]
    pub fn set_raw(this: &PeerCertificate, value: &Buffer);
    pub type DetailedPeerCertificate;
    # [ wasm_bindgen ( method , getter , js_name = issuerCertificate ) ]
    pub fn issuer_certificate(this: &DetailedPeerCertificate) -> DetailedPeerCertificate;
    # [ wasm_bindgen ( method , setter , js_name = issuerCertificate ) ]
    pub fn set_issuer_certificate(this: &DetailedPeerCertificate, value: &DetailedPeerCertificate);
    pub type CipherNameAndProtocol;
    #[doc = "The cipher name."]
    #[wasm_bindgen(method, getter)]
    pub fn name(this: &CipherNameAndProtocol) -> String;
    #[wasm_bindgen(method, setter)]
    pub fn set_name(this: &CipherNameAndProtocol, value: &str);
    #[doc = "SSL/TLS protocol version."]
    #[wasm_bindgen(method, getter)]
    pub fn version(this: &CipherNameAndProtocol) -> String;
    #[wasm_bindgen(method, setter)]
    pub fn set_version(this: &CipherNameAndProtocol, value: &str);
    pub type EphemeralKeyInfo;
    #[doc = "The supported types are 'DH' and 'ECDH'."]
    # [ wasm_bindgen ( method , getter , js_name = type ) ]
    pub fn type_(this: &EphemeralKeyInfo) -> String;
    # [ wasm_bindgen ( method , setter , js_name = type ) ]
    pub fn set_type_(this: &EphemeralKeyInfo, value: &str);
    #[doc = "The name property is available only when type is 'ECDH'."]
    #[wasm_bindgen(method, getter)]
    pub fn name(this: &EphemeralKeyInfo) -> Option<String>;
    #[wasm_bindgen(method, setter)]
    pub fn set_name(this: &EphemeralKeyInfo, value: Option<&str>);
    #[doc = "The size of parameter of an ephemeral key exchange."]
    #[wasm_bindgen(method, getter)]
    pub fn size(this: &EphemeralKeyInfo) -> f64;
    #[wasm_bindgen(method, setter)]
    pub fn set_size(this: &EphemeralKeyInfo, value: f64);
    pub type KeyObject;
    #[doc = "Private keys in PEM format."]
    #[wasm_bindgen(method, getter)]
    pub fn pem(this: &KeyObject) -> JsValue;
    #[wasm_bindgen(method, setter)]
    pub fn set_pem(this: &KeyObject, value: &JsValue);
    #[doc = "Optional passphrase."]
    #[wasm_bindgen(method, getter)]
    pub fn passphrase(this: &KeyObject) -> Option<String>;
    #[wasm_bindgen(method, setter)]
    pub fn set_passphrase(this: &KeyObject, value: Option<&str>);
    pub type PxfObject;
    #[doc = "PFX or PKCS12 encoded private key and certificate chain."]
    #[wasm_bindgen(method, getter)]
    pub fn buf(this: &PxfObject) -> JsValue;
    #[wasm_bindgen(method, setter)]
    pub fn set_buf(this: &PxfObject, value: &JsValue);
    #[doc = "Optional passphrase."]
    #[wasm_bindgen(method, getter)]
    pub fn passphrase(this: &PxfObject) -> Option<String>;
    #[wasm_bindgen(method, setter)]
    pub fn set_passphrase(this: &PxfObject, value: Option<&str>);
    pub type TLSSocketOptions;
    #[doc = "If true the TLS socket will be instantiated in server-mode."]
    #[doc = "Defaults to false."]
    # [ wasm_bindgen ( method , getter , js_name = isServer ) ]
    pub fn is_server(this: &TLSSocketOptions) -> Option<bool>;
    # [ wasm_bindgen ( method , setter , js_name = isServer ) ]
    pub fn set_is_server(this: &TLSSocketOptions, value: Option<bool>);
    #[doc = "An optional net.Server instance."]
    #[wasm_bindgen(method, getter)]
    pub fn server(this: &TLSSocketOptions) -> Option<crate::net::Server>;
    #[wasm_bindgen(method, setter)]
    pub fn set_server(this: &TLSSocketOptions, value: Option<&crate::net::Server>);
    #[doc = "An optional Buffer instance containing a TLS session."]
    #[wasm_bindgen(method, getter)]
    pub fn session(this: &TLSSocketOptions) -> Option<Buffer>;
    #[wasm_bindgen(method, setter)]
    pub fn set_session(this: &TLSSocketOptions, value: Option<&Buffer>);
    #[doc = "If true, specifies that the OCSP status request extension will be"]
    #[doc = "added to the client hello and an 'OCSPResponse' event will be"]
    #[doc = "emitted on the socket before establishing a secure communication"]
    # [ wasm_bindgen ( method , getter , js_name = requestOCSP ) ]
    pub fn request_ocsp(this: &TLSSocketOptions) -> Option<bool>;
    # [ wasm_bindgen ( method , setter , js_name = requestOCSP ) ]
    pub fn set_request_ocsp(this: &TLSSocketOptions, value: Option<bool>);
    pub type TLSSocket;
    #[wasm_bindgen(constructor)]
    pub fn new_tls_socket(
        socket: &crate::net::Socket,
        options: Option<&TLSSocketOptions>,
    ) -> TLSSocket;
    #[doc = "A boolean that is true if the peer certificate was signed by one of the specified CAs, otherwise false."]
    #[wasm_bindgen(method, getter)]
    pub fn authorized(this: &TLSSocket) -> bool;
    #[wasm_bindgen(method, setter)]
    pub fn set_authorized(this: &TLSSocket, value: bool);
    #[doc = "The reason why the peer's certificate has not been verified."]
    #[doc = "This property becomes available only when tlsSocket.authorized === false."]
    # [ wasm_bindgen ( method , getter , js_name = authorizationError ) ]
    pub fn authorization_error(this: &TLSSocket) -> Error;
    # [ wasm_bindgen ( method , setter , js_name = authorizationError ) ]
    pub fn set_authorization_error(this: &TLSSocket, value: &Error);
    #[doc = "Static boolean value, always true."]
    #[doc = "May be used to distinguish TLS sockets from regular ones."]
    #[wasm_bindgen(method, getter)]
    pub fn encrypted(this: &TLSSocket) -> bool;
    #[wasm_bindgen(method, setter)]
    pub fn set_encrypted(this: &TLSSocket, value: bool);
    #[doc = "String containing the selected ALPN protocol."]
    #[doc = "When ALPN has no selected protocol, tlsSocket.alpnProtocol equals false."]
    # [ wasm_bindgen ( method , getter , js_name = alpnProtocol ) ]
    pub fn alpn_protocol(this: &TLSSocket) -> Option<String>;
    # [ wasm_bindgen ( method , setter , js_name = alpnProtocol ) ]
    pub fn set_alpn_protocol(this: &TLSSocket, value: Option<&str>);
    #[doc = "Returns an object representing the local certificate. The returned"]
    #[doc = "object has some properties corresponding to the fields of the"]
    #[doc = "certificate."]
    #[doc = ""]
    #[doc = "See tls.TLSSocket.getPeerCertificate() for an example of the"]
    #[doc = "certificate structure."]
    #[doc = ""]
    #[doc = "If there is no local certificate, an empty object will be returned."]
    #[doc = "If the socket has been destroyed, null will be returned."]
    # [ wasm_bindgen ( method , js_name = getCertificate ) ]
    pub fn get_certificate(this: &TLSSocket) -> JsValue;
    # [ wasm_bindgen ( method , setter , js_name = getCertificate ) ]
    pub fn set_get_certificate(this: &TLSSocket, value: &Function);
    #[doc = "Returns an object representing the cipher name and the SSL/TLS protocol version of the current connection."]
    # [ wasm_bindgen ( method , js_name = getCipher ) ]
    pub fn get_cipher(this: &TLSSocket) -> CipherNameAndProtocol;
    # [ wasm_bindgen ( method , setter , js_name = getCipher ) ]
    pub fn set_get_cipher(this: &TLSSocket, value: &Function);
    #[doc = "Returns an object representing the type, name, and size of parameter"]
    #[doc = "of an ephemeral key exchange in Perfect Forward Secrecy on a client"]
    #[doc = "connection. It returns an empty object when the key exchange is not"]
    #[doc = "ephemeral. As this is only supported on a client socket; null is"]
    #[doc = "returned if called on a server socket. The supported types are 'DH'"]
    #[doc = "and 'ECDH'. The name property is available only when type is 'ECDH'."]
    #[doc = ""]
    #[doc = "For example: { type: 'ECDH', name: 'prime256v1', size: 256 }."]
    # [ wasm_bindgen ( method , js_name = getEphemeralKeyInfo ) ]
    pub fn get_ephemeral_key_info(this: &TLSSocket) -> JsValue;
    # [ wasm_bindgen ( method , setter , js_name = getEphemeralKeyInfo ) ]
    pub fn set_get_ephemeral_key_info(this: &TLSSocket, value: &Function);
    #[doc = "Returns the latest Finished message that has"]
    #[doc = "been sent to the socket as part of a SSL/TLS handshake, or undefined"]
    #[doc = "if no Finished message has been sent yet."]
    #[doc = ""]
    #[doc = "As the Finished messages are message digests of the complete"]
    #[doc = "handshake (with a total of 192 bits for TLS 1.0 and more for SSL"]
    #[doc = "3.0), they can be used for external authentication procedures when"]
    #[doc = "the authentication provided by SSL/TLS is not desired or is not"]
    #[doc = "enough."]
    #[doc = ""]
    #[doc = "Corresponds to the SSL_get_finished routine in OpenSSL and may be"]
    #[doc = "used to implement the tls-unique channel binding from RFC 5929."]
    # [ wasm_bindgen ( method , js_name = getFinished ) ]
    pub fn get_finished(this: &TLSSocket) -> Option<Buffer>;
    # [ wasm_bindgen ( method , setter , js_name = getFinished ) ]
    pub fn set_get_finished(this: &TLSSocket, value: &Function);
    #[doc = "Returns an object representing the peer's certificate."]
    #[doc = "The returned object has some properties corresponding to the field of the certificate."]
    #[doc = "If detailed argument is true the full chain with issuer property will be returned,"]
    #[doc = "if false only the top certificate without issuer property."]
    #[doc = "If the peer does not provide a certificate, it returns null or an empty object."]
    # [ wasm_bindgen ( method , js_name = getPeerCertificate ) ]
    pub fn get_peer_certificate(this: &TLSSocket, detailed: &JsValue) -> DetailedPeerCertificate;
    # [ wasm_bindgen ( method , setter , js_name = getPeerCertificate ) ]
    pub fn set_get_peer_certificate(this: &TLSSocket, value: &Function);
    #[doc = "Returns an object representing the peer's certificate."]
    #[doc = "The returned object has some properties corresponding to the field of the certificate."]
    #[doc = "If detailed argument is true the full chain with issuer property will be returned,"]
    #[doc = "if false only the top certificate without issuer property."]
    #[doc = "If the peer does not provide a certificate, it returns null or an empty object."]
    # [ wasm_bindgen ( method , js_name = getPeerCertificate ) ]
    pub fn get_peer_certificate2(this: &TLSSocket, detailed: &JsValue) -> PeerCertificate;
    # [ wasm_bindgen ( method , setter , js_name = getPeerCertificate ) ]
    pub fn set_get_peer_certificate2(this: &TLSSocket, value: &Function);
    #[doc = "Returns an object representing the peer's certificate."]
    #[doc = "The returned object has some properties corresponding to the field of the certificate."]
    #[doc = "If detailed argument is true the full chain with issuer property will be returned,"]
    #[doc = "if false only the top certificate without issuer property."]
    #[doc = "If the peer does not provide a certificate, it returns null or an empty object."]
    # [ wasm_bindgen ( method , js_name = getPeerCertificate ) ]
    pub fn get_peer_certificate3(this: &TLSSocket, detailed: Option<bool>) -> JsValue;
    # [ wasm_bindgen ( method , setter , js_name = getPeerCertificate ) ]
    pub fn set_get_peer_certificate3(this: &TLSSocket, value: &Function);
    #[doc = "Returns the latest Finished message that is expected or has actually"]
    #[doc = "been received from the socket as part of a SSL/TLS handshake, or"]
    #[doc = "undefined if there is no Finished message so far."]
    #[doc = ""]
    #[doc = "As the Finished messages are message digests of the complete"]
    #[doc = "handshake (with a total of 192 bits for TLS 1.0 and more for SSL"]
    #[doc = "3.0), they can be used for external authentication procedures when"]
    #[doc = "the authentication provided by SSL/TLS is not desired or is not"]
    #[doc = "enough."]
    #[doc = ""]
    #[doc = "Corresponds to the SSL_get_peer_finished routine in OpenSSL and may"]
    #[doc = "be used to implement the tls-unique channel binding from RFC 5929."]
    # [ wasm_bindgen ( method , js_name = getPeerFinished ) ]
    pub fn get_peer_finished(this: &TLSSocket) -> Option<Buffer>;
    # [ wasm_bindgen ( method , setter , js_name = getPeerFinished ) ]
    pub fn set_get_peer_finished(this: &TLSSocket, value: &Function);
    #[doc = "Returns a string containing the negotiated SSL/TLS protocol version of the current connection."]
    #[doc = "The value `'unknown'` will be returned for connected sockets that have not completed the handshaking process."]
    #[doc = "The value `null` will be returned for server sockets or disconnected client sockets."]
    #[doc = "See https://www.openssl.org/docs/man1.0.2/ssl/SSL_get_version.html for more information."]
    # [ wasm_bindgen ( method , js_name = getProtocol ) ]
    pub fn get_protocol(this: &TLSSocket) -> JsValue;
    # [ wasm_bindgen ( method , setter , js_name = getProtocol ) ]
    pub fn set_get_protocol(this: &TLSSocket, value: &Function);
    #[doc = "Could be used to speed up handshake establishment when reconnecting to the server."]
    # [ wasm_bindgen ( method , js_name = getSession ) ]
    pub fn get_session(this: &TLSSocket) -> Option<Buffer>;
    # [ wasm_bindgen ( method , setter , js_name = getSession ) ]
    pub fn set_get_session(this: &TLSSocket, value: &Function);
    #[doc = "Returns a list of signature algorithms shared between the server and"]
    #[doc = "the client in the order of decreasing preference."]
    # [ wasm_bindgen ( method , js_name = getSharedSigalgs ) ]
    pub fn get_shared_sigalgs(this: &TLSSocket) -> Array;
    # [ wasm_bindgen ( method , setter , js_name = getSharedSigalgs ) ]
    pub fn set_get_shared_sigalgs(this: &TLSSocket, value: &Function);
    #[doc = "NOTE: Works only with client TLS sockets."]
    #[doc = "Useful only for debugging, for session reuse provide session option to tls.connect()."]
    # [ wasm_bindgen ( method , js_name = getTLSTicket ) ]
    pub fn get_tls_ticket(this: &TLSSocket) -> Option<Buffer>;
    # [ wasm_bindgen ( method , setter , js_name = getTLSTicket ) ]
    pub fn set_get_tls_ticket(this: &TLSSocket, value: &Function);
    #[doc = "Returns true if the session was reused, false otherwise."]
    # [ wasm_bindgen ( method , js_name = isSessionReused ) ]
    pub fn is_session_reused(this: &TLSSocket) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = isSessionReused ) ]
    pub fn set_is_session_reused(this: &TLSSocket, value: &Function);
    #[doc = "Initiate TLS renegotiation process."]
    #[doc = ""]
    #[doc = "NOTE: Can be used to request peer's certificate after the secure connection has been established."]
    #[doc = "ANOTHER NOTE: When running as the server, socket will be destroyed with an error after handshakeTimeout timeout."]
    #[wasm_bindgen(method)]
    pub fn renegotiate(this: &TLSSocket, options: &JsValue, callback: &JsValue) -> Option<bool>;
    #[wasm_bindgen(method, setter)]
    pub fn set_renegotiate(this: &TLSSocket, value: &Function);
    #[doc = "Set maximum TLS fragment size (default and maximum value is: 16384, minimum is: 512)."]
    #[doc = "Smaller fragment size decreases buffering latency on the client: large fragments are buffered by"]
    #[doc = "the TLS layer until the entire fragment is received and its integrity is verified;"]
    #[doc = "large fragments can span multiple roundtrips, and their processing can be delayed due to packet"]
    #[doc = "loss or reordering. However, smaller fragments add extra TLS framing bytes and CPU overhead,"]
    #[doc = "which may decrease overall server throughput."]
    # [ wasm_bindgen ( method , js_name = setMaxSendFragment ) ]
    pub fn set_max_send_fragment(this: &TLSSocket, size: f64) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = setMaxSendFragment ) ]
    pub fn set_set_max_send_fragment(this: &TLSSocket, value: &Function);
    #[doc = "Disables TLS renegotiation for this TLSSocket instance. Once called,"]
    #[doc = "attempts to renegotiate will trigger an 'error' event on the"]
    #[doc = "TLSSocket."]
    # [ wasm_bindgen ( method , js_name = disableRenegotiation ) ]
    pub fn disable_renegotiation(this: &TLSSocket);
    # [ wasm_bindgen ( method , setter , js_name = disableRenegotiation ) ]
    pub fn set_disable_renegotiation(this: &TLSSocket, value: &Function);
    #[doc = "When enabled, TLS packet trace information is written to `stderr`. This can be"]
    #[doc = "used to debug TLS connection problems."]
    #[doc = ""]
    #[doc = "Note: The format of the output is identical to the output of `openssl s_client"]
    #[doc = "-trace` or `openssl s_server -trace`. While it is produced by OpenSSL's"]
    #[doc = "`SSL_trace()` function, the format is undocumented, can change without notice,"]
    #[doc = "and should not be relied on."]
    # [ wasm_bindgen ( method , js_name = enableTrace ) ]
    pub fn enable_trace(this: &TLSSocket);
    # [ wasm_bindgen ( method , setter , js_name = enableTrace ) ]
    pub fn set_enable_trace(this: &TLSSocket, value: &Function);
    #[doc = "events.EventEmitter"]
    #[doc = "   1. close"]
    #[doc = "   2. connect"]
    #[doc = "   3. data"]
    #[doc = "   4. drain"]
    #[doc = "   5. end"]
    #[doc = "   6. error"]
    #[doc = "   7. lookup"]
    #[doc = "   8. timeout"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "events.EventEmitter"]
    #[doc = "   1. close"]
    #[doc = "   2. connect"]
    #[doc = "   3. data"]
    #[doc = "   4. drain"]
    #[doc = "   5. end"]
    #[doc = "   6. error"]
    #[doc = "   7. lookup"]
    #[doc = "   8. timeout"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "events.EventEmitter"]
    #[doc = "   1. close"]
    #[doc = "   2. connect"]
    #[doc = "   3. data"]
    #[doc = "   4. drain"]
    #[doc = "   5. end"]
    #[doc = "   6. error"]
    #[doc = "   7. lookup"]
    #[doc = "   8. timeout"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "events.EventEmitter"]
    #[doc = "   1. close"]
    #[doc = "   2. connect"]
    #[doc = "   3. data"]
    #[doc = "   4. drain"]
    #[doc = "   5. end"]
    #[doc = "   6. error"]
    #[doc = "   7. lookup"]
    #[doc = "   8. timeout"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "events.EventEmitter"]
    #[doc = "   1. close"]
    #[doc = "   2. connect"]
    #[doc = "   3. data"]
    #[doc = "   4. drain"]
    #[doc = "   5. end"]
    #[doc = "   6. error"]
    #[doc = "   7. lookup"]
    #[doc = "   8. timeout"]
    # [ wasm_bindgen ( method , js_name = addListener ) ]
    pub fn add_listener(this: &TLSSocket, event: &str, listener: &JsValue) -> TLSSocket;
    # [ wasm_bindgen ( method , setter , js_name = addListener ) ]
    pub fn set_add_listener(this: &TLSSocket, value: &Function);
    #[doc = "events.EventEmitter"]
    #[doc = "   1. close"]
    #[doc = "   2. connect"]
    #[doc = "   3. data"]
    #[doc = "   4. drain"]
    #[doc = "   5. end"]
    #[doc = "   6. error"]
    #[doc = "   7. lookup"]
    #[doc = "   8. timeout"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "events.EventEmitter"]
    #[doc = "   1. close"]
    #[doc = "   2. connect"]
    #[doc = "   3. data"]
    #[doc = "   4. drain"]
    #[doc = "   5. end"]
    #[doc = "   6. error"]
    #[doc = "   7. lookup"]
    #[doc = "   8. timeout"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "events.EventEmitter"]
    #[doc = "   1. close"]
    #[doc = "   2. connect"]
    #[doc = "   3. data"]
    #[doc = "   4. drain"]
    #[doc = "   5. end"]
    #[doc = "   6. error"]
    #[doc = "   7. lookup"]
    #[doc = "   8. timeout"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "events.EventEmitter"]
    #[doc = "   1. close"]
    #[doc = "   2. connect"]
    #[doc = "   3. data"]
    #[doc = "   4. drain"]
    #[doc = "   5. end"]
    #[doc = "   6. error"]
    #[doc = "   7. lookup"]
    #[doc = "   8. timeout"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "events.EventEmitter"]
    #[doc = "   1. close"]
    #[doc = "   2. connect"]
    #[doc = "   3. data"]
    #[doc = "   4. drain"]
    #[doc = "   5. end"]
    #[doc = "   6. error"]
    #[doc = "   7. lookup"]
    #[doc = "   8. timeout"]
    # [ wasm_bindgen ( method , js_name = addListener ) ]
    pub fn add_listener2(this: &TLSSocket, event: &JsValue, listener: &JsValue) -> TLSSocket;
    # [ wasm_bindgen ( method , setter , js_name = addListener ) ]
    pub fn set_add_listener2(this: &TLSSocket, value: &Function);
    #[doc = "events.EventEmitter"]
    #[doc = "   1. close"]
    #[doc = "   2. connect"]
    #[doc = "   3. data"]
    #[doc = "   4. drain"]
    #[doc = "   5. end"]
    #[doc = "   6. error"]
    #[doc = "   7. lookup"]
    #[doc = "   8. timeout"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "events.EventEmitter"]
    #[doc = "   1. close"]
    #[doc = "   2. connect"]
    #[doc = "   3. data"]
    #[doc = "   4. drain"]
    #[doc = "   5. end"]
    #[doc = "   6. error"]
    #[doc = "   7. lookup"]
    #[doc = "   8. timeout"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "events.EventEmitter"]
    #[doc = "   1. close"]
    #[doc = "   2. connect"]
    #[doc = "   3. data"]
    #[doc = "   4. drain"]
    #[doc = "   5. end"]
    #[doc = "   6. error"]
    #[doc = "   7. lookup"]
    #[doc = "   8. timeout"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "events.EventEmitter"]
    #[doc = "   1. close"]
    #[doc = "   2. connect"]
    #[doc = "   3. data"]
    #[doc = "   4. drain"]
    #[doc = "   5. end"]
    #[doc = "   6. error"]
    #[doc = "   7. lookup"]
    #[doc = "   8. timeout"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "events.EventEmitter"]
    #[doc = "   1. close"]
    #[doc = "   2. connect"]
    #[doc = "   3. data"]
    #[doc = "   4. drain"]
    #[doc = "   5. end"]
    #[doc = "   6. error"]
    #[doc = "   7. lookup"]
    #[doc = "   8. timeout"]
    # [ wasm_bindgen ( method , js_name = addListener ) ]
    pub fn add_listener3(this: &TLSSocket, event: &JsValue, listener: &JsValue) -> TLSSocket;
    # [ wasm_bindgen ( method , setter , js_name = addListener ) ]
    pub fn set_add_listener3(this: &TLSSocket, value: &Function);
    #[doc = "events.EventEmitter"]
    #[doc = "   1. close"]
    #[doc = "   2. connect"]
    #[doc = "   3. data"]
    #[doc = "   4. drain"]
    #[doc = "   5. end"]
    #[doc = "   6. error"]
    #[doc = "   7. lookup"]
    #[doc = "   8. timeout"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "events.EventEmitter"]
    #[doc = "   1. close"]
    #[doc = "   2. connect"]
    #[doc = "   3. data"]
    #[doc = "   4. drain"]
    #[doc = "   5. end"]
    #[doc = "   6. error"]
    #[doc = "   7. lookup"]
    #[doc = "   8. timeout"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "events.EventEmitter"]
    #[doc = "   1. close"]
    #[doc = "   2. connect"]
    #[doc = "   3. data"]
    #[doc = "   4. drain"]
    #[doc = "   5. end"]
    #[doc = "   6. error"]
    #[doc = "   7. lookup"]
    #[doc = "   8. timeout"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "events.EventEmitter"]
    #[doc = "   1. close"]
    #[doc = "   2. connect"]
    #[doc = "   3. data"]
    #[doc = "   4. drain"]
    #[doc = "   5. end"]
    #[doc = "   6. error"]
    #[doc = "   7. lookup"]
    #[doc = "   8. timeout"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "events.EventEmitter"]
    #[doc = "   1. close"]
    #[doc = "   2. connect"]
    #[doc = "   3. data"]
    #[doc = "   4. drain"]
    #[doc = "   5. end"]
    #[doc = "   6. error"]
    #[doc = "   7. lookup"]
    #[doc = "   8. timeout"]
    # [ wasm_bindgen ( method , js_name = addListener ) ]
    pub fn add_listener4(this: &TLSSocket, event: &JsValue, listener: &JsValue) -> TLSSocket;
    # [ wasm_bindgen ( method , setter , js_name = addListener ) ]
    pub fn set_add_listener4(this: &TLSSocket, value: &Function);
    #[doc = "events.EventEmitter"]
    #[doc = "   1. close"]
    #[doc = "   2. connect"]
    #[doc = "   3. data"]
    #[doc = "   4. drain"]
    #[doc = "   5. end"]
    #[doc = "   6. error"]
    #[doc = "   7. lookup"]
    #[doc = "   8. timeout"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "events.EventEmitter"]
    #[doc = "   1. close"]
    #[doc = "   2. connect"]
    #[doc = "   3. data"]
    #[doc = "   4. drain"]
    #[doc = "   5. end"]
    #[doc = "   6. error"]
    #[doc = "   7. lookup"]
    #[doc = "   8. timeout"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "events.EventEmitter"]
    #[doc = "   1. close"]
    #[doc = "   2. connect"]
    #[doc = "   3. data"]
    #[doc = "   4. drain"]
    #[doc = "   5. end"]
    #[doc = "   6. error"]
    #[doc = "   7. lookup"]
    #[doc = "   8. timeout"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "events.EventEmitter"]
    #[doc = "   1. close"]
    #[doc = "   2. connect"]
    #[doc = "   3. data"]
    #[doc = "   4. drain"]
    #[doc = "   5. end"]
    #[doc = "   6. error"]
    #[doc = "   7. lookup"]
    #[doc = "   8. timeout"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "events.EventEmitter"]
    #[doc = "   1. close"]
    #[doc = "   2. connect"]
    #[doc = "   3. data"]
    #[doc = "   4. drain"]
    #[doc = "   5. end"]
    #[doc = "   6. error"]
    #[doc = "   7. lookup"]
    #[doc = "   8. timeout"]
    # [ wasm_bindgen ( method , js_name = addListener ) ]
    pub fn add_listener5(this: &TLSSocket, event: &JsValue, listener: &JsValue) -> TLSSocket;
    # [ wasm_bindgen ( method , setter , js_name = addListener ) ]
    pub fn set_add_listener5(this: &TLSSocket, value: &Function);
    #[wasm_bindgen(method)]
    pub fn emit(this: &TLSSocket, event: &JsValue, args: &Array) -> bool;
    #[wasm_bindgen(method, setter)]
    pub fn set_emit(this: &TLSSocket, value: &Function);
    # [ wasm_bindgen ( method , js_name = emit ) ]
    pub fn emit2(this: &TLSSocket, event: &JsValue, response: &Buffer) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = emit ) ]
    pub fn set_emit2(this: &TLSSocket, value: &Function);
    # [ wasm_bindgen ( method , js_name = emit ) ]
    pub fn emit3(this: &TLSSocket, event: &JsValue) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = emit ) ]
    pub fn set_emit3(this: &TLSSocket, value: &Function);
    # [ wasm_bindgen ( method , js_name = emit ) ]
    pub fn emit4(this: &TLSSocket, event: &JsValue, session: &Buffer) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = emit ) ]
    pub fn set_emit4(this: &TLSSocket, value: &Function);
    # [ wasm_bindgen ( method , js_name = emit ) ]
    pub fn emit5(this: &TLSSocket, event: &JsValue, line: &Buffer) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = emit ) ]
    pub fn set_emit5(this: &TLSSocket, value: &Function);
    #[wasm_bindgen(method)]
    pub fn on(this: &TLSSocket, event: &str, listener: &JsValue) -> TLSSocket;
    #[wasm_bindgen(method, setter)]
    pub fn set_on(this: &TLSSocket, value: &Function);
    # [ wasm_bindgen ( method , js_name = on ) ]
    pub fn on2(this: &TLSSocket, event: &JsValue, listener: &JsValue) -> TLSSocket;
    # [ wasm_bindgen ( method , setter , js_name = on ) ]
    pub fn set_on2(this: &TLSSocket, value: &Function);
    # [ wasm_bindgen ( method , js_name = on ) ]
    pub fn on3(this: &TLSSocket, event: &JsValue, listener: &JsValue) -> TLSSocket;
    # [ wasm_bindgen ( method , setter , js_name = on ) ]
    pub fn set_on3(this: &TLSSocket, value: &Function);
    # [ wasm_bindgen ( method , js_name = on ) ]
    pub fn on4(this: &TLSSocket, event: &JsValue, listener: &JsValue) -> TLSSocket;
    # [ wasm_bindgen ( method , setter , js_name = on ) ]
    pub fn set_on4(this: &TLSSocket, value: &Function);
    # [ wasm_bindgen ( method , js_name = on ) ]
    pub fn on5(this: &TLSSocket, event: &JsValue, listener: &JsValue) -> TLSSocket;
    # [ wasm_bindgen ( method , setter , js_name = on ) ]
    pub fn set_on5(this: &TLSSocket, value: &Function);
    #[wasm_bindgen(method)]
    pub fn once(this: &TLSSocket, event: &str, listener: &JsValue) -> TLSSocket;
    #[wasm_bindgen(method, setter)]
    pub fn set_once(this: &TLSSocket, value: &Function);
    # [ wasm_bindgen ( method , js_name = once ) ]
    pub fn once2(this: &TLSSocket, event: &JsValue, listener: &JsValue) -> TLSSocket;
    # [ wasm_bindgen ( method , setter , js_name = once ) ]
    pub fn set_once2(this: &TLSSocket, value: &Function);
    # [ wasm_bindgen ( method , js_name = once ) ]
    pub fn once3(this: &TLSSocket, event: &JsValue, listener: &JsValue) -> TLSSocket;
    # [ wasm_bindgen ( method , setter , js_name = once ) ]
    pub fn set_once3(this: &TLSSocket, value: &Function);
    # [ wasm_bindgen ( method , js_name = once ) ]
    pub fn once4(this: &TLSSocket, event: &JsValue, listener: &JsValue) -> TLSSocket;
    # [ wasm_bindgen ( method , setter , js_name = once ) ]
    pub fn set_once4(this: &TLSSocket, value: &Function);
    # [ wasm_bindgen ( method , js_name = once ) ]
    pub fn once5(this: &TLSSocket, event: &JsValue, listener: &JsValue) -> TLSSocket;
    # [ wasm_bindgen ( method , setter , js_name = once ) ]
    pub fn set_once5(this: &TLSSocket, value: &Function);
    # [ wasm_bindgen ( method , js_name = prependListener ) ]
    pub fn prepend_listener(this: &TLSSocket, event: &str, listener: &JsValue) -> TLSSocket;
    # [ wasm_bindgen ( method , setter , js_name = prependListener ) ]
    pub fn set_prepend_listener(this: &TLSSocket, value: &Function);
    # [ wasm_bindgen ( method , js_name = prependListener ) ]
    pub fn prepend_listener2(this: &TLSSocket, event: &JsValue, listener: &JsValue) -> TLSSocket;
    # [ wasm_bindgen ( method , setter , js_name = prependListener ) ]
    pub fn set_prepend_listener2(this: &TLSSocket, value: &Function);
    # [ wasm_bindgen ( method , js_name = prependListener ) ]
    pub fn prepend_listener3(this: &TLSSocket, event: &JsValue, listener: &JsValue) -> TLSSocket;
    # [ wasm_bindgen ( method , setter , js_name = prependListener ) ]
    pub fn set_prepend_listener3(this: &TLSSocket, value: &Function);
    # [ wasm_bindgen ( method , js_name = prependListener ) ]
    pub fn prepend_listener4(this: &TLSSocket, event: &JsValue, listener: &JsValue) -> TLSSocket;
    # [ wasm_bindgen ( method , setter , js_name = prependListener ) ]
    pub fn set_prepend_listener4(this: &TLSSocket, value: &Function);
    # [ wasm_bindgen ( method , js_name = prependListener ) ]
    pub fn prepend_listener5(this: &TLSSocket, event: &JsValue, listener: &JsValue) -> TLSSocket;
    # [ wasm_bindgen ( method , setter , js_name = prependListener ) ]
    pub fn set_prepend_listener5(this: &TLSSocket, value: &Function);
    # [ wasm_bindgen ( method , js_name = prependOnceListener ) ]
    pub fn prepend_once_listener(this: &TLSSocket, event: &str, listener: &JsValue) -> TLSSocket;
    # [ wasm_bindgen ( method , setter , js_name = prependOnceListener ) ]
    pub fn set_prepend_once_listener(this: &TLSSocket, value: &Function);
    # [ wasm_bindgen ( method , js_name = prependOnceListener ) ]
    pub fn prepend_once_listener2(
        this: &TLSSocket,
        event: &JsValue,
        listener: &JsValue,
    ) -> TLSSocket;
    # [ wasm_bindgen ( method , setter , js_name = prependOnceListener ) ]
    pub fn set_prepend_once_listener2(this: &TLSSocket, value: &Function);
    # [ wasm_bindgen ( method , js_name = prependOnceListener ) ]
    pub fn prepend_once_listener3(
        this: &TLSSocket,
        event: &JsValue,
        listener: &JsValue,
    ) -> TLSSocket;
    # [ wasm_bindgen ( method , setter , js_name = prependOnceListener ) ]
    pub fn set_prepend_once_listener3(this: &TLSSocket, value: &Function);
    # [ wasm_bindgen ( method , js_name = prependOnceListener ) ]
    pub fn prepend_once_listener4(
        this: &TLSSocket,
        event: &JsValue,
        listener: &JsValue,
    ) -> TLSSocket;
    # [ wasm_bindgen ( method , setter , js_name = prependOnceListener ) ]
    pub fn set_prepend_once_listener4(this: &TLSSocket, value: &Function);
    # [ wasm_bindgen ( method , js_name = prependOnceListener ) ]
    pub fn prepend_once_listener5(
        this: &TLSSocket,
        event: &JsValue,
        listener: &JsValue,
    ) -> TLSSocket;
    # [ wasm_bindgen ( method , setter , js_name = prependOnceListener ) ]
    pub fn set_prepend_once_listener5(this: &TLSSocket, value: &Function);
    pub type CommonConnectionOptions;
    #[doc = "An optional TLS context object from tls.createSecureContext()"]
    # [ wasm_bindgen ( method , getter , js_name = secureContext ) ]
    pub fn secure_context(this: &CommonConnectionOptions) -> Option<SecureContext>;
    # [ wasm_bindgen ( method , setter , js_name = secureContext ) ]
    pub fn set_secure_context(this: &CommonConnectionOptions, value: Option<&SecureContext>);
    #[doc = "When enabled, TLS packet trace information is written to `stderr`. This can be"]
    #[doc = "used to debug TLS connection problems."]
    # [ wasm_bindgen ( method , getter , js_name = enableTrace ) ]
    pub fn enable_trace(this: &CommonConnectionOptions) -> Option<bool>;
    # [ wasm_bindgen ( method , setter , js_name = enableTrace ) ]
    pub fn set_enable_trace(this: &CommonConnectionOptions, value: Option<bool>);
    #[doc = "If true the server will request a certificate from clients that"]
    #[doc = "connect and attempt to verify that certificate. Defaults to"]
    #[doc = "false."]
    # [ wasm_bindgen ( method , getter , js_name = requestCert ) ]
    pub fn request_cert(this: &CommonConnectionOptions) -> Option<bool>;
    # [ wasm_bindgen ( method , setter , js_name = requestCert ) ]
    pub fn set_request_cert(this: &CommonConnectionOptions, value: Option<bool>);
    #[doc = "An array of strings or a Buffer naming possible ALPN protocols."]
    #[doc = "(Protocols should be ordered by their priority.)"]
    # [ wasm_bindgen ( method , getter , js_name = ALPNProtocols ) ]
    pub fn alpn_protocols(this: &CommonConnectionOptions) -> JsValue;
    # [ wasm_bindgen ( method , setter , js_name = ALPNProtocols ) ]
    pub fn set_alpn_protocols(this: &CommonConnectionOptions, value: &JsValue);
    #[doc = "SNICallback(servername, cb) <Function> A function that will be"]
    #[doc = "called if the client supports SNI TLS extension. Two arguments"]
    #[doc = "will be passed when called: servername and cb. SNICallback should"]
    #[doc = "invoke cb(null, ctx), where ctx is a SecureContext instance."]
    #[doc = "(tls.createSecureContext(...) can be used to get a proper"]
    #[doc = "SecureContext.) If SNICallback wasn't provided the default callback"]
    #[doc = "with high-level API will be used (see below)."]
    # [ wasm_bindgen ( method , getter , js_name = SNICallback ) ]
    pub fn sni_callback(this: &CommonConnectionOptions) -> Option<Function>;
    # [ wasm_bindgen ( method , setter , js_name = SNICallback ) ]
    pub fn set_sni_callback(this: &CommonConnectionOptions, value: Option<&Function>);
    #[doc = "If true the server will reject any connection which is not"]
    #[doc = "authorized with the list of supplied CAs. This option only has an"]
    #[doc = "effect if requestCert is true."]
    # [ wasm_bindgen ( method , getter , js_name = rejectUnauthorized ) ]
    pub fn reject_unauthorized(this: &CommonConnectionOptions) -> Option<bool>;
    # [ wasm_bindgen ( method , setter , js_name = rejectUnauthorized ) ]
    pub fn set_reject_unauthorized(this: &CommonConnectionOptions, value: Option<bool>);
    pub type TlsOptions;
    #[doc = "Abort the connection if the SSL/TLS handshake does not finish in the"]
    #[doc = "specified number of milliseconds. A 'tlsClientError' is emitted on"]
    #[doc = "the tls.Server object whenever a handshake times out. Default:"]
    #[doc = "120000 (120 seconds)."]
    # [ wasm_bindgen ( method , getter , js_name = handshakeTimeout ) ]
    pub fn handshake_timeout(this: &TlsOptions) -> Option<f64>;
    # [ wasm_bindgen ( method , setter , js_name = handshakeTimeout ) ]
    pub fn set_handshake_timeout(this: &TlsOptions, value: Option<f64>);
    #[doc = "The number of seconds after which a TLS session created by the"]
    #[doc = "server will no longer be resumable. See Session Resumption for more"]
    #[doc = "information. Default: 300."]
    # [ wasm_bindgen ( method , getter , js_name = sessionTimeout ) ]
    pub fn session_timeout(this: &TlsOptions) -> Option<f64>;
    # [ wasm_bindgen ( method , setter , js_name = sessionTimeout ) ]
    pub fn set_session_timeout(this: &TlsOptions, value: Option<f64>);
    #[doc = "48-bytes of cryptographically strong pseudo-random data."]
    # [ wasm_bindgen ( method , getter , js_name = ticketKeys ) ]
    pub fn ticket_keys(this: &TlsOptions) -> Option<Buffer>;
    # [ wasm_bindgen ( method , setter , js_name = ticketKeys ) ]
    pub fn set_ticket_keys(this: &TlsOptions, value: Option<&Buffer>);
    pub type ConnectionOptions;
    #[wasm_bindgen(method, getter)]
    pub fn host(this: &ConnectionOptions) -> Option<String>;
    #[wasm_bindgen(method, setter)]
    pub fn set_host(this: &ConnectionOptions, value: Option<&str>);
    #[wasm_bindgen(method, getter)]
    pub fn port(this: &ConnectionOptions) -> Option<f64>;
    #[wasm_bindgen(method, setter)]
    pub fn set_port(this: &ConnectionOptions, value: Option<f64>);
    #[wasm_bindgen(method, getter)]
    pub fn path(this: &ConnectionOptions) -> Option<String>;
    #[wasm_bindgen(method, setter)]
    pub fn set_path(this: &ConnectionOptions, value: Option<&str>);
    #[wasm_bindgen(method, getter)]
    pub fn socket(this: &ConnectionOptions) -> Option<crate::net::Socket>;
    #[wasm_bindgen(method, setter)]
    pub fn set_socket(this: &ConnectionOptions, value: Option<&crate::net::Socket>);
    # [ wasm_bindgen ( method , getter , js_name = checkServerIdentity ) ]
    pub fn check_server_identity(this: &ConnectionOptions) -> JsValue;
    # [ wasm_bindgen ( method , setter , js_name = checkServerIdentity ) ]
    pub fn set_check_server_identity(this: &ConnectionOptions, value: &JsValue);
    #[wasm_bindgen(method, getter)]
    pub fn servername(this: &ConnectionOptions) -> Option<String>;
    #[wasm_bindgen(method, setter)]
    pub fn set_servername(this: &ConnectionOptions, value: Option<&str>);
    #[wasm_bindgen(method, getter)]
    pub fn session(this: &ConnectionOptions) -> Option<Buffer>;
    #[wasm_bindgen(method, setter)]
    pub fn set_session(this: &ConnectionOptions, value: Option<&Buffer>);
    # [ wasm_bindgen ( method , getter , js_name = minDHSize ) ]
    pub fn min_dh_size(this: &ConnectionOptions) -> Option<f64>;
    # [ wasm_bindgen ( method , setter , js_name = minDHSize ) ]
    pub fn set_min_dh_size(this: &ConnectionOptions, value: Option<f64>);
    #[wasm_bindgen(method, getter)]
    pub fn lookup(this: &ConnectionOptions) -> Option<crate::net::LookupFunction>;
    #[wasm_bindgen(method, setter)]
    pub fn set_lookup(this: &ConnectionOptions, value: Option<&crate::net::LookupFunction>);
    #[wasm_bindgen(method, getter)]
    pub fn timeout(this: &ConnectionOptions) -> Option<f64>;
    #[wasm_bindgen(method, setter)]
    pub fn set_timeout(this: &ConnectionOptions, value: Option<f64>);
    pub type Server;
    #[doc = "The server.addContext() method adds a secure context that will be"]
    #[doc = "used if the client request's SNI name matches the supplied hostname"]
    #[doc = "(or wildcard)."]
    # [ wasm_bindgen ( method , js_name = addContext ) ]
    pub fn add_context(this: &Server, host_name: &str, credentials: &SecureContextOptions);
    # [ wasm_bindgen ( method , setter , js_name = addContext ) ]
    pub fn set_add_context(this: &Server, value: &Function);
    #[doc = "Returns the session ticket keys."]
    # [ wasm_bindgen ( method , js_name = getTicketKeys ) ]
    pub fn get_ticket_keys(this: &Server) -> Buffer;
    # [ wasm_bindgen ( method , setter , js_name = getTicketKeys ) ]
    pub fn set_get_ticket_keys(this: &Server, value: &Function);
    #[doc = "The server.setSecureContext() method replaces the"]
    #[doc = "secure context of an existing server. Existing connections to the"]
    #[doc = "server are not interrupted."]
    # [ wasm_bindgen ( method , js_name = setSecureContext ) ]
    pub fn set_secure_context(this: &Server, details: &SecureContextOptions);
    # [ wasm_bindgen ( method , setter , js_name = setSecureContext ) ]
    pub fn set_set_secure_context(this: &Server, value: &Function);
    #[doc = "The server.setSecureContext() method replaces the secure context of"]
    #[doc = "an existing server. Existing connections to the server are not"]
    #[doc = "interrupted."]
    # [ wasm_bindgen ( method , js_name = setTicketKeys ) ]
    pub fn set_ticket_keys(this: &Server, keys: &Buffer);
    # [ wasm_bindgen ( method , setter , js_name = setTicketKeys ) ]
    pub fn set_set_ticket_keys(this: &Server, value: &Function);
    #[doc = "events.EventEmitter"]
    #[doc = "1. tlsClientError"]
    #[doc = "2. newSession"]
    #[doc = "3. OCSPRequest"]
    #[doc = "4. resumeSession"]
    #[doc = "5. secureConnection"]
    #[doc = "6. keylog"]
    # [ wasm_bindgen ( method , js_name = addListener ) ]
    pub fn add_listener(this: &Server, event: &str, listener: &JsValue) -> Server;
    # [ wasm_bindgen ( method , setter , js_name = addListener ) ]
    pub fn set_add_listener(this: &Server, value: &Function);
    #[doc = "events.EventEmitter"]
    #[doc = "1. tlsClientError"]
    #[doc = "2. newSession"]
    #[doc = "3. OCSPRequest"]
    #[doc = "4. resumeSession"]
    #[doc = "5. secureConnection"]
    #[doc = "6. keylog"]
    # [ wasm_bindgen ( method , js_name = addListener ) ]
    pub fn add_listener2(this: &Server, event: &JsValue, listener: &JsValue) -> Server;
    # [ wasm_bindgen ( method , setter , js_name = addListener ) ]
    pub fn set_add_listener2(this: &Server, value: &Function);
    #[doc = "events.EventEmitter"]
    #[doc = "1. tlsClientError"]
    #[doc = "2. newSession"]
    #[doc = "3. OCSPRequest"]
    #[doc = "4. resumeSession"]
    #[doc = "5. secureConnection"]
    #[doc = "6. keylog"]
    # [ wasm_bindgen ( method , js_name = addListener ) ]
    pub fn add_listener3(this: &Server, event: &JsValue, listener: &JsValue) -> Server;
    # [ wasm_bindgen ( method , setter , js_name = addListener ) ]
    pub fn set_add_listener3(this: &Server, value: &Function);
    #[doc = "events.EventEmitter"]
    #[doc = "1. tlsClientError"]
    #[doc = "2. newSession"]
    #[doc = "3. OCSPRequest"]
    #[doc = "4. resumeSession"]
    #[doc = "5. secureConnection"]
    #[doc = "6. keylog"]
    # [ wasm_bindgen ( method , js_name = addListener ) ]
    pub fn add_listener4(this: &Server, event: &JsValue, listener: &JsValue) -> Server;
    # [ wasm_bindgen ( method , setter , js_name = addListener ) ]
    pub fn set_add_listener4(this: &Server, value: &Function);
    #[doc = "events.EventEmitter"]
    #[doc = "1. tlsClientError"]
    #[doc = "2. newSession"]
    #[doc = "3. OCSPRequest"]
    #[doc = "4. resumeSession"]
    #[doc = "5. secureConnection"]
    #[doc = "6. keylog"]
    # [ wasm_bindgen ( method , js_name = addListener ) ]
    pub fn add_listener5(this: &Server, event: &JsValue, listener: &JsValue) -> Server;
    # [ wasm_bindgen ( method , setter , js_name = addListener ) ]
    pub fn set_add_listener5(this: &Server, value: &Function);
    #[doc = "events.EventEmitter"]
    #[doc = "1. tlsClientError"]
    #[doc = "2. newSession"]
    #[doc = "3. OCSPRequest"]
    #[doc = "4. resumeSession"]
    #[doc = "5. secureConnection"]
    #[doc = "6. keylog"]
    # [ wasm_bindgen ( method , js_name = addListener ) ]
    pub fn add_listener6(this: &Server, event: &JsValue, listener: &JsValue) -> Server;
    # [ wasm_bindgen ( method , setter , js_name = addListener ) ]
    pub fn set_add_listener6(this: &Server, value: &Function);
    #[doc = "events.EventEmitter"]
    #[doc = "1. tlsClientError"]
    #[doc = "2. newSession"]
    #[doc = "3. OCSPRequest"]
    #[doc = "4. resumeSession"]
    #[doc = "5. secureConnection"]
    #[doc = "6. keylog"]
    # [ wasm_bindgen ( method , js_name = addListener ) ]
    pub fn add_listener7(this: &Server, event: &JsValue, listener: &JsValue) -> Server;
    # [ wasm_bindgen ( method , setter , js_name = addListener ) ]
    pub fn set_add_listener7(this: &Server, value: &Function);
    #[wasm_bindgen(method)]
    pub fn emit(this: &Server, event: &JsValue, args: &Array) -> bool;
    #[wasm_bindgen(method, setter)]
    pub fn set_emit(this: &Server, value: &Function);
    # [ wasm_bindgen ( method , js_name = emit ) ]
    pub fn emit2(this: &Server, event: &JsValue, err: &Error, tls_socket: &TLSSocket) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = emit ) ]
    pub fn set_emit2(this: &Server, value: &Function);
    # [ wasm_bindgen ( method , js_name = emit ) ]
    pub fn emit3(
        this: &Server,
        event: &JsValue,
        session_id: &Buffer,
        session_data: &Buffer,
        callback: &JsValue,
    ) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = emit ) ]
    pub fn set_emit3(this: &Server, value: &Function);
    # [ wasm_bindgen ( method , js_name = emit ) ]
    pub fn emit4(
        this: &Server,
        event: &JsValue,
        certificate: &Buffer,
        issuer: &Buffer,
        callback: &JsValue,
    ) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = emit ) ]
    pub fn set_emit4(this: &Server, value: &Function);
    # [ wasm_bindgen ( method , js_name = emit ) ]
    pub fn emit5(this: &Server, event: &JsValue, session_id: &Buffer, callback: &JsValue) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = emit ) ]
    pub fn set_emit5(this: &Server, value: &Function);
    # [ wasm_bindgen ( method , js_name = emit ) ]
    pub fn emit6(this: &Server, event: &JsValue, tls_socket: &TLSSocket) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = emit ) ]
    pub fn set_emit6(this: &Server, value: &Function);
    # [ wasm_bindgen ( method , js_name = emit ) ]
    pub fn emit7(this: &Server, event: &JsValue, line: &Buffer, tls_socket: &TLSSocket) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = emit ) ]
    pub fn set_emit7(this: &Server, value: &Function);
    #[wasm_bindgen(method)]
    pub fn on(this: &Server, event: &str, listener: &JsValue) -> Server;
    #[wasm_bindgen(method, setter)]
    pub fn set_on(this: &Server, value: &Function);
    # [ wasm_bindgen ( method , js_name = on ) ]
    pub fn on2(this: &Server, event: &JsValue, listener: &JsValue) -> Server;
    # [ wasm_bindgen ( method , setter , js_name = on ) ]
    pub fn set_on2(this: &Server, value: &Function);
    # [ wasm_bindgen ( method , js_name = on ) ]
    pub fn on3(this: &Server, event: &JsValue, listener: &JsValue) -> Server;
    # [ wasm_bindgen ( method , setter , js_name = on ) ]
    pub fn set_on3(this: &Server, value: &Function);
    # [ wasm_bindgen ( method , js_name = on ) ]
    pub fn on4(this: &Server, event: &JsValue, listener: &JsValue) -> Server;
    # [ wasm_bindgen ( method , setter , js_name = on ) ]
    pub fn set_on4(this: &Server, value: &Function);
    # [ wasm_bindgen ( method , js_name = on ) ]
    pub fn on5(this: &Server, event: &JsValue, listener: &JsValue) -> Server;
    # [ wasm_bindgen ( method , setter , js_name = on ) ]
    pub fn set_on5(this: &Server, value: &Function);
    # [ wasm_bindgen ( method , js_name = on ) ]
    pub fn on6(this: &Server, event: &JsValue, listener: &JsValue) -> Server;
    # [ wasm_bindgen ( method , setter , js_name = on ) ]
    pub fn set_on6(this: &Server, value: &Function);
    # [ wasm_bindgen ( method , js_name = on ) ]
    pub fn on7(this: &Server, event: &JsValue, listener: &JsValue) -> Server;
    # [ wasm_bindgen ( method , setter , js_name = on ) ]
    pub fn set_on7(this: &Server, value: &Function);
    #[wasm_bindgen(method)]
    pub fn once(this: &Server, event: &str, listener: &JsValue) -> Server;
    #[wasm_bindgen(method, setter)]
    pub fn set_once(this: &Server, value: &Function);
    # [ wasm_bindgen ( method , js_name = once ) ]
    pub fn once2(this: &Server, event: &JsValue, listener: &JsValue) -> Server;
    # [ wasm_bindgen ( method , setter , js_name = once ) ]
    pub fn set_once2(this: &Server, value: &Function);
    # [ wasm_bindgen ( method , js_name = once ) ]
    pub fn once3(this: &Server, event: &JsValue, listener: &JsValue) -> Server;
    # [ wasm_bindgen ( method , setter , js_name = once ) ]
    pub fn set_once3(this: &Server, value: &Function);
    # [ wasm_bindgen ( method , js_name = once ) ]
    pub fn once4(this: &Server, event: &JsValue, listener: &JsValue) -> Server;
    # [ wasm_bindgen ( method , setter , js_name = once ) ]
    pub fn set_once4(this: &Server, value: &Function);
    # [ wasm_bindgen ( method , js_name = once ) ]
    pub fn once5(this: &Server, event: &JsValue, listener: &JsValue) -> Server;
    # [ wasm_bindgen ( method , setter , js_name = once ) ]
    pub fn set_once5(this: &Server, value: &Function);
    # [ wasm_bindgen ( method , js_name = once ) ]
    pub fn once6(this: &Server, event: &JsValue, listener: &JsValue) -> Server;
    # [ wasm_bindgen ( method , setter , js_name = once ) ]
    pub fn set_once6(this: &Server, value: &Function);
    # [ wasm_bindgen ( method , js_name = once ) ]
    pub fn once7(this: &Server, event: &JsValue, listener: &JsValue) -> Server;
    # [ wasm_bindgen ( method , setter , js_name = once ) ]
    pub fn set_once7(this: &Server, value: &Function);
    # [ wasm_bindgen ( method , js_name = prependListener ) ]
    pub fn prepend_listener(this: &Server, event: &str, listener: &JsValue) -> Server;
    # [ wasm_bindgen ( method , setter , js_name = prependListener ) ]
    pub fn set_prepend_listener(this: &Server, value: &Function);
    # [ wasm_bindgen ( method , js_name = prependListener ) ]
    pub fn prepend_listener2(this: &Server, event: &JsValue, listener: &JsValue) -> Server;
    # [ wasm_bindgen ( method , setter , js_name = prependListener ) ]
    pub fn set_prepend_listener2(this: &Server, value: &Function);
    # [ wasm_bindgen ( method , js_name = prependListener ) ]
    pub fn prepend_listener3(this: &Server, event: &JsValue, listener: &JsValue) -> Server;
    # [ wasm_bindgen ( method , setter , js_name = prependListener ) ]
    pub fn set_prepend_listener3(this: &Server, value: &Function);
    # [ wasm_bindgen ( method , js_name = prependListener ) ]
    pub fn prepend_listener4(this: &Server, event: &JsValue, listener: &JsValue) -> Server;
    # [ wasm_bindgen ( method , setter , js_name = prependListener ) ]
    pub fn set_prepend_listener4(this: &Server, value: &Function);
    # [ wasm_bindgen ( method , js_name = prependListener ) ]
    pub fn prepend_listener5(this: &Server, event: &JsValue, listener: &JsValue) -> Server;
    # [ wasm_bindgen ( method , setter , js_name = prependListener ) ]
    pub fn set_prepend_listener5(this: &Server, value: &Function);
    # [ wasm_bindgen ( method , js_name = prependListener ) ]
    pub fn prepend_listener6(this: &Server, event: &JsValue, listener: &JsValue) -> Server;
    # [ wasm_bindgen ( method , setter , js_name = prependListener ) ]
    pub fn set_prepend_listener6(this: &Server, value: &Function);
    # [ wasm_bindgen ( method , js_name = prependListener ) ]
    pub fn prepend_listener7(this: &Server, event: &JsValue, listener: &JsValue) -> Server;
    # [ wasm_bindgen ( method , setter , js_name = prependListener ) ]
    pub fn set_prepend_listener7(this: &Server, value: &Function);
    # [ wasm_bindgen ( method , js_name = prependOnceListener ) ]
    pub fn prepend_once_listener(this: &Server, event: &str, listener: &JsValue) -> Server;
    # [ wasm_bindgen ( method , setter , js_name = prependOnceListener ) ]
    pub fn set_prepend_once_listener(this: &Server, value: &Function);
    # [ wasm_bindgen ( method , js_name = prependOnceListener ) ]
    pub fn prepend_once_listener2(this: &Server, event: &JsValue, listener: &JsValue) -> Server;
    # [ wasm_bindgen ( method , setter , js_name = prependOnceListener ) ]
    pub fn set_prepend_once_listener2(this: &Server, value: &Function);
    # [ wasm_bindgen ( method , js_name = prependOnceListener ) ]
    pub fn prepend_once_listener3(this: &Server, event: &JsValue, listener: &JsValue) -> Server;
    # [ wasm_bindgen ( method , setter , js_name = prependOnceListener ) ]
    pub fn set_prepend_once_listener3(this: &Server, value: &Function);
    # [ wasm_bindgen ( method , js_name = prependOnceListener ) ]
    pub fn prepend_once_listener4(this: &Server, event: &JsValue, listener: &JsValue) -> Server;
    # [ wasm_bindgen ( method , setter , js_name = prependOnceListener ) ]
    pub fn set_prepend_once_listener4(this: &Server, value: &Function);
    # [ wasm_bindgen ( method , js_name = prependOnceListener ) ]
    pub fn prepend_once_listener5(this: &Server, event: &JsValue, listener: &JsValue) -> Server;
    # [ wasm_bindgen ( method , setter , js_name = prependOnceListener ) ]
    pub fn set_prepend_once_listener5(this: &Server, value: &Function);
    # [ wasm_bindgen ( method , js_name = prependOnceListener ) ]
    pub fn prepend_once_listener6(this: &Server, event: &JsValue, listener: &JsValue) -> Server;
    # [ wasm_bindgen ( method , setter , js_name = prependOnceListener ) ]
    pub fn set_prepend_once_listener6(this: &Server, value: &Function);
    # [ wasm_bindgen ( method , js_name = prependOnceListener ) ]
    pub fn prepend_once_listener7(this: &Server, event: &JsValue, listener: &JsValue) -> Server;
    # [ wasm_bindgen ( method , setter , js_name = prependOnceListener ) ]
    pub fn set_prepend_once_listener7(this: &Server, value: &Function);
    pub type SecurePair;
    #[wasm_bindgen(method, getter)]
    pub fn encrypted(this: &SecurePair) -> TLSSocket;
    #[wasm_bindgen(method, setter)]
    pub fn set_encrypted(this: &SecurePair, value: &TLSSocket);
    #[wasm_bindgen(method, getter)]
    pub fn cleartext(this: &SecurePair) -> TLSSocket;
    #[wasm_bindgen(method, setter)]
    pub fn set_cleartext(this: &SecurePair, value: &TLSSocket);
    pub type SecureVersion;
    pub type SecureContextOptions;
    #[doc = "Optionally override the trusted CA certificates. Default is to trust"]
    #[doc = "the well-known CAs curated by Mozilla. Mozilla's CAs are completely"]
    #[doc = "replaced when CAs are explicitly specified using this option."]
    #[wasm_bindgen(method, getter)]
    pub fn ca(this: &SecureContextOptions) -> JsValue;
    #[wasm_bindgen(method, setter)]
    pub fn set_ca(this: &SecureContextOptions, value: &JsValue);
    #[doc = "Cert chains in PEM format. One cert chain should be provided per"]
    #[doc = "private key. Each cert chain should consist of the PEM formatted"]
    #[doc = "certificate for a provided private key, followed by the PEM"]
    #[doc = "formatted intermediate certificates (if any), in order, and not"]
    #[doc = "including the root CA (the root CA must be pre-known to the peer,"]
    #[doc = "see ca). When providing multiple cert chains, they do not have to"]
    #[doc = "be in the same order as their private keys in key. If the"]
    #[doc = "intermediate certificates are not provided, the peer will not be"]
    #[doc = "able to validate the certificate, and the handshake will fail."]
    #[wasm_bindgen(method, getter)]
    pub fn cert(this: &SecureContextOptions) -> JsValue;
    #[wasm_bindgen(method, setter)]
    pub fn set_cert(this: &SecureContextOptions, value: &JsValue);
    #[doc = "Colon-separated list of supported signature algorithms. The list"]
    #[doc = "can contain digest algorithms (SHA256, MD5 etc.), public key"]
    #[doc = "algorithms (RSA-PSS, ECDSA etc.), combination of both (e.g"]
    #[doc = "'RSA+SHA384') or TLS v1.3 scheme names (e.g. rsa_pss_pss_sha512)."]
    #[wasm_bindgen(method, getter)]
    pub fn sigalgs(this: &SecureContextOptions) -> Option<String>;
    #[wasm_bindgen(method, setter)]
    pub fn set_sigalgs(this: &SecureContextOptions, value: Option<&str>);
    #[doc = "Cipher suite specification, replacing the default. For more"]
    #[doc = "information, see modifying the default cipher suite. Permitted"]
    #[doc = "ciphers can be obtained via tls.getCiphers(). Cipher names must be"]
    #[doc = "uppercased in order for OpenSSL to accept them."]
    #[wasm_bindgen(method, getter)]
    pub fn ciphers(this: &SecureContextOptions) -> Option<String>;
    #[wasm_bindgen(method, setter)]
    pub fn set_ciphers(this: &SecureContextOptions, value: Option<&str>);
    #[doc = "Name of an OpenSSL engine which can provide the client certificate."]
    # [ wasm_bindgen ( method , getter , js_name = clientCertEngine ) ]
    pub fn client_cert_engine(this: &SecureContextOptions) -> Option<String>;
    # [ wasm_bindgen ( method , setter , js_name = clientCertEngine ) ]
    pub fn set_client_cert_engine(this: &SecureContextOptions, value: Option<&str>);
    #[doc = "PEM formatted CRLs (Certificate Revocation Lists)."]
    #[wasm_bindgen(method, getter)]
    pub fn crl(this: &SecureContextOptions) -> JsValue;
    #[wasm_bindgen(method, setter)]
    pub fn set_crl(this: &SecureContextOptions, value: &JsValue);
    #[doc = "Diffie Hellman parameters, required for Perfect Forward Secrecy. Use"]
    #[doc = "openssl dhparam to create the parameters. The key length must be"]
    #[doc = "greater than or equal to 1024 bits or else an error will be thrown."]
    #[doc = "Although 1024 bits is permissible, use 2048 bits or larger for"]
    #[doc = "stronger security. If omitted or invalid, the parameters are"]
    #[doc = "silently discarded and DHE ciphers will not be available."]
    #[wasm_bindgen(method, getter)]
    pub fn dhparam(this: &SecureContextOptions) -> JsValue;
    #[wasm_bindgen(method, setter)]
    pub fn set_dhparam(this: &SecureContextOptions, value: &JsValue);
    #[doc = "A string describing a named curve or a colon separated list of curve"]
    #[doc = "NIDs or names, for example P-521:P-384:P-256, to use for ECDH key"]
    #[doc = "agreement. Set to auto to select the curve automatically. Use"]
    #[doc = "crypto.getCurves() to obtain a list of available curve names. On"]
    #[doc = "recent releases, openssl ecparam -list_curves will also display the"]
    #[doc = "name and description of each available elliptic curve. Default:"]
    #[doc = "tls.DEFAULT_ECDH_CURVE."]
    # [ wasm_bindgen ( method , getter , js_name = ecdhCurve ) ]
    pub fn ecdh_curve(this: &SecureContextOptions) -> Option<String>;
    # [ wasm_bindgen ( method , setter , js_name = ecdhCurve ) ]
    pub fn set_ecdh_curve(this: &SecureContextOptions, value: Option<&str>);
    #[doc = "Attempt to use the server's cipher suite preferences instead of the"]
    #[doc = "client's. When true, causes SSL_OP_CIPHER_SERVER_PREFERENCE to be"]
    #[doc = "set in secureOptions"]
    # [ wasm_bindgen ( method , getter , js_name = honorCipherOrder ) ]
    pub fn honor_cipher_order(this: &SecureContextOptions) -> Option<bool>;
    # [ wasm_bindgen ( method , setter , js_name = honorCipherOrder ) ]
    pub fn set_honor_cipher_order(this: &SecureContextOptions, value: Option<bool>);
    #[doc = "Private keys in PEM format. PEM allows the option of private keys"]
    #[doc = "being encrypted. Encrypted keys will be decrypted with"]
    #[doc = "options.passphrase. Multiple keys using different algorithms can be"]
    #[doc = "provided either as an array of unencrypted key strings or buffers,"]
    #[doc = "or an array of objects in the form {pem: <string|buffer>[,"]
    #[doc = "passphrase: <string>]}. The object form can only occur in an array."]
    #[doc = "object.passphrase is optional. Encrypted keys will be decrypted with"]
    #[doc = "object.passphrase if provided, or options.passphrase if it is not."]
    #[wasm_bindgen(method, getter)]
    pub fn key(this: &SecureContextOptions) -> JsValue;
    #[wasm_bindgen(method, setter)]
    pub fn set_key(this: &SecureContextOptions, value: &JsValue);
    #[doc = "Name of an OpenSSL engine to get private key from. Should be used"]
    #[doc = "together with privateKeyIdentifier."]
    # [ wasm_bindgen ( method , getter , js_name = privateKeyEngine ) ]
    pub fn private_key_engine(this: &SecureContextOptions) -> Option<String>;
    # [ wasm_bindgen ( method , setter , js_name = privateKeyEngine ) ]
    pub fn set_private_key_engine(this: &SecureContextOptions, value: Option<&str>);
    #[doc = "Identifier of a private key managed by an OpenSSL engine. Should be"]
    #[doc = "used together with privateKeyEngine. Should not be set together with"]
    #[doc = "key, because both options define a private key in different ways."]
    # [ wasm_bindgen ( method , getter , js_name = privateKeyIdentifier ) ]
    pub fn private_key_identifier(this: &SecureContextOptions) -> Option<String>;
    # [ wasm_bindgen ( method , setter , js_name = privateKeyIdentifier ) ]
    pub fn set_private_key_identifier(this: &SecureContextOptions, value: Option<&str>);
    #[doc = "Optionally set the maximum TLS version to allow. One"]
    #[doc = "of `'TLSv1.3'`, `'TLSv1.2'`, `'TLSv1.1'`, or `'TLSv1'`. Cannot be specified along with the"]
    #[doc = "`secureProtocol` option, use one or the other."]
    #[doc = "**Default:** `'TLSv1.3'`, unless changed using CLI options. Using"]
    #[doc = "`--tls-max-v1.2` sets the default to `'TLSv1.2'`. Using `--tls-max-v1.3` sets the default to"]
    #[doc = "`'TLSv1.3'`. If multiple of the options are provided, the highest maximum is used."]
    # [ wasm_bindgen ( method , getter , js_name = maxVersion ) ]
    pub fn max_version(this: &SecureContextOptions) -> Option<SecureVersion>;
    # [ wasm_bindgen ( method , setter , js_name = maxVersion ) ]
    pub fn set_max_version(this: &SecureContextOptions, value: Option<&SecureVersion>);
    #[doc = "Optionally set the minimum TLS version to allow. One"]
    #[doc = "of `'TLSv1.3'`, `'TLSv1.2'`, `'TLSv1.1'`, or `'TLSv1'`. Cannot be specified along with the"]
    #[doc = "`secureProtocol` option, use one or the other.  It is not recommended to use"]
    #[doc = "less than TLSv1.2, but it may be required for interoperability."]
    #[doc = "**Default:** `'TLSv1.2'`, unless changed using CLI options. Using"]
    #[doc = "`--tls-v1.0` sets the default to `'TLSv1'`. Using `--tls-v1.1` sets the default to"]
    #[doc = "`'TLSv1.1'`. Using `--tls-min-v1.3` sets the default to"]
    #[doc = "'TLSv1.3'. If multiple of the options are provided, the lowest minimum is used."]
    # [ wasm_bindgen ( method , getter , js_name = minVersion ) ]
    pub fn min_version(this: &SecureContextOptions) -> Option<SecureVersion>;
    # [ wasm_bindgen ( method , setter , js_name = minVersion ) ]
    pub fn set_min_version(this: &SecureContextOptions, value: Option<&SecureVersion>);
    #[doc = "Shared passphrase used for a single private key and/or a PFX."]
    #[wasm_bindgen(method, getter)]
    pub fn passphrase(this: &SecureContextOptions) -> Option<String>;
    #[wasm_bindgen(method, setter)]
    pub fn set_passphrase(this: &SecureContextOptions, value: Option<&str>);
    #[doc = "PFX or PKCS12 encoded private key and certificate chain. pfx is an"]
    #[doc = "alternative to providing key and cert individually. PFX is usually"]
    #[doc = "encrypted, if it is, passphrase will be used to decrypt it. Multiple"]
    #[doc = "PFX can be provided either as an array of unencrypted PFX buffers,"]
    #[doc = "or an array of objects in the form {buf: <string|buffer>[,"]
    #[doc = "passphrase: <string>]}. The object form can only occur in an array."]
    #[doc = "object.passphrase is optional. Encrypted PFX will be decrypted with"]
    #[doc = "object.passphrase if provided, or options.passphrase if it is not."]
    #[wasm_bindgen(method, getter)]
    pub fn pfx(this: &SecureContextOptions) -> JsValue;
    #[wasm_bindgen(method, setter)]
    pub fn set_pfx(this: &SecureContextOptions, value: &JsValue);
    #[doc = "Optionally affect the OpenSSL protocol behavior, which is not"]
    #[doc = "usually necessary. This should be used carefully if at all! Value is"]
    #[doc = "a numeric bitmask of the SSL_OP_* options from OpenSSL Options"]
    # [ wasm_bindgen ( method , getter , js_name = secureOptions ) ]
    pub fn secure_options(this: &SecureContextOptions) -> Option<f64>;
    # [ wasm_bindgen ( method , setter , js_name = secureOptions ) ]
    pub fn set_secure_options(this: &SecureContextOptions, value: Option<f64>);
    #[doc = "Legacy mechanism to select the TLS protocol version to use, it does"]
    #[doc = "not support independent control of the minimum and maximum version,"]
    #[doc = "and does not support limiting the protocol to TLSv1.3. Use"]
    #[doc = "minVersion and maxVersion instead. The possible values are listed as"]
    #[doc = "SSL_METHODS, use the function names as strings. For example, use"]
    #[doc = "'TLSv1_1_method' to force TLS version 1.1, or 'TLS_method' to allow"]
    #[doc = "any TLS protocol version up to TLSv1.3. It is not recommended to use"]
    #[doc = "TLS versions less than 1.2, but it may be required for"]
    #[doc = "interoperability. Default: none, see minVersion."]
    # [ wasm_bindgen ( method , getter , js_name = secureProtocol ) ]
    pub fn secure_protocol(this: &SecureContextOptions) -> Option<String>;
    # [ wasm_bindgen ( method , setter , js_name = secureProtocol ) ]
    pub fn set_secure_protocol(this: &SecureContextOptions, value: Option<&str>);
    #[doc = "Opaque identifier used by servers to ensure session state is not"]
    #[doc = "shared between applications. Unused by clients."]
    # [ wasm_bindgen ( method , getter , js_name = sessionIdContext ) ]
    pub fn session_id_context(this: &SecureContextOptions) -> Option<String>;
    # [ wasm_bindgen ( method , setter , js_name = sessionIdContext ) ]
    pub fn set_session_id_context(this: &SecureContextOptions, value: Option<&str>);
    pub type SecureContext;
    #[wasm_bindgen(method, getter)]
    pub fn context(this: &SecureContext) -> JsValue;
    #[wasm_bindgen(method, setter)]
    pub fn set_context(this: &SecureContext, value: &JsValue);
    # [ wasm_bindgen ( js_name = checkServerIdentity ) ]
    pub fn check_server_identity(host: &str, cert: &PeerCertificate) -> Option<Error>;
    # [ wasm_bindgen ( js_name = createServer ) ]
    pub fn create_server(secure_connection_listener: &JsValue) -> Server;
    # [ wasm_bindgen ( js_name = createServer ) ]
    pub fn create_server2(options: &TlsOptions, secure_connection_listener: &JsValue) -> Server;
    #[wasm_bindgen()]
    pub fn connect(options: &ConnectionOptions, secure_connect_listener: &JsValue) -> TLSSocket;
    # [ wasm_bindgen ( js_name = connect ) ]
    pub fn connect2(
        port: f64,
        host: Option<&str>,
        options: Option<&ConnectionOptions>,
        secure_connect_listener: &JsValue,
    ) -> TLSSocket;
    # [ wasm_bindgen ( js_name = connect ) ]
    pub fn connect3(
        port: f64,
        options: Option<&ConnectionOptions>,
        secure_connect_listener: &JsValue,
    ) -> TLSSocket;
    # [ wasm_bindgen ( js_name = createSecurePair ) ]
    pub fn create_secure_pair(
        credentials: Option<&SecureContext>,
        is_server: Option<bool>,
        request_cert: Option<bool>,
        reject_unauthorized: Option<bool>,
    ) -> SecurePair;
    # [ wasm_bindgen ( js_name = createSecureContext ) ]
    pub fn create_secure_context(details: &SecureContextOptions) -> SecureContext;
    # [ wasm_bindgen ( js_name = getCiphers ) ]
    pub fn get_ciphers() -> Array;
    #[doc = "The default curve name to use for ECDH key agreement in a tls server."]
    #[doc = "The default value is 'auto'. See tls.createSecureContext() for further"]
    #[doc = "information."]
    pub static DEFAULT_ECDH_CURVE: String;
    #[doc = "The default value of the maxVersion option of"]
    #[doc = "tls.createSecureContext(). It can be assigned any of the supported TLS"]
    #[doc = "protocol versions, 'TLSv1.3', 'TLSv1.2', 'TLSv1.1', or 'TLSv1'. Default:"]
    #[doc = "'TLSv1.3', unless changed using CLI options. Using --tls-max-v1.2 sets"]
    #[doc = "the default to 'TLSv1.2'. Using --tls-max-v1.3 sets the default to"]
    #[doc = "'TLSv1.3'. If multiple of the options are provided, the highest maximum"]
    #[doc = "is used."]
    pub static DEFAULT_MAX_VERSION: String;
    #[doc = "The default value of the minVersion option of tls.createSecureContext()."]
    #[doc = "It can be assigned any of the supported TLS protocol versions,"]
    #[doc = "'TLSv1.3', 'TLSv1.2', 'TLSv1.1', or 'TLSv1'. Default: 'TLSv1.2', unless"]
    #[doc = "changed using CLI options. Using --tls-min-v1.0 sets the default to"]
    #[doc = "'TLSv1'. Using --tls-min-v1.1 sets the default to 'TLSv1.1'. Using"]
    #[doc = "--tls-min-v1.3 sets the default to 'TLSv1.3'. If multiple of the options"]
    #[doc = "are provided, the lowest minimum is used."]
    pub static DEFAULT_MIN_VERSION: String;
    #[wasm_bindgen(js_name = "rootCertificates")]
    #[doc = "An immutable array of strings representing the root certificates (in PEM"]
    #[doc = "format) used for verifying peer certificates. This is the default value"]
    #[doc = "of the ca option to tls.createSecureContext()."]
    pub static ROOT_CERTIFICATES: String;
}
