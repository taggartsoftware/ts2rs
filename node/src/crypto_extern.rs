// generated by ts2rs 0.1.4
// https://ts2rs.ctaggart.com/

#[wasm_bindgen(module = "crypto")]
extern "C" {
    pub type Certificate;
    # [ wasm_bindgen ( method , js_name = exportChallenge ) ]
    pub fn export_challenge(this: &Certificate, spkac: &crate::crypto::BinaryLike) -> Buffer;
    # [ wasm_bindgen ( method , setter , js_name = exportChallenge ) ]
    pub fn set_export_challenge(this: &Certificate, value: &Function);
    # [ wasm_bindgen ( method , js_name = exportPublicKey ) ]
    pub fn export_public_key(this: &Certificate, spkac: &crate::crypto::BinaryLike) -> Buffer;
    # [ wasm_bindgen ( method , setter , js_name = exportPublicKey ) ]
    pub fn set_export_public_key(this: &Certificate, value: &Function);
    # [ wasm_bindgen ( method , js_name = verifySpkac ) ]
    pub fn verify_spkac(this: &Certificate, spkac: &crate::node_js::ArrayBufferView) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = verifySpkac ) ]
    pub fn set_verify_spkac(this: &Certificate, value: &Function);
    #[wasm_bindgen(js_name = "Certificate")]
    pub static CERTIFICATE: String;
    pub type HashOptions;
    #[doc = "For XOF hash functions such as `shake256`, the"]
    #[doc = "outputLength option can be used to specify the desired output length in bytes."]
    # [ wasm_bindgen ( method , getter , js_name = outputLength ) ]
    pub fn output_length(this: &HashOptions) -> Option<f64>;
    # [ wasm_bindgen ( method , setter , js_name = outputLength ) ]
    pub fn set_output_length(this: &HashOptions, value: Option<f64>);
    #[wasm_bindgen(js_name = "fips")]
    pub static FIPS: String;
    # [ wasm_bindgen ( js_name = createHash ) ]
    pub fn create_hash(
        algorithm: &str,
        options: Option<&crate::crypto::HashOptions>,
    ) -> crate::crypto::Hash;
    # [ wasm_bindgen ( js_name = createHmac ) ]
    pub fn create_hmac(
        algorithm: &str,
        key: &crate::crypto::BinaryLike,
        options: Option<&crate::internal::TransformOptions>,
    ) -> crate::crypto::Hmac;
    pub type Utf8AsciiLatin1Encoding;
    pub type HexBase64Latin1Encoding;
    pub type Utf8AsciiBinaryEncoding;
    pub type HexBase64BinaryEncoding;
    pub type ECDHKeyFormat;
    pub type Hash;
    #[wasm_bindgen(constructor)]
    pub fn new_hash() -> Hash;
    #[wasm_bindgen(method)]
    pub fn update(this: &Hash, data: &crate::crypto::BinaryLike) -> crate::crypto::Hash;
    #[wasm_bindgen(method, setter)]
    pub fn set_update(this: &Hash, value: &Function);
    # [ wasm_bindgen ( method , js_name = update ) ]
    pub fn update2(
        this: &Hash,
        data: &str,
        input_encoding: &crate::crypto::Utf8AsciiLatin1Encoding,
    ) -> crate::crypto::Hash;
    # [ wasm_bindgen ( method , setter , js_name = update ) ]
    pub fn set_update2(this: &Hash, value: &Function);
    #[wasm_bindgen(method)]
    pub fn digest(this: &Hash) -> Buffer;
    #[wasm_bindgen(method, setter)]
    pub fn set_digest(this: &Hash, value: &Function);
    # [ wasm_bindgen ( method , js_name = digest ) ]
    pub fn digest2(this: &Hash, encoding: &crate::crypto::HexBase64Latin1Encoding) -> String;
    # [ wasm_bindgen ( method , setter , js_name = digest ) ]
    pub fn set_digest2(this: &Hash, value: &Function);
    pub type Hmac;
    #[wasm_bindgen(constructor)]
    pub fn new_hmac() -> Hmac;
    #[wasm_bindgen(method)]
    pub fn update(this: &Hmac, data: &crate::crypto::BinaryLike) -> crate::crypto::Hmac;
    #[wasm_bindgen(method, setter)]
    pub fn set_update(this: &Hmac, value: &Function);
    # [ wasm_bindgen ( method , js_name = update ) ]
    pub fn update2(
        this: &Hmac,
        data: &str,
        input_encoding: &crate::crypto::Utf8AsciiLatin1Encoding,
    ) -> crate::crypto::Hmac;
    # [ wasm_bindgen ( method , setter , js_name = update ) ]
    pub fn set_update2(this: &Hmac, value: &Function);
    #[wasm_bindgen(method)]
    pub fn digest(this: &Hmac) -> Buffer;
    #[wasm_bindgen(method, setter)]
    pub fn set_digest(this: &Hmac, value: &Function);
    # [ wasm_bindgen ( method , js_name = digest ) ]
    pub fn digest2(this: &Hmac, encoding: &crate::crypto::HexBase64Latin1Encoding) -> String;
    # [ wasm_bindgen ( method , setter , js_name = digest ) ]
    pub fn set_digest2(this: &Hmac, value: &Function);
    pub type KeyObjectType;
    pub type KeyExportOptions;
    # [ wasm_bindgen ( method , getter , js_name = type ) ]
    pub fn type_(this: &KeyExportOptions) -> JsValue;
    # [ wasm_bindgen ( method , setter , js_name = type ) ]
    pub fn set_type_(this: &KeyExportOptions, value: &JsValue);
    #[wasm_bindgen(method, getter)]
    pub fn format(this: &KeyExportOptions) -> JsValue;
    #[wasm_bindgen(method, setter)]
    pub fn set_format(this: &KeyExportOptions, value: &JsValue);
    #[wasm_bindgen(method, getter)]
    pub fn cipher(this: &KeyExportOptions) -> Option<String>;
    #[wasm_bindgen(method, setter)]
    pub fn set_cipher(this: &KeyExportOptions, value: Option<&str>);
    #[wasm_bindgen(method, getter)]
    pub fn passphrase(this: &KeyExportOptions) -> JsValue;
    #[wasm_bindgen(method, setter)]
    pub fn set_passphrase(this: &KeyExportOptions, value: &JsValue);
    pub type KeyObject;
    #[wasm_bindgen(constructor)]
    pub fn new_key_object() -> KeyObject;
    # [ wasm_bindgen ( method , getter , js_name = asymmetricKeyType ) ]
    pub fn asymmetric_key_type(this: &KeyObject) -> Option<crate::crypto::KeyType>;
    # [ wasm_bindgen ( method , setter , js_name = asymmetricKeyType ) ]
    pub fn set_asymmetric_key_type(this: &KeyObject, value: Option<&crate::crypto::KeyType>);
    #[doc = "For asymmetric keys, this property represents the size of the embedded key in"]
    #[doc = "bytes. This property is `undefined` for symmetric keys."]
    # [ wasm_bindgen ( method , getter , js_name = asymmetricKeySize ) ]
    pub fn asymmetric_key_size(this: &KeyObject) -> Option<f64>;
    # [ wasm_bindgen ( method , setter , js_name = asymmetricKeySize ) ]
    pub fn set_asymmetric_key_size(this: &KeyObject, value: Option<f64>);
    #[wasm_bindgen(method)]
    pub fn export(this: &KeyObject, options: &crate::crypto::KeyExportOptions) -> JsValue;
    #[wasm_bindgen(method, setter)]
    pub fn set_export(this: &KeyObject, value: &Function);
    # [ wasm_bindgen ( method , js_name = export ) ]
    pub fn export2(this: &KeyObject, options: Option<&crate::crypto::KeyExportOptions>) -> Buffer;
    # [ wasm_bindgen ( method , setter , js_name = export ) ]
    pub fn set_export2(this: &KeyObject, value: &Function);
    # [ wasm_bindgen ( method , getter , js_name = symmetricKeySize ) ]
    pub fn symmetric_key_size(this: &KeyObject) -> Option<f64>;
    # [ wasm_bindgen ( method , setter , js_name = symmetricKeySize ) ]
    pub fn set_symmetric_key_size(this: &KeyObject, value: Option<f64>);
    # [ wasm_bindgen ( method , getter , js_name = type ) ]
    pub fn type_(this: &KeyObject) -> crate::crypto::KeyObjectType;
    # [ wasm_bindgen ( method , setter , js_name = type ) ]
    pub fn set_type_(this: &KeyObject, value: &crate::crypto::KeyObjectType);
    pub type CipherCCMTypes;
    pub type CipherGCMTypes;
    pub type BinaryLike;
    pub type CipherKey;
    pub type CipherCCMOptions;
    # [ wasm_bindgen ( method , getter , js_name = authTagLength ) ]
    pub fn auth_tag_length(this: &CipherCCMOptions) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = authTagLength ) ]
    pub fn set_auth_tag_length(this: &CipherCCMOptions, value: f64);
    pub type CipherGCMOptions;
    # [ wasm_bindgen ( method , getter , js_name = authTagLength ) ]
    pub fn auth_tag_length(this: &CipherGCMOptions) -> Option<f64>;
    # [ wasm_bindgen ( method , setter , js_name = authTagLength ) ]
    pub fn set_auth_tag_length(this: &CipherGCMOptions, value: Option<f64>);
    # [ wasm_bindgen ( js_name = createCipher ) ]
    pub fn create_cipher(
        algorithm: &crate::crypto::CipherCCMTypes,
        password: &crate::crypto::BinaryLike,
        options: &crate::crypto::CipherCCMOptions,
    ) -> crate::crypto::CipherCCM;
    # [ wasm_bindgen ( js_name = createCipher ) ]
    pub fn create_cipher2(
        algorithm: &crate::crypto::CipherGCMTypes,
        password: &crate::crypto::BinaryLike,
        options: Option<&crate::crypto::CipherGCMOptions>,
    ) -> crate::crypto::CipherGCM;
    # [ wasm_bindgen ( js_name = createCipher ) ]
    pub fn create_cipher3(
        algorithm: &str,
        password: &crate::crypto::BinaryLike,
        options: Option<&crate::internal::TransformOptions>,
    ) -> crate::crypto::Cipher;
    # [ wasm_bindgen ( js_name = createCipheriv ) ]
    pub fn create_cipheriv(
        algorithm: &crate::crypto::CipherCCMTypes,
        key: &crate::crypto::CipherKey,
        iv: &JsValue,
        options: &crate::crypto::CipherCCMOptions,
    ) -> crate::crypto::CipherCCM;
    # [ wasm_bindgen ( js_name = createCipheriv ) ]
    pub fn create_cipheriv2(
        algorithm: &crate::crypto::CipherGCMTypes,
        key: &crate::crypto::CipherKey,
        iv: &JsValue,
        options: Option<&crate::crypto::CipherGCMOptions>,
    ) -> crate::crypto::CipherGCM;
    # [ wasm_bindgen ( js_name = createCipheriv ) ]
    pub fn create_cipheriv3(
        algorithm: &str,
        key: &crate::crypto::CipherKey,
        iv: &JsValue,
        options: Option<&crate::internal::TransformOptions>,
    ) -> crate::crypto::Cipher;
    pub type Cipher;
    #[wasm_bindgen(constructor)]
    pub fn new_cipher() -> Cipher;
    #[wasm_bindgen(method)]
    pub fn update(this: &Cipher, data: &crate::crypto::BinaryLike) -> Buffer;
    #[wasm_bindgen(method, setter)]
    pub fn set_update(this: &Cipher, value: &Function);
    # [ wasm_bindgen ( method , js_name = update ) ]
    pub fn update2(
        this: &Cipher,
        data: &str,
        input_encoding: &crate::crypto::Utf8AsciiBinaryEncoding,
    ) -> Buffer;
    # [ wasm_bindgen ( method , setter , js_name = update ) ]
    pub fn set_update2(this: &Cipher, value: &Function);
    # [ wasm_bindgen ( method , js_name = update ) ]
    pub fn update3(
        this: &Cipher,
        data: &crate::node_js::ArrayBufferView,
        input_encoding: &JsValue,
        output_encoding: &crate::crypto::HexBase64BinaryEncoding,
    ) -> String;
    # [ wasm_bindgen ( method , setter , js_name = update ) ]
    pub fn set_update3(this: &Cipher, value: &Function);
    # [ wasm_bindgen ( method , js_name = update ) ]
    pub fn update4(
        this: &Cipher,
        data: &str,
        input_encoding: Option<&crate::crypto::Utf8AsciiBinaryEncoding>,
        output_encoding: &crate::crypto::HexBase64BinaryEncoding,
    ) -> String;
    # [ wasm_bindgen ( method , setter , js_name = update ) ]
    pub fn set_update4(this: &Cipher, value: &Function);
    # [ wasm_bindgen ( method , js_name = final ) ]
    pub fn final_(this: &Cipher) -> Buffer;
    # [ wasm_bindgen ( method , setter , js_name = final ) ]
    pub fn set_final_(this: &Cipher, value: &Function);
    # [ wasm_bindgen ( method , js_name = final ) ]
    pub fn final2(this: &Cipher, output_encoding: &str) -> String;
    # [ wasm_bindgen ( method , setter , js_name = final ) ]
    pub fn set_final2(this: &Cipher, value: &Function);
    # [ wasm_bindgen ( method , js_name = setAutoPadding ) ]
    pub fn set_auto_padding(this: &Cipher, auto_padding: Option<bool>) -> Cipher;
    # [ wasm_bindgen ( method , setter , js_name = setAutoPadding ) ]
    pub fn set_set_auto_padding(this: &Cipher, value: &Function);
    pub type CipherCCM;
    # [ wasm_bindgen ( method , js_name = setAAD ) ]
    pub fn set_aad(this: &CipherCCM, buffer: &Buffer, options: &JsValue) -> CipherCCM;
    # [ wasm_bindgen ( method , setter , js_name = setAAD ) ]
    pub fn set_set_aad(this: &CipherCCM, value: &Function);
    # [ wasm_bindgen ( method , js_name = getAuthTag ) ]
    pub fn get_auth_tag(this: &CipherCCM) -> Buffer;
    # [ wasm_bindgen ( method , setter , js_name = getAuthTag ) ]
    pub fn set_get_auth_tag(this: &CipherCCM, value: &Function);
    pub type CipherGCM;
    # [ wasm_bindgen ( method , js_name = setAAD ) ]
    pub fn set_aad(this: &CipherGCM, buffer: &Buffer, options: &JsValue) -> CipherGCM;
    # [ wasm_bindgen ( method , setter , js_name = setAAD ) ]
    pub fn set_set_aad(this: &CipherGCM, value: &Function);
    # [ wasm_bindgen ( method , js_name = getAuthTag ) ]
    pub fn get_auth_tag(this: &CipherGCM) -> Buffer;
    # [ wasm_bindgen ( method , setter , js_name = getAuthTag ) ]
    pub fn set_get_auth_tag(this: &CipherGCM, value: &Function);
    # [ wasm_bindgen ( js_name = createDecipher ) ]
    pub fn create_decipher(
        algorithm: &crate::crypto::CipherCCMTypes,
        password: &crate::crypto::BinaryLike,
        options: &crate::crypto::CipherCCMOptions,
    ) -> crate::crypto::DecipherCCM;
    # [ wasm_bindgen ( js_name = createDecipher ) ]
    pub fn create_decipher2(
        algorithm: &crate::crypto::CipherGCMTypes,
        password: &crate::crypto::BinaryLike,
        options: Option<&crate::crypto::CipherGCMOptions>,
    ) -> crate::crypto::DecipherGCM;
    # [ wasm_bindgen ( js_name = createDecipher ) ]
    pub fn create_decipher3(
        algorithm: &str,
        password: &crate::crypto::BinaryLike,
        options: Option<&crate::internal::TransformOptions>,
    ) -> crate::crypto::Decipher;
    # [ wasm_bindgen ( js_name = createDecipheriv ) ]
    pub fn create_decipheriv(
        algorithm: &crate::crypto::CipherCCMTypes,
        key: &crate::crypto::BinaryLike,
        iv: &JsValue,
        options: &crate::crypto::CipherCCMOptions,
    ) -> crate::crypto::DecipherCCM;
    # [ wasm_bindgen ( js_name = createDecipheriv ) ]
    pub fn create_decipheriv2(
        algorithm: &crate::crypto::CipherGCMTypes,
        key: &crate::crypto::BinaryLike,
        iv: &JsValue,
        options: Option<&crate::crypto::CipherGCMOptions>,
    ) -> crate::crypto::DecipherGCM;
    # [ wasm_bindgen ( js_name = createDecipheriv ) ]
    pub fn create_decipheriv3(
        algorithm: &str,
        key: &crate::crypto::BinaryLike,
        iv: &JsValue,
        options: Option<&crate::internal::TransformOptions>,
    ) -> crate::crypto::Decipher;
    pub type Decipher;
    #[wasm_bindgen(constructor)]
    pub fn new_decipher() -> Decipher;
    #[wasm_bindgen(method)]
    pub fn update(this: &Decipher, data: &crate::node_js::ArrayBufferView) -> Buffer;
    #[wasm_bindgen(method, setter)]
    pub fn set_update(this: &Decipher, value: &Function);
    # [ wasm_bindgen ( method , js_name = update ) ]
    pub fn update2(
        this: &Decipher,
        data: &str,
        input_encoding: &crate::crypto::HexBase64BinaryEncoding,
    ) -> Buffer;
    # [ wasm_bindgen ( method , setter , js_name = update ) ]
    pub fn set_update2(this: &Decipher, value: &Function);
    # [ wasm_bindgen ( method , js_name = update ) ]
    pub fn update3(
        this: &Decipher,
        data: &crate::node_js::ArrayBufferView,
        input_encoding: Option<&crate::crypto::HexBase64BinaryEncoding>,
        output_encoding: &crate::crypto::Utf8AsciiBinaryEncoding,
    ) -> String;
    # [ wasm_bindgen ( method , setter , js_name = update ) ]
    pub fn set_update3(this: &Decipher, value: &Function);
    # [ wasm_bindgen ( method , js_name = update ) ]
    pub fn update4(
        this: &Decipher,
        data: &str,
        input_encoding: Option<&crate::crypto::HexBase64BinaryEncoding>,
        output_encoding: &crate::crypto::Utf8AsciiBinaryEncoding,
    ) -> String;
    # [ wasm_bindgen ( method , setter , js_name = update ) ]
    pub fn set_update4(this: &Decipher, value: &Function);
    # [ wasm_bindgen ( method , js_name = final ) ]
    pub fn final_(this: &Decipher) -> Buffer;
    # [ wasm_bindgen ( method , setter , js_name = final ) ]
    pub fn set_final_(this: &Decipher, value: &Function);
    # [ wasm_bindgen ( method , js_name = final ) ]
    pub fn final2(this: &Decipher, output_encoding: &str) -> String;
    # [ wasm_bindgen ( method , setter , js_name = final ) ]
    pub fn set_final2(this: &Decipher, value: &Function);
    # [ wasm_bindgen ( method , js_name = setAutoPadding ) ]
    pub fn set_auto_padding(this: &Decipher, auto_padding: Option<bool>) -> Decipher;
    # [ wasm_bindgen ( method , setter , js_name = setAutoPadding ) ]
    pub fn set_set_auto_padding(this: &Decipher, value: &Function);
    pub type DecipherCCM;
    # [ wasm_bindgen ( method , js_name = setAuthTag ) ]
    pub fn set_auth_tag(
        this: &DecipherCCM,
        buffer: &crate::node_js::ArrayBufferView,
    ) -> DecipherCCM;
    # [ wasm_bindgen ( method , setter , js_name = setAuthTag ) ]
    pub fn set_set_auth_tag(this: &DecipherCCM, value: &Function);
    # [ wasm_bindgen ( method , js_name = setAAD ) ]
    pub fn set_aad(
        this: &DecipherCCM,
        buffer: &crate::node_js::ArrayBufferView,
        options: &JsValue,
    ) -> DecipherCCM;
    # [ wasm_bindgen ( method , setter , js_name = setAAD ) ]
    pub fn set_set_aad(this: &DecipherCCM, value: &Function);
    pub type DecipherGCM;
    # [ wasm_bindgen ( method , js_name = setAuthTag ) ]
    pub fn set_auth_tag(
        this: &DecipherGCM,
        buffer: &crate::node_js::ArrayBufferView,
    ) -> DecipherGCM;
    # [ wasm_bindgen ( method , setter , js_name = setAuthTag ) ]
    pub fn set_set_auth_tag(this: &DecipherGCM, value: &Function);
    # [ wasm_bindgen ( method , js_name = setAAD ) ]
    pub fn set_aad(
        this: &DecipherGCM,
        buffer: &crate::node_js::ArrayBufferView,
        options: &JsValue,
    ) -> DecipherGCM;
    # [ wasm_bindgen ( method , setter , js_name = setAAD ) ]
    pub fn set_set_aad(this: &DecipherGCM, value: &Function);
    pub type PrivateKeyInput;
    #[wasm_bindgen(method, getter)]
    pub fn key(this: &PrivateKeyInput) -> JsValue;
    #[wasm_bindgen(method, setter)]
    pub fn set_key(this: &PrivateKeyInput, value: &JsValue);
    #[wasm_bindgen(method, getter)]
    pub fn format(this: &PrivateKeyInput) -> Option<crate::crypto::KeyFormat>;
    #[wasm_bindgen(method, setter)]
    pub fn set_format(this: &PrivateKeyInput, value: Option<&crate::crypto::KeyFormat>);
    # [ wasm_bindgen ( method , getter , js_name = type ) ]
    pub fn type_(this: &PrivateKeyInput) -> JsValue;
    # [ wasm_bindgen ( method , setter , js_name = type ) ]
    pub fn set_type_(this: &PrivateKeyInput, value: &JsValue);
    #[wasm_bindgen(method, getter)]
    pub fn passphrase(this: &PrivateKeyInput) -> JsValue;
    #[wasm_bindgen(method, setter)]
    pub fn set_passphrase(this: &PrivateKeyInput, value: &JsValue);
    pub type PublicKeyInput;
    #[wasm_bindgen(method, getter)]
    pub fn key(this: &PublicKeyInput) -> JsValue;
    #[wasm_bindgen(method, setter)]
    pub fn set_key(this: &PublicKeyInput, value: &JsValue);
    #[wasm_bindgen(method, getter)]
    pub fn format(this: &PublicKeyInput) -> Option<crate::crypto::KeyFormat>;
    #[wasm_bindgen(method, setter)]
    pub fn set_format(this: &PublicKeyInput, value: Option<&crate::crypto::KeyFormat>);
    # [ wasm_bindgen ( method , getter , js_name = type ) ]
    pub fn type_(this: &PublicKeyInput) -> JsValue;
    # [ wasm_bindgen ( method , setter , js_name = type ) ]
    pub fn set_type_(this: &PublicKeyInput, value: &JsValue);
    # [ wasm_bindgen ( js_name = createPrivateKey ) ]
    pub fn create_private_key(key: &JsValue) -> crate::crypto::KeyObject;
    # [ wasm_bindgen ( js_name = createPublicKey ) ]
    pub fn create_public_key(key: &JsValue) -> crate::crypto::KeyObject;
    # [ wasm_bindgen ( js_name = createSecretKey ) ]
    pub fn create_secret_key(key: &Buffer) -> crate::crypto::KeyObject;
    # [ wasm_bindgen ( js_name = createSign ) ]
    pub fn create_sign(
        algorithm: &str,
        options: Option<&crate::internal::WritableOptions>,
    ) -> crate::crypto::Signer;
    pub type SigningOptions;
    #[wasm_bindgen(method, getter)]
    pub fn padding(this: &SigningOptions) -> Option<f64>;
    #[wasm_bindgen(method, setter)]
    pub fn set_padding(this: &SigningOptions, value: Option<f64>);
    # [ wasm_bindgen ( method , getter , js_name = saltLength ) ]
    pub fn salt_length(this: &SigningOptions) -> Option<f64>;
    # [ wasm_bindgen ( method , setter , js_name = saltLength ) ]
    pub fn set_salt_length(this: &SigningOptions, value: Option<f64>);
    pub type SignPrivateKeyInput;
    pub type KeyLike;
    pub type Signer;
    #[wasm_bindgen(constructor)]
    pub fn new_signer() -> Signer;
    #[wasm_bindgen(method)]
    pub fn update(this: &Signer, data: &crate::crypto::BinaryLike) -> crate::crypto::Signer;
    #[wasm_bindgen(method, setter)]
    pub fn set_update(this: &Signer, value: &Function);
    # [ wasm_bindgen ( method , js_name = update ) ]
    pub fn update2(
        this: &Signer,
        data: &str,
        input_encoding: &crate::crypto::Utf8AsciiLatin1Encoding,
    ) -> crate::crypto::Signer;
    # [ wasm_bindgen ( method , setter , js_name = update ) ]
    pub fn set_update2(this: &Signer, value: &Function);
    #[wasm_bindgen(method)]
    pub fn sign(this: &Signer, private_key: &JsValue) -> Buffer;
    #[wasm_bindgen(method, setter)]
    pub fn set_sign(this: &Signer, value: &Function);
    # [ wasm_bindgen ( method , js_name = sign ) ]
    pub fn sign2(
        this: &Signer,
        private_key: &JsValue,
        output_format: &crate::crypto::HexBase64Latin1Encoding,
    ) -> String;
    # [ wasm_bindgen ( method , setter , js_name = sign ) ]
    pub fn set_sign2(this: &Signer, value: &Function);
    # [ wasm_bindgen ( js_name = createVerify ) ]
    pub fn create_verify(
        algorithm: &str,
        options: Option<&crate::internal::WritableOptions>,
    ) -> crate::crypto::Verify;
    pub type Verify;
    #[wasm_bindgen(constructor)]
    pub fn new_verify() -> Verify;
    #[wasm_bindgen(method)]
    pub fn update(this: &Verify, data: &crate::crypto::BinaryLike) -> crate::crypto::Verify;
    #[wasm_bindgen(method, setter)]
    pub fn set_update(this: &Verify, value: &Function);
    # [ wasm_bindgen ( method , js_name = update ) ]
    pub fn update2(
        this: &Verify,
        data: &str,
        input_encoding: &crate::crypto::Utf8AsciiLatin1Encoding,
    ) -> crate::crypto::Verify;
    # [ wasm_bindgen ( method , setter , js_name = update ) ]
    pub fn set_update2(this: &Verify, value: &Function);
    #[wasm_bindgen(method)]
    pub fn verify(
        this: &Verify,
        object: &JsValue,
        signature: &crate::node_js::ArrayBufferView,
    ) -> bool;
    #[wasm_bindgen(method, setter)]
    pub fn set_verify(this: &Verify, value: &Function);
    # [ wasm_bindgen ( method , js_name = verify ) ]
    pub fn verify2(
        this: &Verify,
        object: &JsValue,
        signature: &str,
        signature_format: Option<&crate::crypto::HexBase64Latin1Encoding>,
    ) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = verify ) ]
    pub fn set_verify2(this: &Verify, value: &Function);
    # [ wasm_bindgen ( js_name = createDiffieHellman ) ]
    pub fn create_diffie_hellman(
        prime_length: f64,
        generator: &JsValue,
    ) -> crate::crypto::DiffieHellman;
    # [ wasm_bindgen ( js_name = createDiffieHellman ) ]
    pub fn create_diffie_hellman2(
        prime: &crate::node_js::ArrayBufferView,
    ) -> crate::crypto::DiffieHellman;
    # [ wasm_bindgen ( js_name = createDiffieHellman ) ]
    pub fn create_diffie_hellman3(
        prime: &str,
        prime_encoding: &crate::crypto::HexBase64Latin1Encoding,
    ) -> crate::crypto::DiffieHellman;
    # [ wasm_bindgen ( js_name = createDiffieHellman ) ]
    pub fn create_diffie_hellman4(
        prime: &str,
        prime_encoding: &crate::crypto::HexBase64Latin1Encoding,
        generator: &JsValue,
    ) -> crate::crypto::DiffieHellman;
    # [ wasm_bindgen ( js_name = createDiffieHellman ) ]
    pub fn create_diffie_hellman5(
        prime: &str,
        prime_encoding: &crate::crypto::HexBase64Latin1Encoding,
        generator: &str,
        generator_encoding: &crate::crypto::HexBase64Latin1Encoding,
    ) -> crate::crypto::DiffieHellman;
    pub type DiffieHellman;
    #[wasm_bindgen(constructor)]
    pub fn new_diffie_hellman() -> DiffieHellman;
    # [ wasm_bindgen ( method , js_name = generateKeys ) ]
    pub fn generate_keys(this: &DiffieHellman) -> Buffer;
    # [ wasm_bindgen ( method , setter , js_name = generateKeys ) ]
    pub fn set_generate_keys(this: &DiffieHellman, value: &Function);
    # [ wasm_bindgen ( method , js_name = generateKeys ) ]
    pub fn generate_keys2(
        this: &DiffieHellman,
        encoding: &crate::crypto::HexBase64Latin1Encoding,
    ) -> String;
    # [ wasm_bindgen ( method , setter , js_name = generateKeys ) ]
    pub fn set_generate_keys2(this: &DiffieHellman, value: &Function);
    # [ wasm_bindgen ( method , js_name = computeSecret ) ]
    pub fn compute_secret(
        this: &DiffieHellman,
        other_public_key: &crate::node_js::ArrayBufferView,
    ) -> Buffer;
    # [ wasm_bindgen ( method , setter , js_name = computeSecret ) ]
    pub fn set_compute_secret(this: &DiffieHellman, value: &Function);
    # [ wasm_bindgen ( method , js_name = computeSecret ) ]
    pub fn compute_secret2(
        this: &DiffieHellman,
        other_public_key: &str,
        input_encoding: &crate::crypto::HexBase64Latin1Encoding,
    ) -> Buffer;
    # [ wasm_bindgen ( method , setter , js_name = computeSecret ) ]
    pub fn set_compute_secret2(this: &DiffieHellman, value: &Function);
    # [ wasm_bindgen ( method , js_name = computeSecret ) ]
    pub fn compute_secret3(
        this: &DiffieHellman,
        other_public_key: &crate::node_js::ArrayBufferView,
        output_encoding: &crate::crypto::HexBase64Latin1Encoding,
    ) -> String;
    # [ wasm_bindgen ( method , setter , js_name = computeSecret ) ]
    pub fn set_compute_secret3(this: &DiffieHellman, value: &Function);
    # [ wasm_bindgen ( method , js_name = computeSecret ) ]
    pub fn compute_secret4(
        this: &DiffieHellman,
        other_public_key: &str,
        input_encoding: &crate::crypto::HexBase64Latin1Encoding,
        output_encoding: &crate::crypto::HexBase64Latin1Encoding,
    ) -> String;
    # [ wasm_bindgen ( method , setter , js_name = computeSecret ) ]
    pub fn set_compute_secret4(this: &DiffieHellman, value: &Function);
    # [ wasm_bindgen ( method , js_name = getPrime ) ]
    pub fn get_prime(this: &DiffieHellman) -> Buffer;
    # [ wasm_bindgen ( method , setter , js_name = getPrime ) ]
    pub fn set_get_prime(this: &DiffieHellman, value: &Function);
    # [ wasm_bindgen ( method , js_name = getPrime ) ]
    pub fn get_prime2(
        this: &DiffieHellman,
        encoding: &crate::crypto::HexBase64Latin1Encoding,
    ) -> String;
    # [ wasm_bindgen ( method , setter , js_name = getPrime ) ]
    pub fn set_get_prime2(this: &DiffieHellman, value: &Function);
    # [ wasm_bindgen ( method , js_name = getGenerator ) ]
    pub fn get_generator(this: &DiffieHellman) -> Buffer;
    # [ wasm_bindgen ( method , setter , js_name = getGenerator ) ]
    pub fn set_get_generator(this: &DiffieHellman, value: &Function);
    # [ wasm_bindgen ( method , js_name = getGenerator ) ]
    pub fn get_generator2(
        this: &DiffieHellman,
        encoding: &crate::crypto::HexBase64Latin1Encoding,
    ) -> String;
    # [ wasm_bindgen ( method , setter , js_name = getGenerator ) ]
    pub fn set_get_generator2(this: &DiffieHellman, value: &Function);
    # [ wasm_bindgen ( method , js_name = getPublicKey ) ]
    pub fn get_public_key(this: &DiffieHellman) -> Buffer;
    # [ wasm_bindgen ( method , setter , js_name = getPublicKey ) ]
    pub fn set_get_public_key(this: &DiffieHellman, value: &Function);
    # [ wasm_bindgen ( method , js_name = getPublicKey ) ]
    pub fn get_public_key2(
        this: &DiffieHellman,
        encoding: &crate::crypto::HexBase64Latin1Encoding,
    ) -> String;
    # [ wasm_bindgen ( method , setter , js_name = getPublicKey ) ]
    pub fn set_get_public_key2(this: &DiffieHellman, value: &Function);
    # [ wasm_bindgen ( method , js_name = getPrivateKey ) ]
    pub fn get_private_key(this: &DiffieHellman) -> Buffer;
    # [ wasm_bindgen ( method , setter , js_name = getPrivateKey ) ]
    pub fn set_get_private_key(this: &DiffieHellman, value: &Function);
    # [ wasm_bindgen ( method , js_name = getPrivateKey ) ]
    pub fn get_private_key2(
        this: &DiffieHellman,
        encoding: &crate::crypto::HexBase64Latin1Encoding,
    ) -> String;
    # [ wasm_bindgen ( method , setter , js_name = getPrivateKey ) ]
    pub fn set_get_private_key2(this: &DiffieHellman, value: &Function);
    # [ wasm_bindgen ( method , js_name = setPublicKey ) ]
    pub fn set_public_key(this: &DiffieHellman, public_key: &crate::node_js::ArrayBufferView);
    # [ wasm_bindgen ( method , setter , js_name = setPublicKey ) ]
    pub fn set_set_public_key(this: &DiffieHellman, value: &Function);
    # [ wasm_bindgen ( method , js_name = setPublicKey ) ]
    pub fn set_public_key2(this: &DiffieHellman, public_key: &str, encoding: &str);
    # [ wasm_bindgen ( method , setter , js_name = setPublicKey ) ]
    pub fn set_set_public_key2(this: &DiffieHellman, value: &Function);
    # [ wasm_bindgen ( method , js_name = setPrivateKey ) ]
    pub fn set_private_key(this: &DiffieHellman, private_key: &crate::node_js::ArrayBufferView);
    # [ wasm_bindgen ( method , setter , js_name = setPrivateKey ) ]
    pub fn set_set_private_key(this: &DiffieHellman, value: &Function);
    # [ wasm_bindgen ( method , js_name = setPrivateKey ) ]
    pub fn set_private_key2(this: &DiffieHellman, private_key: &str, encoding: &str);
    # [ wasm_bindgen ( method , setter , js_name = setPrivateKey ) ]
    pub fn set_set_private_key2(this: &DiffieHellman, value: &Function);
    # [ wasm_bindgen ( method , getter , js_name = verifyError ) ]
    pub fn verify_error(this: &DiffieHellman) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = verifyError ) ]
    pub fn set_verify_error(this: &DiffieHellman, value: f64);
    # [ wasm_bindgen ( js_name = getDiffieHellman ) ]
    pub fn get_diffie_hellman(group_name: &str) -> crate::crypto::DiffieHellman;
    #[wasm_bindgen()]
    pub fn pbkdf2(
        password: &crate::crypto::BinaryLike,
        salt: &crate::crypto::BinaryLike,
        iterations: f64,
        keylen: f64,
        digest: &str,
        callback: &JsValue,
    );
    # [ wasm_bindgen ( js_name = pbkdf2Sync ) ]
    pub fn pbkdf2_sync(
        password: &crate::crypto::BinaryLike,
        salt: &crate::crypto::BinaryLike,
        iterations: f64,
        keylen: f64,
        digest: &str,
    ) -> Buffer;
    # [ wasm_bindgen ( js_name = randomBytes ) ]
    pub fn random_bytes(size: f64) -> Buffer;
    # [ wasm_bindgen ( js_name = randomBytes ) ]
    pub fn random_bytes2(size: f64, callback: &JsValue);
    # [ wasm_bindgen ( js_name = pseudoRandomBytes ) ]
    pub fn pseudo_random_bytes(size: f64) -> Buffer;
    # [ wasm_bindgen ( js_name = pseudoRandomBytes ) ]
    pub fn pseudo_random_bytes2(size: f64, callback: &JsValue);
    # [ wasm_bindgen ( js_name = randomFillSync ) ]
    pub fn random_fill_sync(buffer: &JsValue, offset: Option<f64>, size: Option<f64>) -> JsValue;
    # [ wasm_bindgen ( js_name = randomFill ) ]
    pub fn random_fill(buffer: &JsValue, callback: &JsValue);
    # [ wasm_bindgen ( js_name = randomFill ) ]
    pub fn random_fill2(buffer: &JsValue, offset: f64, callback: &JsValue);
    # [ wasm_bindgen ( js_name = randomFill ) ]
    pub fn random_fill3(buffer: &JsValue, offset: f64, size: f64, callback: &JsValue);
    pub type ScryptOptions;
    # [ wasm_bindgen ( method , getter , js_name = N ) ]
    pub fn n(this: &ScryptOptions) -> Option<f64>;
    # [ wasm_bindgen ( method , setter , js_name = N ) ]
    pub fn set_n(this: &ScryptOptions, value: Option<f64>);
    #[wasm_bindgen(method, getter)]
    pub fn r(this: &ScryptOptions) -> Option<f64>;
    #[wasm_bindgen(method, setter)]
    pub fn set_r(this: &ScryptOptions, value: Option<f64>);
    #[wasm_bindgen(method, getter)]
    pub fn p(this: &ScryptOptions) -> Option<f64>;
    #[wasm_bindgen(method, setter)]
    pub fn set_p(this: &ScryptOptions, value: Option<f64>);
    #[wasm_bindgen(method, getter)]
    pub fn maxmem(this: &ScryptOptions) -> Option<f64>;
    #[wasm_bindgen(method, setter)]
    pub fn set_maxmem(this: &ScryptOptions, value: Option<f64>);
    #[wasm_bindgen()]
    pub fn scrypt(
        password: &crate::crypto::BinaryLike,
        salt: &crate::crypto::BinaryLike,
        keylen: f64,
        callback: &JsValue,
    );
    # [ wasm_bindgen ( js_name = scrypt ) ]
    pub fn scrypt2(
        password: &crate::crypto::BinaryLike,
        salt: &crate::crypto::BinaryLike,
        keylen: f64,
        options: &crate::crypto::ScryptOptions,
        callback: &JsValue,
    );
    # [ wasm_bindgen ( js_name = scryptSync ) ]
    pub fn scrypt_sync(
        password: &crate::crypto::BinaryLike,
        salt: &crate::crypto::BinaryLike,
        keylen: f64,
        options: Option<&crate::crypto::ScryptOptions>,
    ) -> Buffer;
    pub type RsaPublicKey;
    #[wasm_bindgen(method, getter)]
    pub fn key(this: &RsaPublicKey) -> crate::crypto::KeyLike;
    #[wasm_bindgen(method, setter)]
    pub fn set_key(this: &RsaPublicKey, value: &crate::crypto::KeyLike);
    #[wasm_bindgen(method, getter)]
    pub fn padding(this: &RsaPublicKey) -> Option<f64>;
    #[wasm_bindgen(method, setter)]
    pub fn set_padding(this: &RsaPublicKey, value: Option<f64>);
    pub type RsaPrivateKey;
    #[wasm_bindgen(method, getter)]
    pub fn key(this: &RsaPrivateKey) -> crate::crypto::KeyLike;
    #[wasm_bindgen(method, setter)]
    pub fn set_key(this: &RsaPrivateKey, value: &crate::crypto::KeyLike);
    #[wasm_bindgen(method, getter)]
    pub fn passphrase(this: &RsaPrivateKey) -> Option<String>;
    #[wasm_bindgen(method, setter)]
    pub fn set_passphrase(this: &RsaPrivateKey, value: Option<&str>);
    # [ wasm_bindgen ( method , getter , js_name = oaepHash ) ]
    pub fn oaep_hash(this: &RsaPrivateKey) -> Option<String>;
    # [ wasm_bindgen ( method , setter , js_name = oaepHash ) ]
    pub fn set_oaep_hash(this: &RsaPrivateKey, value: Option<&str>);
    # [ wasm_bindgen ( method , getter , js_name = oaepLabel ) ]
    pub fn oaep_label(this: &RsaPrivateKey) -> Option<crate::node_js::TypedArray>;
    # [ wasm_bindgen ( method , setter , js_name = oaepLabel ) ]
    pub fn set_oaep_label(this: &RsaPrivateKey, value: Option<&crate::node_js::TypedArray>);
    #[wasm_bindgen(method, getter)]
    pub fn padding(this: &RsaPrivateKey) -> Option<f64>;
    #[wasm_bindgen(method, setter)]
    pub fn set_padding(this: &RsaPrivateKey, value: Option<f64>);
    # [ wasm_bindgen ( js_name = publicEncrypt ) ]
    pub fn public_encrypt(key: &JsValue, buffer: &crate::node_js::ArrayBufferView) -> Buffer;
    # [ wasm_bindgen ( js_name = publicDecrypt ) ]
    pub fn public_decrypt(key: &JsValue, buffer: &crate::node_js::ArrayBufferView) -> Buffer;
    # [ wasm_bindgen ( js_name = privateDecrypt ) ]
    pub fn private_decrypt(
        private_key: &JsValue,
        buffer: &crate::node_js::ArrayBufferView,
    ) -> Buffer;
    # [ wasm_bindgen ( js_name = privateEncrypt ) ]
    pub fn private_encrypt(
        private_key: &JsValue,
        buffer: &crate::node_js::ArrayBufferView,
    ) -> Buffer;
    # [ wasm_bindgen ( js_name = getCiphers ) ]
    pub fn get_ciphers() -> Array;
    # [ wasm_bindgen ( js_name = getCurves ) ]
    pub fn get_curves() -> Array;
    # [ wasm_bindgen ( js_name = getHashes ) ]
    pub fn get_hashes() -> Array;
    pub type ECDH;
    #[wasm_bindgen(constructor)]
    pub fn new_ecdh() -> ECDH;
    # [ wasm_bindgen ( method , js_name = convertKey ) ]
    pub fn convert_key(
        this: &ECDH,
        key: &crate::crypto::BinaryLike,
        curve: &str,
        input_encoding: Option<&crate::crypto::HexBase64Latin1Encoding>,
        output_encoding: &JsValue,
        format: &JsValue,
    ) -> JsValue;
    # [ wasm_bindgen ( method , setter , js_name = convertKey ) ]
    pub fn set_convert_key(this: &ECDH, value: &Function);
    # [ wasm_bindgen ( method , js_name = generateKeys ) ]
    pub fn generate_keys(this: &ECDH) -> Buffer;
    # [ wasm_bindgen ( method , setter , js_name = generateKeys ) ]
    pub fn set_generate_keys(this: &ECDH, value: &Function);
    # [ wasm_bindgen ( method , js_name = generateKeys ) ]
    pub fn generate_keys2(
        this: &ECDH,
        encoding: &crate::crypto::HexBase64Latin1Encoding,
        format: Option<&crate::crypto::ECDHKeyFormat>,
    ) -> String;
    # [ wasm_bindgen ( method , setter , js_name = generateKeys ) ]
    pub fn set_generate_keys2(this: &ECDH, value: &Function);
    # [ wasm_bindgen ( method , js_name = computeSecret ) ]
    pub fn compute_secret(
        this: &ECDH,
        other_public_key: &crate::node_js::ArrayBufferView,
    ) -> Buffer;
    # [ wasm_bindgen ( method , setter , js_name = computeSecret ) ]
    pub fn set_compute_secret(this: &ECDH, value: &Function);
    # [ wasm_bindgen ( method , js_name = computeSecret ) ]
    pub fn compute_secret2(
        this: &ECDH,
        other_public_key: &str,
        input_encoding: &crate::crypto::HexBase64Latin1Encoding,
    ) -> Buffer;
    # [ wasm_bindgen ( method , setter , js_name = computeSecret ) ]
    pub fn set_compute_secret2(this: &ECDH, value: &Function);
    # [ wasm_bindgen ( method , js_name = computeSecret ) ]
    pub fn compute_secret3(
        this: &ECDH,
        other_public_key: &crate::node_js::ArrayBufferView,
        output_encoding: &crate::crypto::HexBase64Latin1Encoding,
    ) -> String;
    # [ wasm_bindgen ( method , setter , js_name = computeSecret ) ]
    pub fn set_compute_secret3(this: &ECDH, value: &Function);
    # [ wasm_bindgen ( method , js_name = computeSecret ) ]
    pub fn compute_secret4(
        this: &ECDH,
        other_public_key: &str,
        input_encoding: &crate::crypto::HexBase64Latin1Encoding,
        output_encoding: &crate::crypto::HexBase64Latin1Encoding,
    ) -> String;
    # [ wasm_bindgen ( method , setter , js_name = computeSecret ) ]
    pub fn set_compute_secret4(this: &ECDH, value: &Function);
    # [ wasm_bindgen ( method , js_name = getPrivateKey ) ]
    pub fn get_private_key(this: &ECDH) -> Buffer;
    # [ wasm_bindgen ( method , setter , js_name = getPrivateKey ) ]
    pub fn set_get_private_key(this: &ECDH, value: &Function);
    # [ wasm_bindgen ( method , js_name = getPrivateKey ) ]
    pub fn get_private_key2(
        this: &ECDH,
        encoding: &crate::crypto::HexBase64Latin1Encoding,
    ) -> String;
    # [ wasm_bindgen ( method , setter , js_name = getPrivateKey ) ]
    pub fn set_get_private_key2(this: &ECDH, value: &Function);
    # [ wasm_bindgen ( method , js_name = getPublicKey ) ]
    pub fn get_public_key(this: &ECDH) -> Buffer;
    # [ wasm_bindgen ( method , setter , js_name = getPublicKey ) ]
    pub fn set_get_public_key(this: &ECDH, value: &Function);
    # [ wasm_bindgen ( method , js_name = getPublicKey ) ]
    pub fn get_public_key2(
        this: &ECDH,
        encoding: &crate::crypto::HexBase64Latin1Encoding,
        format: Option<&crate::crypto::ECDHKeyFormat>,
    ) -> String;
    # [ wasm_bindgen ( method , setter , js_name = getPublicKey ) ]
    pub fn set_get_public_key2(this: &ECDH, value: &Function);
    # [ wasm_bindgen ( method , js_name = setPrivateKey ) ]
    pub fn set_private_key(this: &ECDH, private_key: &crate::node_js::ArrayBufferView);
    # [ wasm_bindgen ( method , setter , js_name = setPrivateKey ) ]
    pub fn set_set_private_key(this: &ECDH, value: &Function);
    # [ wasm_bindgen ( method , js_name = setPrivateKey ) ]
    pub fn set_private_key2(
        this: &ECDH,
        private_key: &str,
        encoding: &crate::crypto::HexBase64Latin1Encoding,
    );
    # [ wasm_bindgen ( method , setter , js_name = setPrivateKey ) ]
    pub fn set_set_private_key2(this: &ECDH, value: &Function);
    # [ wasm_bindgen ( js_name = createECDH ) ]
    pub fn create_ecdh(curve_name: &str) -> crate::crypto::ECDH;
    # [ wasm_bindgen ( js_name = timingSafeEqual ) ]
    pub fn timing_safe_equal(
        a: &crate::node_js::ArrayBufferView,
        b: &crate::node_js::ArrayBufferView,
    ) -> bool;
    pub static DEFAULT_ENCODING: String;
    pub type KeyType;
    pub type KeyFormat;
    pub type BasePrivateKeyEncodingOptions;
    #[wasm_bindgen(method, getter)]
    pub fn format(this: &BasePrivateKeyEncodingOptions) -> JsValue;
    #[wasm_bindgen(method, setter)]
    pub fn set_format(this: &BasePrivateKeyEncodingOptions, value: &JsValue);
    #[wasm_bindgen(method, getter)]
    pub fn cipher(this: &BasePrivateKeyEncodingOptions) -> Option<String>;
    #[wasm_bindgen(method, setter)]
    pub fn set_cipher(this: &BasePrivateKeyEncodingOptions, value: Option<&str>);
    #[wasm_bindgen(method, getter)]
    pub fn passphrase(this: &BasePrivateKeyEncodingOptions) -> Option<String>;
    #[wasm_bindgen(method, setter)]
    pub fn set_passphrase(this: &BasePrivateKeyEncodingOptions, value: Option<&str>);
    pub type KeyPairKeyObjectResult;
    # [ wasm_bindgen ( method , getter , js_name = publicKey ) ]
    pub fn public_key(this: &KeyPairKeyObjectResult) -> crate::crypto::KeyObject;
    # [ wasm_bindgen ( method , setter , js_name = publicKey ) ]
    pub fn set_public_key(this: &KeyPairKeyObjectResult, value: &crate::crypto::KeyObject);
    # [ wasm_bindgen ( method , getter , js_name = privateKey ) ]
    pub fn private_key(this: &KeyPairKeyObjectResult) -> crate::crypto::KeyObject;
    # [ wasm_bindgen ( method , setter , js_name = privateKey ) ]
    pub fn set_private_key(this: &KeyPairKeyObjectResult, value: &crate::crypto::KeyObject);
    pub type ECKeyPairKeyObjectOptions;
    #[doc = "Name of the curve to use."]
    # [ wasm_bindgen ( method , getter , js_name = namedCurve ) ]
    pub fn named_curve(this: &ECKeyPairKeyObjectOptions) -> String;
    # [ wasm_bindgen ( method , setter , js_name = namedCurve ) ]
    pub fn set_named_curve(this: &ECKeyPairKeyObjectOptions, value: &str);
    pub type RSAKeyPairKeyObjectOptions;
    #[doc = "Key size in bits"]
    # [ wasm_bindgen ( method , getter , js_name = modulusLength ) ]
    pub fn modulus_length(this: &RSAKeyPairKeyObjectOptions) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = modulusLength ) ]
    pub fn set_modulus_length(this: &RSAKeyPairKeyObjectOptions, value: f64);
    # [ wasm_bindgen ( method , getter , js_name = publicExponent ) ]
    pub fn public_exponent(this: &RSAKeyPairKeyObjectOptions) -> Option<f64>;
    # [ wasm_bindgen ( method , setter , js_name = publicExponent ) ]
    pub fn set_public_exponent(this: &RSAKeyPairKeyObjectOptions, value: Option<f64>);
    pub type DSAKeyPairKeyObjectOptions;
    #[doc = "Key size in bits"]
    # [ wasm_bindgen ( method , getter , js_name = modulusLength ) ]
    pub fn modulus_length(this: &DSAKeyPairKeyObjectOptions) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = modulusLength ) ]
    pub fn set_modulus_length(this: &DSAKeyPairKeyObjectOptions, value: f64);
    #[doc = "Size of q in bits"]
    # [ wasm_bindgen ( method , getter , js_name = divisorLength ) ]
    pub fn divisor_length(this: &DSAKeyPairKeyObjectOptions) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = divisorLength ) ]
    pub fn set_divisor_length(this: &DSAKeyPairKeyObjectOptions, value: f64);
    pub type RSAKeyPairOptions;
    #[doc = "Key size in bits"]
    # [ wasm_bindgen ( method , getter , js_name = modulusLength ) ]
    pub fn modulus_length(this: &RSAKeyPairOptions) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = modulusLength ) ]
    pub fn set_modulus_length(this: &RSAKeyPairOptions, value: f64);
    # [ wasm_bindgen ( method , getter , js_name = publicExponent ) ]
    pub fn public_exponent(this: &RSAKeyPairOptions) -> Option<f64>;
    # [ wasm_bindgen ( method , setter , js_name = publicExponent ) ]
    pub fn set_public_exponent(this: &RSAKeyPairOptions, value: Option<f64>);
    # [ wasm_bindgen ( method , getter , js_name = publicKeyEncoding ) ]
    pub fn public_key_encoding(this: &RSAKeyPairOptions) -> JsValue;
    # [ wasm_bindgen ( method , setter , js_name = publicKeyEncoding ) ]
    pub fn set_public_key_encoding(this: &RSAKeyPairOptions, value: &JsValue);
    # [ wasm_bindgen ( method , getter , js_name = privateKeyEncoding ) ]
    pub fn private_key_encoding(this: &RSAKeyPairOptions) -> JsValue;
    # [ wasm_bindgen ( method , setter , js_name = privateKeyEncoding ) ]
    pub fn set_private_key_encoding(this: &RSAKeyPairOptions, value: &JsValue);
    pub type DSAKeyPairOptions;
    #[doc = "Key size in bits"]
    # [ wasm_bindgen ( method , getter , js_name = modulusLength ) ]
    pub fn modulus_length(this: &DSAKeyPairOptions) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = modulusLength ) ]
    pub fn set_modulus_length(this: &DSAKeyPairOptions, value: f64);
    #[doc = "Size of q in bits"]
    # [ wasm_bindgen ( method , getter , js_name = divisorLength ) ]
    pub fn divisor_length(this: &DSAKeyPairOptions) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = divisorLength ) ]
    pub fn set_divisor_length(this: &DSAKeyPairOptions, value: f64);
    # [ wasm_bindgen ( method , getter , js_name = publicKeyEncoding ) ]
    pub fn public_key_encoding(this: &DSAKeyPairOptions) -> JsValue;
    # [ wasm_bindgen ( method , setter , js_name = publicKeyEncoding ) ]
    pub fn set_public_key_encoding(this: &DSAKeyPairOptions, value: &JsValue);
    # [ wasm_bindgen ( method , getter , js_name = privateKeyEncoding ) ]
    pub fn private_key_encoding(this: &DSAKeyPairOptions) -> JsValue;
    # [ wasm_bindgen ( method , setter , js_name = privateKeyEncoding ) ]
    pub fn set_private_key_encoding(this: &DSAKeyPairOptions, value: &JsValue);
    pub type ECKeyPairOptions;
    #[doc = "Name of the curve to use."]
    # [ wasm_bindgen ( method , getter , js_name = namedCurve ) ]
    pub fn named_curve(this: &ECKeyPairOptions) -> String;
    # [ wasm_bindgen ( method , setter , js_name = namedCurve ) ]
    pub fn set_named_curve(this: &ECKeyPairOptions, value: &str);
    # [ wasm_bindgen ( method , getter , js_name = publicKeyEncoding ) ]
    pub fn public_key_encoding(this: &ECKeyPairOptions) -> JsValue;
    # [ wasm_bindgen ( method , setter , js_name = publicKeyEncoding ) ]
    pub fn set_public_key_encoding(this: &ECKeyPairOptions, value: &JsValue);
    # [ wasm_bindgen ( method , getter , js_name = privateKeyEncoding ) ]
    pub fn private_key_encoding(this: &ECKeyPairOptions) -> JsValue;
    # [ wasm_bindgen ( method , setter , js_name = privateKeyEncoding ) ]
    pub fn set_private_key_encoding(this: &ECKeyPairOptions, value: &JsValue);
    pub type KeyPairSyncResult;
    # [ wasm_bindgen ( method , getter , js_name = publicKey ) ]
    pub fn public_key(this: &KeyPairSyncResult) -> JsValue;
    # [ wasm_bindgen ( method , setter , js_name = publicKey ) ]
    pub fn set_public_key(this: &KeyPairSyncResult, value: &JsValue);
    # [ wasm_bindgen ( method , getter , js_name = privateKey ) ]
    pub fn private_key(this: &KeyPairSyncResult) -> JsValue;
    # [ wasm_bindgen ( method , setter , js_name = privateKey ) ]
    pub fn set_private_key(this: &KeyPairSyncResult, value: &JsValue);
    # [ wasm_bindgen ( js_name = generateKeyPairSync ) ]
    pub fn generate_key_pair_sync(
        type_: &JsValue,
        options: &crate::crypto::RSAKeyPairOptions,
    ) -> crate::crypto::KeyPairSyncResult;
    # [ wasm_bindgen ( js_name = generateKeyPairSync ) ]
    pub fn generate_key_pair_sync2(
        type_: &JsValue,
        options: &crate::crypto::RSAKeyPairOptions,
    ) -> crate::crypto::KeyPairSyncResult;
    # [ wasm_bindgen ( js_name = generateKeyPairSync ) ]
    pub fn generate_key_pair_sync3(
        type_: &JsValue,
        options: &crate::crypto::RSAKeyPairOptions,
    ) -> crate::crypto::KeyPairSyncResult;
    # [ wasm_bindgen ( js_name = generateKeyPairSync ) ]
    pub fn generate_key_pair_sync4(
        type_: &JsValue,
        options: &crate::crypto::RSAKeyPairOptions,
    ) -> crate::crypto::KeyPairSyncResult;
    # [ wasm_bindgen ( js_name = generateKeyPairSync ) ]
    pub fn generate_key_pair_sync5(
        type_: &JsValue,
        options: &crate::crypto::RSAKeyPairKeyObjectOptions,
    ) -> crate::crypto::KeyPairKeyObjectResult;
    # [ wasm_bindgen ( js_name = generateKeyPairSync ) ]
    pub fn generate_key_pair_sync6(
        type_: &JsValue,
        options: &crate::crypto::DSAKeyPairOptions,
    ) -> crate::crypto::KeyPairSyncResult;
    # [ wasm_bindgen ( js_name = generateKeyPairSync ) ]
    pub fn generate_key_pair_sync7(
        type_: &JsValue,
        options: &crate::crypto::DSAKeyPairOptions,
    ) -> crate::crypto::KeyPairSyncResult;
    # [ wasm_bindgen ( js_name = generateKeyPairSync ) ]
    pub fn generate_key_pair_sync8(
        type_: &JsValue,
        options: &crate::crypto::DSAKeyPairOptions,
    ) -> crate::crypto::KeyPairSyncResult;
    # [ wasm_bindgen ( js_name = generateKeyPairSync ) ]
    pub fn generate_key_pair_sync9(
        type_: &JsValue,
        options: &crate::crypto::DSAKeyPairOptions,
    ) -> crate::crypto::KeyPairSyncResult;
    # [ wasm_bindgen ( js_name = generateKeyPairSync ) ]
    pub fn generate_key_pair_sync10(
        type_: &JsValue,
        options: &crate::crypto::DSAKeyPairKeyObjectOptions,
    ) -> crate::crypto::KeyPairKeyObjectResult;
    # [ wasm_bindgen ( js_name = generateKeyPairSync ) ]
    pub fn generate_key_pair_sync11(
        type_: &JsValue,
        options: &crate::crypto::ECKeyPairOptions,
    ) -> crate::crypto::KeyPairSyncResult;
    # [ wasm_bindgen ( js_name = generateKeyPairSync ) ]
    pub fn generate_key_pair_sync12(
        type_: &JsValue,
        options: &crate::crypto::ECKeyPairOptions,
    ) -> crate::crypto::KeyPairSyncResult;
    # [ wasm_bindgen ( js_name = generateKeyPairSync ) ]
    pub fn generate_key_pair_sync13(
        type_: &JsValue,
        options: &crate::crypto::ECKeyPairOptions,
    ) -> crate::crypto::KeyPairSyncResult;
    # [ wasm_bindgen ( js_name = generateKeyPairSync ) ]
    pub fn generate_key_pair_sync14(
        type_: &JsValue,
        options: &crate::crypto::ECKeyPairOptions,
    ) -> crate::crypto::KeyPairSyncResult;
    # [ wasm_bindgen ( js_name = generateKeyPairSync ) ]
    pub fn generate_key_pair_sync15(
        type_: &JsValue,
        options: &crate::crypto::ECKeyPairKeyObjectOptions,
    ) -> crate::crypto::KeyPairKeyObjectResult;
    # [ wasm_bindgen ( js_name = generateKeyPair ) ]
    pub fn generate_key_pair(
        type_: &JsValue,
        options: &crate::crypto::RSAKeyPairOptions,
        callback: &JsValue,
    );
    # [ wasm_bindgen ( js_name = generateKeyPair ) ]
    pub fn generate_key_pair2(
        type_: &JsValue,
        options: &crate::crypto::RSAKeyPairOptions,
        callback: &JsValue,
    );
    # [ wasm_bindgen ( js_name = generateKeyPair ) ]
    pub fn generate_key_pair3(
        type_: &JsValue,
        options: &crate::crypto::RSAKeyPairOptions,
        callback: &JsValue,
    );
    # [ wasm_bindgen ( js_name = generateKeyPair ) ]
    pub fn generate_key_pair4(
        type_: &JsValue,
        options: &crate::crypto::RSAKeyPairOptions,
        callback: &JsValue,
    );
    # [ wasm_bindgen ( js_name = generateKeyPair ) ]
    pub fn generate_key_pair5(
        type_: &JsValue,
        options: &crate::crypto::RSAKeyPairKeyObjectOptions,
        callback: &JsValue,
    );
    # [ wasm_bindgen ( js_name = generateKeyPair ) ]
    pub fn generate_key_pair6(
        type_: &JsValue,
        options: &crate::crypto::DSAKeyPairOptions,
        callback: &JsValue,
    );
    # [ wasm_bindgen ( js_name = generateKeyPair ) ]
    pub fn generate_key_pair7(
        type_: &JsValue,
        options: &crate::crypto::DSAKeyPairOptions,
        callback: &JsValue,
    );
    # [ wasm_bindgen ( js_name = generateKeyPair ) ]
    pub fn generate_key_pair8(
        type_: &JsValue,
        options: &crate::crypto::DSAKeyPairOptions,
        callback: &JsValue,
    );
    # [ wasm_bindgen ( js_name = generateKeyPair ) ]
    pub fn generate_key_pair9(
        type_: &JsValue,
        options: &crate::crypto::DSAKeyPairOptions,
        callback: &JsValue,
    );
    # [ wasm_bindgen ( js_name = generateKeyPair ) ]
    pub fn generate_key_pair10(
        type_: &JsValue,
        options: &crate::crypto::DSAKeyPairKeyObjectOptions,
        callback: &JsValue,
    );
    # [ wasm_bindgen ( js_name = generateKeyPair ) ]
    pub fn generate_key_pair11(
        type_: &JsValue,
        options: &crate::crypto::ECKeyPairOptions,
        callback: &JsValue,
    );
    # [ wasm_bindgen ( js_name = generateKeyPair ) ]
    pub fn generate_key_pair12(
        type_: &JsValue,
        options: &crate::crypto::ECKeyPairOptions,
        callback: &JsValue,
    );
    # [ wasm_bindgen ( js_name = generateKeyPair ) ]
    pub fn generate_key_pair13(
        type_: &JsValue,
        options: &crate::crypto::ECKeyPairOptions,
        callback: &JsValue,
    );
    # [ wasm_bindgen ( js_name = generateKeyPair ) ]
    pub fn generate_key_pair14(
        type_: &JsValue,
        options: &crate::crypto::ECKeyPairOptions,
        callback: &JsValue,
    );
    # [ wasm_bindgen ( js_name = generateKeyPair ) ]
    pub fn generate_key_pair15(
        type_: &JsValue,
        options: &crate::crypto::ECKeyPairKeyObjectOptions,
        callback: &JsValue,
    );
    #[doc = "Calculates and returns the signature for `data` using the given private key and"]
    #[doc = "algorithm. If `algorithm` is `null` or `undefined`, then the algorithm is"]
    #[doc = "dependent upon the key type (especially Ed25519 and Ed448)."]
    #[doc = ""]
    #[doc = "If `key` is not a [`KeyObject`][], this function behaves as if `key` had been"]
    #[doc = "passed to [`crypto.createPrivateKey()`][]."]
    #[wasm_bindgen()]
    pub fn sign(
        algorithm: &JsValue,
        data: &crate::node_js::ArrayBufferView,
        key: &JsValue,
    ) -> Buffer;
    pub type VerifyKeyWithOptions;
    #[doc = "Calculates and returns the signature for `data` using the given private key and"]
    #[doc = "algorithm. If `algorithm` is `null` or `undefined`, then the algorithm is"]
    #[doc = "dependent upon the key type (especially Ed25519 and Ed448)."]
    #[doc = ""]
    #[doc = "If `key` is not a [`KeyObject`][], this function behaves as if `key` had been"]
    #[doc = "passed to [`crypto.createPublicKey()`][]."]
    #[wasm_bindgen()]
    pub fn verify(
        algorithm: &JsValue,
        data: &crate::node_js::ArrayBufferView,
        key: &JsValue,
        signature: &crate::node_js::ArrayBufferView,
    ) -> Buffer;
}
