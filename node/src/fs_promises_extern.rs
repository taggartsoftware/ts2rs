// generated by ts2rs 0.1.4
// https://ts2rs.ctaggart.com/

#[wasm_bindgen(module = "promises")]
extern "C" {
    pub type FileHandle;
    #[doc = "Gets the file descriptor for this file handle."]
    #[wasm_bindgen(method, getter)]
    pub fn fd(this: &FileHandle) -> f64;
    #[doc = "Asynchronously append data to a file, creating the file if it does not exist. The underlying file will _not_ be closed automatically."]
    #[doc = "The `FileHandle` must have been opened for appending."]
    # [ wasm_bindgen ( method , js_name = appendFile ) ]
    pub fn append_file(this: &FileHandle, data: &JsValue, options: &JsValue) -> Promise;
    # [ wasm_bindgen ( method , setter , js_name = appendFile ) ]
    pub fn set_append_file(this: &FileHandle, value: &Function);
    #[doc = "Asynchronous fchown(2) - Change ownership of a file."]
    #[wasm_bindgen(method)]
    pub fn chown(this: &FileHandle, uid: f64, gid: f64) -> Promise;
    #[wasm_bindgen(method, setter)]
    pub fn set_chown(this: &FileHandle, value: &Function);
    #[doc = "Asynchronous fchmod(2) - Change permissions of a file."]
    #[wasm_bindgen(method)]
    pub fn chmod(this: &FileHandle, mode: &JsValue) -> Promise;
    #[wasm_bindgen(method, setter)]
    pub fn set_chmod(this: &FileHandle, value: &Function);
    #[doc = "Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device."]
    #[wasm_bindgen(method)]
    pub fn datasync(this: &FileHandle) -> Promise;
    #[wasm_bindgen(method, setter)]
    pub fn set_datasync(this: &FileHandle, value: &Function);
    #[doc = "Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device."]
    #[wasm_bindgen(method)]
    pub fn sync(this: &FileHandle) -> Promise;
    #[wasm_bindgen(method, setter)]
    pub fn set_sync(this: &FileHandle, value: &Function);
    #[doc = "Asynchronously reads data from the file."]
    #[doc = "The `FileHandle` must have been opened for reading."]
    #[wasm_bindgen(method)]
    pub fn read(
        this: &FileHandle,
        buffer: &JsValue,
        offset: &JsValue,
        length: &JsValue,
        position: &JsValue,
    ) -> Promise;
    #[wasm_bindgen(method, setter)]
    pub fn set_read(this: &FileHandle, value: &Function);
    #[doc = "Asynchronously reads the entire contents of a file. The underlying file will _not_ be closed automatically."]
    #[doc = "The `FileHandle` must have been opened for reading."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronously reads the entire contents of a file. The underlying file will _not_ be closed automatically."]
    #[doc = "The `FileHandle` must have been opened for reading."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronously reads the entire contents of a file. The underlying file will _not_ be closed automatically."]
    #[doc = "The `FileHandle` must have been opened for reading."]
    # [ wasm_bindgen ( method , js_name = readFile ) ]
    pub fn read_file(this: &FileHandle, options: &JsValue) -> Promise;
    # [ wasm_bindgen ( method , setter , js_name = readFile ) ]
    pub fn set_read_file(this: &FileHandle, value: &Function);
    #[doc = "Asynchronously reads the entire contents of a file. The underlying file will _not_ be closed automatically."]
    #[doc = "The `FileHandle` must have been opened for reading."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronously reads the entire contents of a file. The underlying file will _not_ be closed automatically."]
    #[doc = "The `FileHandle` must have been opened for reading."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronously reads the entire contents of a file. The underlying file will _not_ be closed automatically."]
    #[doc = "The `FileHandle` must have been opened for reading."]
    # [ wasm_bindgen ( method , js_name = readFile ) ]
    pub fn read_file2(this: &FileHandle, options: &JsValue) -> Promise;
    # [ wasm_bindgen ( method , setter , js_name = readFile ) ]
    pub fn set_read_file2(this: &FileHandle, value: &Function);
    #[doc = "Asynchronously reads the entire contents of a file. The underlying file will _not_ be closed automatically."]
    #[doc = "The `FileHandle` must have been opened for reading."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronously reads the entire contents of a file. The underlying file will _not_ be closed automatically."]
    #[doc = "The `FileHandle` must have been opened for reading."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronously reads the entire contents of a file. The underlying file will _not_ be closed automatically."]
    #[doc = "The `FileHandle` must have been opened for reading."]
    # [ wasm_bindgen ( method , js_name = readFile ) ]
    pub fn read_file3(this: &FileHandle, options: &JsValue) -> Promise;
    # [ wasm_bindgen ( method , setter , js_name = readFile ) ]
    pub fn set_read_file3(this: &FileHandle, value: &Function);
    #[doc = "Asynchronous fstat(2) - Get file status."]
    #[wasm_bindgen(method)]
    pub fn stat(this: &FileHandle) -> Promise;
    #[wasm_bindgen(method, setter)]
    pub fn set_stat(this: &FileHandle, value: &Function);
    #[doc = "Asynchronous ftruncate(2) - Truncate a file to a specified length."]
    #[wasm_bindgen(method)]
    pub fn truncate(this: &FileHandle, len: Option<f64>) -> Promise;
    #[wasm_bindgen(method, setter)]
    pub fn set_truncate(this: &FileHandle, value: &Function);
    #[doc = "Asynchronously change file timestamps of the file."]
    #[wasm_bindgen(method)]
    pub fn utimes(this: &FileHandle, atime: &JsValue, mtime: &JsValue) -> Promise;
    #[wasm_bindgen(method, setter)]
    pub fn set_utimes(this: &FileHandle, value: &Function);
    #[doc = "Asynchronously writes `buffer` to the file."]
    #[doc = "The `FileHandle` must have been opened for writing."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronously writes `string` to the file."]
    #[doc = "The `FileHandle` must have been opened for writing."]
    #[doc = "It is unsafe to call `write()` multiple times on the same file without waiting for the `Promise`"]
    #[doc = "to be resolved (or rejected). For this scenario, `fs.createWriteStream` is strongly recommended."]
    #[wasm_bindgen(method)]
    pub fn write(
        this: &FileHandle,
        buffer: &JsValue,
        offset: &JsValue,
        length: &JsValue,
        position: &JsValue,
    ) -> Promise;
    #[wasm_bindgen(method, setter)]
    pub fn set_write(this: &FileHandle, value: &Function);
    #[doc = "Asynchronously writes `buffer` to the file."]
    #[doc = "The `FileHandle` must have been opened for writing."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronously writes `string` to the file."]
    #[doc = "The `FileHandle` must have been opened for writing."]
    #[doc = "It is unsafe to call `write()` multiple times on the same file without waiting for the `Promise`"]
    #[doc = "to be resolved (or rejected). For this scenario, `fs.createWriteStream` is strongly recommended."]
    # [ wasm_bindgen ( method , js_name = write ) ]
    pub fn write2(
        this: &FileHandle,
        data: &JsValue,
        position: &JsValue,
        encoding: &JsValue,
    ) -> Promise;
    # [ wasm_bindgen ( method , setter , js_name = write ) ]
    pub fn set_write2(this: &FileHandle, value: &Function);
    #[doc = "Asynchronously writes data to a file, replacing the file if it already exists. The underlying file will _not_ be closed automatically."]
    #[doc = "The `FileHandle` must have been opened for writing."]
    #[doc = "It is unsafe to call `writeFile()` multiple times on the same file without waiting for the `Promise` to be resolved (or rejected)."]
    # [ wasm_bindgen ( method , js_name = writeFile ) ]
    pub fn write_file(this: &FileHandle, data: &JsValue, options: &JsValue) -> Promise;
    # [ wasm_bindgen ( method , setter , js_name = writeFile ) ]
    pub fn set_write_file(this: &FileHandle, value: &Function);
    #[doc = "See `fs.writev` promisified version."]
    #[wasm_bindgen(method)]
    pub fn writev(this: &FileHandle, buffers: &Array, position: Option<f64>) -> Promise;
    #[wasm_bindgen(method, setter)]
    pub fn set_writev(this: &FileHandle, value: &Function);
    #[doc = "Asynchronous close(2) - close a `FileHandle`."]
    #[wasm_bindgen(method)]
    pub fn close(this: &FileHandle) -> Promise;
    #[wasm_bindgen(method, setter)]
    pub fn set_close(this: &FileHandle, value: &Function);
    #[doc = "Asynchronously tests a user's permissions for the file specified by path."]
    #[wasm_bindgen()]
    pub fn access(path: &PathLike, mode: Option<f64>) -> Promise;
    #[doc = "Asynchronously copies `src` to `dest`. By default, `dest` is overwritten if it already exists."]
    #[doc = "Node.js makes no guarantees about the atomicity of the copy operation."]
    #[doc = "If an error occurs after the destination file has been opened for writing, Node.js will attempt"]
    #[doc = "to remove the destination."]
    # [ wasm_bindgen ( js_name = copyFile ) ]
    pub fn copy_file(src: &PathLike, dest: &PathLike, flags: Option<f64>) -> Promise;
    #[doc = "Asynchronous open(2) - open and possibly create a file."]
    #[wasm_bindgen()]
    pub fn open(path: &PathLike, flags: &JsValue, mode: &JsValue) -> Promise;
    #[doc = "Asynchronously reads data from the file referenced by the supplied `FileHandle`."]
    #[wasm_bindgen()]
    pub fn read(
        handle: &FileHandle,
        buffer: &JsValue,
        offset: &JsValue,
        length: &JsValue,
        position: &JsValue,
    ) -> Promise;
    #[doc = "Asynchronously writes `buffer` to the file referenced by the supplied `FileHandle`."]
    #[doc = "It is unsafe to call `fsPromises.write()` multiple times on the same file without waiting for the `Promise`"]
    #[doc = "to be resolved (or rejected). For this scenario, `fs.createWriteStream` is strongly recommended."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronously writes `string` to the file referenced by the supplied `FileHandle`."]
    #[doc = "It is unsafe to call `fsPromises.write()` multiple times on the same file without waiting for the `Promise`"]
    #[doc = "to be resolved (or rejected). For this scenario, `fs.createWriteStream` is strongly recommended."]
    #[wasm_bindgen()]
    pub fn write(
        handle: &FileHandle,
        buffer: &JsValue,
        offset: &JsValue,
        length: &JsValue,
        position: &JsValue,
    ) -> Promise;
    #[doc = "Asynchronously writes `buffer` to the file referenced by the supplied `FileHandle`."]
    #[doc = "It is unsafe to call `fsPromises.write()` multiple times on the same file without waiting for the `Promise`"]
    #[doc = "to be resolved (or rejected). For this scenario, `fs.createWriteStream` is strongly recommended."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronously writes `string` to the file referenced by the supplied `FileHandle`."]
    #[doc = "It is unsafe to call `fsPromises.write()` multiple times on the same file without waiting for the `Promise`"]
    #[doc = "to be resolved (or rejected). For this scenario, `fs.createWriteStream` is strongly recommended."]
    # [ wasm_bindgen ( js_name = write ) ]
    pub fn write2(
        handle: &FileHandle,
        string: &JsValue,
        position: &JsValue,
        encoding: &JsValue,
    ) -> Promise;
    #[doc = "Asynchronous rename(2) - Change the name or location of a file or directory."]
    #[wasm_bindgen()]
    pub fn rename(old_path: &PathLike, new_path: &PathLike) -> Promise;
    #[doc = "Asynchronous truncate(2) - Truncate a file to a specified length."]
    #[wasm_bindgen()]
    pub fn truncate(path: &PathLike, len: Option<f64>) -> Promise;
    #[doc = "Asynchronous ftruncate(2) - Truncate a file to a specified length."]
    #[wasm_bindgen()]
    pub fn ftruncate(handle: &FileHandle, len: Option<f64>) -> Promise;
    #[doc = "Asynchronous rmdir(2) - delete a directory."]
    #[wasm_bindgen()]
    pub fn rmdir(path: &PathLike, options: Option<&RmDirAsyncOptions>) -> Promise;
    #[doc = "Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device."]
    #[wasm_bindgen()]
    pub fn fdatasync(handle: &FileHandle) -> Promise;
    #[doc = "Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device."]
    #[wasm_bindgen()]
    pub fn fsync(handle: &FileHandle) -> Promise;
    #[doc = "Asynchronous mkdir(2) - create a directory."]
    #[wasm_bindgen()]
    pub fn mkdir(path: &PathLike, options: &JsValue) -> Promise;
    #[doc = "Asynchronous readdir(3) - read a directory."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronous readdir(3) - read a directory."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronous readdir(3) - read a directory."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronous readdir(3) - read a directory."]
    #[wasm_bindgen()]
    pub fn readdir(path: &PathLike, options: &JsValue) -> Promise;
    #[doc = "Asynchronous readdir(3) - read a directory."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronous readdir(3) - read a directory."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronous readdir(3) - read a directory."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronous readdir(3) - read a directory."]
    # [ wasm_bindgen ( js_name = readdir ) ]
    pub fn readdir2(path: &PathLike, options: &JsValue) -> Promise;
    #[doc = "Asynchronous readdir(3) - read a directory."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronous readdir(3) - read a directory."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronous readdir(3) - read a directory."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronous readdir(3) - read a directory."]
    # [ wasm_bindgen ( js_name = readdir ) ]
    pub fn readdir3(path: &PathLike, options: &JsValue) -> Promise;
    #[doc = "Asynchronous readdir(3) - read a directory."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronous readdir(3) - read a directory."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronous readdir(3) - read a directory."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronous readdir(3) - read a directory."]
    # [ wasm_bindgen ( js_name = readdir ) ]
    pub fn readdir4(path: &PathLike, options: &JsValue) -> Promise;
    #[doc = "Asynchronous readlink(2) - read value of a symbolic link."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronous readlink(2) - read value of a symbolic link."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronous readlink(2) - read value of a symbolic link."]
    #[wasm_bindgen()]
    pub fn readlink(path: &PathLike, options: &JsValue) -> Promise;
    #[doc = "Asynchronous readlink(2) - read value of a symbolic link."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronous readlink(2) - read value of a symbolic link."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronous readlink(2) - read value of a symbolic link."]
    # [ wasm_bindgen ( js_name = readlink ) ]
    pub fn readlink2(path: &PathLike, options: &JsValue) -> Promise;
    #[doc = "Asynchronous readlink(2) - read value of a symbolic link."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronous readlink(2) - read value of a symbolic link."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronous readlink(2) - read value of a symbolic link."]
    # [ wasm_bindgen ( js_name = readlink ) ]
    pub fn readlink3(path: &PathLike, options: &JsValue) -> Promise;
    #[doc = "Asynchronous symlink(2) - Create a new symbolic link to an existing file."]
    #[wasm_bindgen()]
    pub fn symlink(target: &PathLike, path: &PathLike, type_: &JsValue) -> Promise;
    #[doc = "Asynchronous fstat(2) - Get file status."]
    #[wasm_bindgen()]
    pub fn fstat(handle: &FileHandle) -> Promise;
    #[doc = "Asynchronous lstat(2) - Get file status. Does not dereference symbolic links."]
    #[wasm_bindgen()]
    pub fn lstat(path: &PathLike) -> Promise;
    #[doc = "Asynchronous stat(2) - Get file status."]
    #[wasm_bindgen()]
    pub fn stat(path: &PathLike) -> Promise;
    #[doc = "Asynchronous link(2) - Create a new link (also known as a hard link) to an existing file."]
    #[wasm_bindgen()]
    pub fn link(existing_path: &PathLike, new_path: &PathLike) -> Promise;
    #[doc = "Asynchronous unlink(2) - delete a name and possibly the file it refers to."]
    #[wasm_bindgen()]
    pub fn unlink(path: &PathLike) -> Promise;
    #[doc = "Asynchronous fchmod(2) - Change permissions of a file."]
    #[wasm_bindgen()]
    pub fn fchmod(handle: &FileHandle, mode: &JsValue) -> Promise;
    #[doc = "Asynchronous chmod(2) - Change permissions of a file."]
    #[wasm_bindgen()]
    pub fn chmod(path: &PathLike, mode: &JsValue) -> Promise;
    #[doc = "Asynchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links."]
    #[wasm_bindgen()]
    pub fn lchmod(path: &PathLike, mode: &JsValue) -> Promise;
    #[doc = "Asynchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links."]
    #[wasm_bindgen()]
    pub fn lchown(path: &PathLike, uid: f64, gid: f64) -> Promise;
    #[doc = "Asynchronous fchown(2) - Change ownership of a file."]
    #[wasm_bindgen()]
    pub fn fchown(handle: &FileHandle, uid: f64, gid: f64) -> Promise;
    #[doc = "Asynchronous chown(2) - Change ownership of a file."]
    #[wasm_bindgen()]
    pub fn chown(path: &PathLike, uid: f64, gid: f64) -> Promise;
    #[doc = "Asynchronously change file timestamps of the file referenced by the supplied path."]
    #[wasm_bindgen()]
    pub fn utimes(path: &PathLike, atime: &JsValue, mtime: &JsValue) -> Promise;
    #[doc = "Asynchronously change file timestamps of the file referenced by the supplied `FileHandle`."]
    #[wasm_bindgen()]
    pub fn futimes(handle: &FileHandle, atime: &JsValue, mtime: &JsValue) -> Promise;
    #[doc = "Asynchronous realpath(3) - return the canonicalized absolute pathname."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronous realpath(3) - return the canonicalized absolute pathname."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronous realpath(3) - return the canonicalized absolute pathname."]
    #[wasm_bindgen()]
    pub fn realpath(path: &PathLike, options: &JsValue) -> Promise;
    #[doc = "Asynchronous realpath(3) - return the canonicalized absolute pathname."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronous realpath(3) - return the canonicalized absolute pathname."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronous realpath(3) - return the canonicalized absolute pathname."]
    # [ wasm_bindgen ( js_name = realpath ) ]
    pub fn realpath2(path: &PathLike, options: &JsValue) -> Promise;
    #[doc = "Asynchronous realpath(3) - return the canonicalized absolute pathname."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronous realpath(3) - return the canonicalized absolute pathname."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronous realpath(3) - return the canonicalized absolute pathname."]
    # [ wasm_bindgen ( js_name = realpath ) ]
    pub fn realpath3(path: &PathLike, options: &JsValue) -> Promise;
    #[doc = "Asynchronously creates a unique temporary directory."]
    #[doc = "Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronously creates a unique temporary directory."]
    #[doc = "Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronously creates a unique temporary directory."]
    #[doc = "Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory."]
    #[wasm_bindgen()]
    pub fn mkdtemp(prefix: &str, options: &JsValue) -> Promise;
    #[doc = "Asynchronously creates a unique temporary directory."]
    #[doc = "Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronously creates a unique temporary directory."]
    #[doc = "Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronously creates a unique temporary directory."]
    #[doc = "Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory."]
    # [ wasm_bindgen ( js_name = mkdtemp ) ]
    pub fn mkdtemp2(prefix: &str, options: &JsValue) -> Promise;
    #[doc = "Asynchronously creates a unique temporary directory."]
    #[doc = "Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronously creates a unique temporary directory."]
    #[doc = "Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronously creates a unique temporary directory."]
    #[doc = "Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory."]
    # [ wasm_bindgen ( js_name = mkdtemp ) ]
    pub fn mkdtemp3(prefix: &str, options: &JsValue) -> Promise;
    #[doc = "Asynchronously writes data to a file, replacing the file if it already exists."]
    #[doc = "It is unsafe to call `fsPromises.writeFile()` multiple times on the same file without waiting for the `Promise` to be resolved (or rejected)."]
    # [ wasm_bindgen ( js_name = writeFile ) ]
    pub fn write_file(path: &JsValue, data: &JsValue, options: &JsValue) -> Promise;
    #[doc = "Asynchronously append data to a file, creating the file if it does not exist."]
    # [ wasm_bindgen ( js_name = appendFile ) ]
    pub fn append_file(path: &JsValue, data: &JsValue, options: &JsValue) -> Promise;
    #[doc = "Asynchronously reads the entire contents of a file."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronously reads the entire contents of a file."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronously reads the entire contents of a file."]
    # [ wasm_bindgen ( js_name = readFile ) ]
    pub fn read_file(path: &JsValue, options: &JsValue) -> Promise;
    #[doc = "Asynchronously reads the entire contents of a file."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronously reads the entire contents of a file."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronously reads the entire contents of a file."]
    # [ wasm_bindgen ( js_name = readFile ) ]
    pub fn read_file2(path: &JsValue, options: &JsValue) -> Promise;
    #[doc = "Asynchronously reads the entire contents of a file."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronously reads the entire contents of a file."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Asynchronously reads the entire contents of a file."]
    # [ wasm_bindgen ( js_name = readFile ) ]
    pub fn read_file3(path: &JsValue, options: &JsValue) -> Promise;
    #[wasm_bindgen()]
    pub fn opendir(path: &str, options: Option<&OpenDirOptions>) -> Promise;
}
