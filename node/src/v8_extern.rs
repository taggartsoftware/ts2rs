// generated by ts2rs 0.1.4
// https://ts2rs.ctaggart.com/

#[wasm_bindgen(module = "v8")]
extern "C" {
    pub type HeapSpaceInfo;
    #[wasm_bindgen(method, getter)]
    pub fn space_name(this: &HeapSpaceInfo) -> String;
    #[wasm_bindgen(method, setter)]
    pub fn set_space_name(this: &HeapSpaceInfo, value: &str);
    #[wasm_bindgen(method, getter)]
    pub fn space_size(this: &HeapSpaceInfo) -> f64;
    #[wasm_bindgen(method, setter)]
    pub fn set_space_size(this: &HeapSpaceInfo, value: f64);
    #[wasm_bindgen(method, getter)]
    pub fn space_used_size(this: &HeapSpaceInfo) -> f64;
    #[wasm_bindgen(method, setter)]
    pub fn set_space_used_size(this: &HeapSpaceInfo, value: f64);
    #[wasm_bindgen(method, getter)]
    pub fn space_available_size(this: &HeapSpaceInfo) -> f64;
    #[wasm_bindgen(method, setter)]
    pub fn set_space_available_size(this: &HeapSpaceInfo, value: f64);
    #[wasm_bindgen(method, getter)]
    pub fn physical_space_size(this: &HeapSpaceInfo) -> f64;
    #[wasm_bindgen(method, setter)]
    pub fn set_physical_space_size(this: &HeapSpaceInfo, value: f64);
    pub type DoesZapCodeSpaceFlag;
    pub type HeapInfo;
    #[wasm_bindgen(method, getter)]
    pub fn total_heap_size(this: &HeapInfo) -> f64;
    #[wasm_bindgen(method, setter)]
    pub fn set_total_heap_size(this: &HeapInfo, value: f64);
    #[wasm_bindgen(method, getter)]
    pub fn total_heap_size_executable(this: &HeapInfo) -> f64;
    #[wasm_bindgen(method, setter)]
    pub fn set_total_heap_size_executable(this: &HeapInfo, value: f64);
    #[wasm_bindgen(method, getter)]
    pub fn total_physical_size(this: &HeapInfo) -> f64;
    #[wasm_bindgen(method, setter)]
    pub fn set_total_physical_size(this: &HeapInfo, value: f64);
    #[wasm_bindgen(method, getter)]
    pub fn total_available_size(this: &HeapInfo) -> f64;
    #[wasm_bindgen(method, setter)]
    pub fn set_total_available_size(this: &HeapInfo, value: f64);
    #[wasm_bindgen(method, getter)]
    pub fn used_heap_size(this: &HeapInfo) -> f64;
    #[wasm_bindgen(method, setter)]
    pub fn set_used_heap_size(this: &HeapInfo, value: f64);
    #[wasm_bindgen(method, getter)]
    pub fn heap_size_limit(this: &HeapInfo) -> f64;
    #[wasm_bindgen(method, setter)]
    pub fn set_heap_size_limit(this: &HeapInfo, value: f64);
    #[wasm_bindgen(method, getter)]
    pub fn malloced_memory(this: &HeapInfo) -> f64;
    #[wasm_bindgen(method, setter)]
    pub fn set_malloced_memory(this: &HeapInfo, value: f64);
    #[wasm_bindgen(method, getter)]
    pub fn peak_malloced_memory(this: &HeapInfo) -> f64;
    #[wasm_bindgen(method, setter)]
    pub fn set_peak_malloced_memory(this: &HeapInfo, value: f64);
    #[wasm_bindgen(method, getter)]
    pub fn does_zap_garbage(this: &HeapInfo) -> DoesZapCodeSpaceFlag;
    #[wasm_bindgen(method, setter)]
    pub fn set_does_zap_garbage(this: &HeapInfo, value: &DoesZapCodeSpaceFlag);
    #[wasm_bindgen(method, getter)]
    pub fn number_of_native_contexts(this: &HeapInfo) -> f64;
    #[wasm_bindgen(method, setter)]
    pub fn set_number_of_native_contexts(this: &HeapInfo, value: f64);
    #[wasm_bindgen(method, getter)]
    pub fn number_of_detached_contexts(this: &HeapInfo) -> f64;
    #[wasm_bindgen(method, setter)]
    pub fn set_number_of_detached_contexts(this: &HeapInfo, value: f64);
    pub type HeapCodeStatistics;
    #[wasm_bindgen(method, getter)]
    pub fn code_and_metadata_size(this: &HeapCodeStatistics) -> f64;
    #[wasm_bindgen(method, setter)]
    pub fn set_code_and_metadata_size(this: &HeapCodeStatistics, value: f64);
    #[wasm_bindgen(method, getter)]
    pub fn bytecode_and_metadata_size(this: &HeapCodeStatistics) -> f64;
    #[wasm_bindgen(method, setter)]
    pub fn set_bytecode_and_metadata_size(this: &HeapCodeStatistics, value: f64);
    #[wasm_bindgen(method, getter)]
    pub fn external_script_source_size(this: &HeapCodeStatistics) -> f64;
    #[wasm_bindgen(method, setter)]
    pub fn set_external_script_source_size(this: &HeapCodeStatistics, value: f64);
    #[doc = "Returns an integer representing a \"version tag\" derived from the V8 version, command line flags and detected CPU features."]
    #[doc = "This is useful for determining whether a vm.Script cachedData buffer is compatible with this instance of V8."]
    # [ wasm_bindgen ( js_name = cachedDataVersionTag ) ]
    pub fn cached_data_version_tag() -> f64;
    # [ wasm_bindgen ( js_name = getHeapStatistics ) ]
    pub fn get_heap_statistics() -> HeapInfo;
    # [ wasm_bindgen ( js_name = getHeapSpaceStatistics ) ]
    pub fn get_heap_space_statistics() -> Array;
    # [ wasm_bindgen ( js_name = setFlagsFromString ) ]
    pub fn set_flags_from_string(flags: &str);
    #[doc = "Generates a snapshot of the current V8 heap and returns a Readable"]
    #[doc = "Stream that may be used to read the JSON serialized representation."]
    #[doc = "This conversation was marked as resolved by joyeecheung"]
    #[doc = "This JSON stream format is intended to be used with tools such as"]
    #[doc = "Chrome DevTools. The JSON schema is undocumented and specific to the"]
    #[doc = "V8 engine, and may change from one version of V8 to the next."]
    # [ wasm_bindgen ( js_name = getHeapSnapshot ) ]
    pub fn get_heap_snapshot() -> Readable;
    # [ wasm_bindgen ( js_name = writeHeapSnapshot ) ]
    pub fn write_heap_snapshot(file_name: Option<&str>) -> String;
    # [ wasm_bindgen ( js_name = getHeapCodeStatistics ) ]
    pub fn get_heap_code_statistics() -> HeapCodeStatistics;
    pub type Serializer;
    #[doc = "Writes out a header, which includes the serialization format version."]
    # [ wasm_bindgen ( method , js_name = writeHeader ) ]
    pub fn write_header(this: &Serializer);
    # [ wasm_bindgen ( method , setter , js_name = writeHeader ) ]
    pub fn set_write_header(this: &Serializer, value: &Function);
    #[doc = "Serializes a JavaScript value and adds the serialized representation to the internal buffer."]
    #[doc = "This throws an error if value cannot be serialized."]
    # [ wasm_bindgen ( method , js_name = writeValue ) ]
    pub fn write_value(this: &Serializer, val: &JsValue) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = writeValue ) ]
    pub fn set_write_value(this: &Serializer, value: &Function);
    #[doc = "Returns the stored internal buffer."]
    #[doc = "This serializer should not be used once the buffer is released."]
    #[doc = "Calling this method results in undefined behavior if a previous write has failed."]
    # [ wasm_bindgen ( method , js_name = releaseBuffer ) ]
    pub fn release_buffer(this: &Serializer) -> Buffer;
    # [ wasm_bindgen ( method , setter , js_name = releaseBuffer ) ]
    pub fn set_release_buffer(this: &Serializer, value: &Function);
    #[doc = "Marks an ArrayBuffer as having its contents transferred out of band.\\"]
    #[doc = "Pass the corresponding ArrayBuffer in the deserializing context to deserializer.transferArrayBuffer()."]
    # [ wasm_bindgen ( method , js_name = transferArrayBuffer ) ]
    pub fn transfer_array_buffer(this: &Serializer, id: f64, array_buffer: &ArrayBuffer);
    # [ wasm_bindgen ( method , setter , js_name = transferArrayBuffer ) ]
    pub fn set_transfer_array_buffer(this: &Serializer, value: &Function);
    #[doc = "Write a raw 32-bit unsigned integer."]
    # [ wasm_bindgen ( method , js_name = writeUint32 ) ]
    pub fn write_uint32(this: &Serializer, value: f64);
    # [ wasm_bindgen ( method , setter , js_name = writeUint32 ) ]
    pub fn set_write_uint32(this: &Serializer, value: &Function);
    #[doc = "Write a raw 64-bit unsigned integer, split into high and low 32-bit parts."]
    # [ wasm_bindgen ( method , js_name = writeUint64 ) ]
    pub fn write_uint64(this: &Serializer, hi: f64, lo: f64);
    # [ wasm_bindgen ( method , setter , js_name = writeUint64 ) ]
    pub fn set_write_uint64(this: &Serializer, value: &Function);
    #[doc = "Write a JS number value."]
    # [ wasm_bindgen ( method , js_name = writeDouble ) ]
    pub fn write_double(this: &Serializer, value: f64);
    # [ wasm_bindgen ( method , setter , js_name = writeDouble ) ]
    pub fn set_write_double(this: &Serializer, value: &Function);
    #[doc = "Write raw bytes into the serializer’s internal buffer."]
    #[doc = "The deserializer will require a way to compute the length of the buffer."]
    # [ wasm_bindgen ( method , js_name = writeRawBytes ) ]
    pub fn write_raw_bytes(this: &Serializer, buffer: &TypedArray);
    # [ wasm_bindgen ( method , setter , js_name = writeRawBytes ) ]
    pub fn set_write_raw_bytes(this: &Serializer, value: &Function);
    #[doc = "A subclass of `Serializer` that serializes `TypedArray` (in particular `Buffer`) and `DataView` objects as host objects,"]
    #[doc = "and only stores the part of their underlying `ArrayBuffers` that they are referring to."]
    pub type DefaultSerializer;
    pub type Deserializer;
    #[wasm_bindgen(constructor)]
    pub fn new_deserializer(data: &TypedArray) -> Deserializer;
    #[doc = "Reads and validates a header (including the format version)."]
    #[doc = "May, for example, reject an invalid or unsupported wire format."]
    #[doc = "In that case, an Error is thrown."]
    # [ wasm_bindgen ( method , js_name = readHeader ) ]
    pub fn read_header(this: &Deserializer) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = readHeader ) ]
    pub fn set_read_header(this: &Deserializer, value: &Function);
    #[doc = "Deserializes a JavaScript value from the buffer and returns it."]
    # [ wasm_bindgen ( method , js_name = readValue ) ]
    pub fn read_value(this: &Deserializer) -> JsValue;
    # [ wasm_bindgen ( method , setter , js_name = readValue ) ]
    pub fn set_read_value(this: &Deserializer, value: &Function);
    #[doc = "Marks an ArrayBuffer as having its contents transferred out of band."]
    #[doc = "Pass the corresponding `ArrayBuffer` in the serializing context to serializer.transferArrayBuffer()"]
    #[doc = "(or return the id from serializer._getSharedArrayBufferId() in the case of SharedArrayBuffers)."]
    # [ wasm_bindgen ( method , js_name = transferArrayBuffer ) ]
    pub fn transfer_array_buffer(this: &Deserializer, id: f64, array_buffer: &ArrayBuffer);
    # [ wasm_bindgen ( method , setter , js_name = transferArrayBuffer ) ]
    pub fn set_transfer_array_buffer(this: &Deserializer, value: &Function);
    #[doc = "Reads the underlying wire format version."]
    #[doc = "Likely mostly to be useful to legacy code reading old wire format versions."]
    #[doc = "May not be called before .readHeader()."]
    # [ wasm_bindgen ( method , js_name = getWireFormatVersion ) ]
    pub fn get_wire_format_version(this: &Deserializer) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = getWireFormatVersion ) ]
    pub fn set_get_wire_format_version(this: &Deserializer, value: &Function);
    #[doc = "Read a raw 32-bit unsigned integer and return it."]
    # [ wasm_bindgen ( method , js_name = readUint32 ) ]
    pub fn read_uint32(this: &Deserializer) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = readUint32 ) ]
    pub fn set_read_uint32(this: &Deserializer, value: &Function);
    #[doc = "Read a raw 64-bit unsigned integer and return it as an array [hi, lo] with two 32-bit unsigned integer entries."]
    # [ wasm_bindgen ( method , js_name = readUint64 ) ]
    pub fn read_uint64(this: &Deserializer) -> JsValue;
    # [ wasm_bindgen ( method , setter , js_name = readUint64 ) ]
    pub fn set_read_uint64(this: &Deserializer, value: &Function);
    #[doc = "Read a JS number value."]
    # [ wasm_bindgen ( method , js_name = readDouble ) ]
    pub fn read_double(this: &Deserializer) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = readDouble ) ]
    pub fn set_read_double(this: &Deserializer, value: &Function);
    #[doc = "Read raw bytes from the deserializer’s internal buffer."]
    #[doc = "The length parameter must correspond to the length of the buffer that was passed to serializer.writeRawBytes()."]
    # [ wasm_bindgen ( method , js_name = readRawBytes ) ]
    pub fn read_raw_bytes(this: &Deserializer, length: f64) -> Buffer;
    # [ wasm_bindgen ( method , setter , js_name = readRawBytes ) ]
    pub fn set_read_raw_bytes(this: &Deserializer, value: &Function);
    #[doc = "A subclass of `Serializer` that serializes `TypedArray` (in particular `Buffer`) and `DataView` objects as host objects,"]
    #[doc = "and only stores the part of their underlying `ArrayBuffers` that they are referring to."]
    pub type DefaultDeserializer;
    #[doc = "Uses a `DefaultSerializer` to serialize value into a buffer."]
    #[wasm_bindgen()]
    pub fn serialize(value: &JsValue) -> Buffer;
    #[doc = "Uses a `DefaultDeserializer` with default options to read a JS value from a buffer."]
    #[wasm_bindgen()]
    pub fn deserialize(data: &TypedArray) -> JsValue;
}
