// generated by ts2rs 0.1.4
// https://ts2rs.ctaggart.com/

#[wasm_bindgen]
extern "C" {
    #[doc = "Provides access to the browser's debugging console (e.g.\u{a0}the Web Console in Firefox). The specifics of how it works varies\u{a0}from browser to browser, but there is a de facto set of features that are typically provided."]
    pub type Console;
    # [ wasm_bindgen ( method , getter , js_name = Console ) ]
    pub fn console(this: &Console) -> node_js::ConsoleConstructor;
    # [ wasm_bindgen ( method , setter , js_name = Console ) ]
    pub fn set_console(this: &Console, value: &node_js::ConsoleConstructor);
    #[wasm_bindgen(method)]
    pub fn assert(this: &Console, value: &JsValue, message: Option<&str>, optional_params: &Array);
    #[wasm_bindgen(method, setter)]
    pub fn set_assert(this: &Console, value: &Function);
    #[wasm_bindgen(method)]
    pub fn clear(this: &Console);
    #[wasm_bindgen(method, setter)]
    pub fn set_clear(this: &Console, value: &Function);
    #[wasm_bindgen(method)]
    pub fn count(this: &Console, label: Option<&str>);
    #[wasm_bindgen(method, setter)]
    pub fn set_count(this: &Console, value: &Function);
    # [ wasm_bindgen ( method , js_name = countReset ) ]
    pub fn count_reset(this: &Console, label: Option<&str>);
    # [ wasm_bindgen ( method , setter , js_name = countReset ) ]
    pub fn set_count_reset(this: &Console, value: &Function);
    #[wasm_bindgen(method)]
    pub fn debug(this: &Console, message: &JsValue, optional_params: &Array);
    #[wasm_bindgen(method, setter)]
    pub fn set_debug(this: &Console, value: &Function);
    #[wasm_bindgen(method)]
    pub fn dir(this: &Console, obj: &JsValue, options: Option<&node_js::InspectOptions>);
    #[wasm_bindgen(method, setter)]
    pub fn set_dir(this: &Console, value: &Function);
    #[wasm_bindgen(method)]
    pub fn dirxml(this: &Console, data: &Array);
    #[wasm_bindgen(method, setter)]
    pub fn set_dirxml(this: &Console, value: &Function);
    #[wasm_bindgen(method)]
    pub fn error(this: &Console, message: &JsValue, optional_params: &Array);
    #[wasm_bindgen(method, setter)]
    pub fn set_error(this: &Console, value: &Function);
    #[wasm_bindgen(method)]
    pub fn group(this: &Console, label: &Array);
    #[wasm_bindgen(method, setter)]
    pub fn set_group(this: &Console, value: &Function);
    # [ wasm_bindgen ( method , js_name = groupCollapsed ) ]
    pub fn group_collapsed(this: &Console, label: &Array);
    # [ wasm_bindgen ( method , setter , js_name = groupCollapsed ) ]
    pub fn set_group_collapsed(this: &Console, value: &Function);
    # [ wasm_bindgen ( method , js_name = groupEnd ) ]
    pub fn group_end(this: &Console);
    # [ wasm_bindgen ( method , setter , js_name = groupEnd ) ]
    pub fn set_group_end(this: &Console, value: &Function);
    #[wasm_bindgen(method)]
    pub fn info(this: &Console, message: &JsValue, optional_params: &Array);
    #[wasm_bindgen(method, setter)]
    pub fn set_info(this: &Console, value: &Function);
    #[wasm_bindgen(method)]
    pub fn log(this: &Console, message: &JsValue, optional_params: &Array);
    #[wasm_bindgen(method, setter)]
    pub fn set_log(this: &Console, value: &Function);
    #[wasm_bindgen(method)]
    pub fn table(this: &Console, tabular_data: &JsValue, properties: Option<&Array>);
    #[wasm_bindgen(method, setter)]
    pub fn set_table(this: &Console, value: &Function);
    #[wasm_bindgen(method)]
    pub fn time(this: &Console, label: Option<&str>);
    #[wasm_bindgen(method, setter)]
    pub fn set_time(this: &Console, value: &Function);
    # [ wasm_bindgen ( method , js_name = timeEnd ) ]
    pub fn time_end(this: &Console, label: Option<&str>);
    # [ wasm_bindgen ( method , setter , js_name = timeEnd ) ]
    pub fn set_time_end(this: &Console, value: &Function);
    # [ wasm_bindgen ( method , js_name = timeLog ) ]
    pub fn time_log(this: &Console, label: Option<&str>, data: &Array);
    # [ wasm_bindgen ( method , setter , js_name = timeLog ) ]
    pub fn set_time_log(this: &Console, value: &Function);
    #[wasm_bindgen(method)]
    pub fn trace(this: &Console, message: &JsValue, optional_params: &Array);
    #[wasm_bindgen(method, setter)]
    pub fn set_trace(this: &Console, value: &Function);
    #[wasm_bindgen(method)]
    pub fn warn(this: &Console, message: &JsValue, optional_params: &Array);
    #[wasm_bindgen(method, setter)]
    pub fn set_warn(this: &Console, value: &Function);
    # [ wasm_bindgen ( method , js_name = markTimeline ) ]
    pub fn mark_timeline(this: &Console, label: Option<&str>);
    # [ wasm_bindgen ( method , setter , js_name = markTimeline ) ]
    pub fn set_mark_timeline(this: &Console, value: &Function);
    #[wasm_bindgen(method)]
    pub fn profile(this: &Console, label: Option<&str>);
    #[wasm_bindgen(method, setter)]
    pub fn set_profile(this: &Console, value: &Function);
    # [ wasm_bindgen ( method , js_name = profileEnd ) ]
    pub fn profile_end(this: &Console, label: Option<&str>);
    # [ wasm_bindgen ( method , setter , js_name = profileEnd ) ]
    pub fn set_profile_end(this: &Console, value: &Function);
    # [ wasm_bindgen ( method , js_name = timeStamp ) ]
    pub fn time_stamp(this: &Console, label: Option<&str>);
    # [ wasm_bindgen ( method , setter , js_name = timeStamp ) ]
    pub fn set_time_stamp(this: &Console, value: &Function);
    #[wasm_bindgen(method)]
    pub fn timeline(this: &Console, label: Option<&str>);
    #[wasm_bindgen(method, setter)]
    pub fn set_timeline(this: &Console, value: &Function);
    # [ wasm_bindgen ( method , js_name = timelineEnd ) ]
    pub fn timeline_end(this: &Console, label: Option<&str>);
    # [ wasm_bindgen ( method , setter , js_name = timelineEnd ) ]
    pub fn set_timeline_end(this: &Console, value: &Function);
    pub type Error;
    #[wasm_bindgen(method, getter)]
    pub fn stack(this: &Error) -> Option<String>;
    #[wasm_bindgen(method, setter)]
    pub fn set_stack(this: &Error, value: Option<&str>);
    pub type ErrorConstructor;
    # [ wasm_bindgen ( method , js_name = captureStackTrace ) ]
    pub fn capture_stack_trace(
        this: &ErrorConstructor,
        target_object: &Object,
        constructor_opt: Option<&Function>,
    );
    # [ wasm_bindgen ( method , setter , js_name = captureStackTrace ) ]
    pub fn set_capture_stack_trace(this: &ErrorConstructor, value: &Function);
    #[doc = "Optional override for formatting stack traces"]
    # [ wasm_bindgen ( method , getter , js_name = prepareStackTrace ) ]
    pub fn prepare_stack_trace(this: &ErrorConstructor) -> Option<Function>;
    # [ wasm_bindgen ( method , setter , js_name = prepareStackTrace ) ]
    pub fn set_prepare_stack_trace(this: &ErrorConstructor, value: Option<&Function>);
    # [ wasm_bindgen ( method , getter , js_name = stackTraceLimit ) ]
    pub fn stack_trace_limit(this: &ErrorConstructor) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = stackTraceLimit ) ]
    pub fn set_stack_trace_limit(this: &ErrorConstructor, value: f64);
    pub type SymbolConstructor;
    #[wasm_bindgen(method, getter)]
    pub fn observable(this: &SymbolConstructor) -> JsValue;
    #[doc = "Allows manipulation and formatting of text strings and determination and location of substrings within strings."]
    pub type String;
    # [ wasm_bindgen ( method , js_name = trimLeft ) ]
    pub fn trim_left(this: &String) -> String;
    # [ wasm_bindgen ( method , setter , js_name = trimLeft ) ]
    pub fn set_trim_left(this: &String, value: &Function);
    # [ wasm_bindgen ( method , js_name = trimRight ) ]
    pub fn trim_right(this: &String) -> String;
    # [ wasm_bindgen ( method , setter , js_name = trimRight ) ]
    pub fn set_trim_right(this: &String, value: &Function);
    #[doc = "The type of `import.meta`.\r"]
    #[doc = "\r"]
    #[doc = "If you need to declare that a given property exists on `import.meta`,\r"]
    #[doc = "this type may be augmented via interface merging."]
    pub type ImportMeta;
    #[wasm_bindgen(method, getter)]
    pub fn url(this: &ImportMeta) -> String;
    #[wasm_bindgen(method, setter)]
    pub fn set_url(this: &ImportMeta, value: &str);
    #[wasm_bindgen(js_name = "process")]
    pub static PROCESS: node_js::Process;
    #[wasm_bindgen(js_name = "console")]
    pub static CONSOLE: Console;
    #[wasm_bindgen(js_name = "__filename")]
    pub static FILENAME: String;
    #[wasm_bindgen(js_name = "__dirname")]
    pub static DIRNAME: String;
    # [ wasm_bindgen ( js_name = setTimeout ) ]
    pub fn set_timeout(callback: &JsValue, ms: f64, args: &Array) -> node_js::Timeout;
    # [ wasm_bindgen ( js_name = clearTimeout ) ]
    pub fn clear_timeout(timeout_id: &node_js::Timeout);
    # [ wasm_bindgen ( js_name = setInterval ) ]
    pub fn set_interval(callback: &JsValue, ms: f64, args: &Array) -> node_js::Timeout;
    # [ wasm_bindgen ( js_name = clearInterval ) ]
    pub fn clear_interval(interval_id: &node_js::Timeout);
    # [ wasm_bindgen ( js_name = setImmediate ) ]
    pub fn set_immediate(callback: &JsValue, args: &Array) -> node_js::Immediate;
    # [ wasm_bindgen ( js_name = clearImmediate ) ]
    pub fn clear_immediate(immediate_id: &node_js::Immediate);
    # [ wasm_bindgen ( js_name = queueMicrotask ) ]
    pub fn queue_microtask(callback: &JsValue);
    pub type NodeRequireFunction;
    pub type NodeRequireCache;
    pub type NodeRequire;
    #[wasm_bindgen(method, getter)]
    pub fn resolve(this: &NodeRequire) -> RequireResolve;
    #[wasm_bindgen(method, setter)]
    pub fn set_resolve(this: &NodeRequire, value: &RequireResolve);
    #[wasm_bindgen(method, getter)]
    pub fn cache(this: &NodeRequire) -> NodeRequireCache;
    #[wasm_bindgen(method, setter)]
    pub fn set_cache(this: &NodeRequire, value: &NodeRequireCache);
    #[wasm_bindgen(method, getter)]
    pub fn extensions(this: &NodeRequire) -> NodeExtensions;
    #[wasm_bindgen(method, setter)]
    pub fn set_extensions(this: &NodeRequire, value: &NodeExtensions);
    #[wasm_bindgen(method, getter)]
    pub fn main(this: &NodeRequire) -> Option<NodeModule>;
    #[wasm_bindgen(method, setter)]
    pub fn set_main(this: &NodeRequire, value: Option<&NodeModule>);
    pub type RequireResolve;
    #[wasm_bindgen(method)]
    pub fn paths(this: &RequireResolve, request: &str) -> JsValue;
    #[wasm_bindgen(method, setter)]
    pub fn set_paths(this: &RequireResolve, value: &Function);
    pub type NodeExtensions;
    #[wasm_bindgen(method, getter)]
    pub fn stringliteral(this: &NodeExtensions) -> Function;
    #[wasm_bindgen(method, setter)]
    pub fn set_stringliteral(this: &NodeExtensions, value: &Function);
    # [ wasm_bindgen ( method , getter , js_name = stringliteral ) ]
    pub fn stringliteral2(this: &NodeExtensions) -> Function;
    # [ wasm_bindgen ( method , setter , js_name = stringliteral ) ]
    pub fn set_stringliteral2(this: &NodeExtensions, value: &Function);
    # [ wasm_bindgen ( method , getter , js_name = stringliteral ) ]
    pub fn stringliteral3(this: &NodeExtensions) -> Function;
    # [ wasm_bindgen ( method , setter , js_name = stringliteral ) ]
    pub fn set_stringliteral3(this: &NodeExtensions, value: &Function);
    #[wasm_bindgen(js_name = "require")]
    pub static REQUIRE: NodeRequire;
    pub type NodeModule;
    #[wasm_bindgen(method, getter)]
    pub fn exports(this: &NodeModule) -> JsValue;
    #[wasm_bindgen(method, setter)]
    pub fn set_exports(this: &NodeModule, value: &JsValue);
    #[wasm_bindgen(method, getter)]
    pub fn require(this: &NodeModule) -> NodeRequireFunction;
    #[wasm_bindgen(method, setter)]
    pub fn set_require(this: &NodeModule, value: &NodeRequireFunction);
    #[wasm_bindgen(method, getter)]
    pub fn id(this: &NodeModule) -> String;
    #[wasm_bindgen(method, setter)]
    pub fn set_id(this: &NodeModule, value: &str);
    #[wasm_bindgen(method, getter)]
    pub fn filename(this: &NodeModule) -> String;
    #[wasm_bindgen(method, setter)]
    pub fn set_filename(this: &NodeModule, value: &str);
    #[wasm_bindgen(method, getter)]
    pub fn loaded(this: &NodeModule) -> bool;
    #[wasm_bindgen(method, setter)]
    pub fn set_loaded(this: &NodeModule, value: bool);
    #[wasm_bindgen(method, getter)]
    pub fn parent(this: &NodeModule) -> JsValue;
    #[wasm_bindgen(method, setter)]
    pub fn set_parent(this: &NodeModule, value: &JsValue);
    #[wasm_bindgen(method, getter)]
    pub fn children(this: &NodeModule) -> Array;
    #[wasm_bindgen(method, setter)]
    pub fn set_children(this: &NodeModule, value: &Array);
    #[wasm_bindgen(method, getter)]
    pub fn paths(this: &NodeModule) -> Array;
    #[wasm_bindgen(method, setter)]
    pub fn set_paths(this: &NodeModule, value: &Array);
    #[wasm_bindgen(js_name = "module")]
    pub static MODULE: NodeModule;
    #[wasm_bindgen(js_name = "exports")]
    pub static EXPORTS: JsValue;
    pub type BufferEncoding;
    #[doc = "Raw data is stored in instances of the Buffer class."]
    #[doc = "A Buffer is similar to an array of integers but corresponds to a raw memory allocation outside the V8 heap.  A Buffer cannot be resized."]
    #[doc = "Valid string encodings: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'binary'(deprecated)|'hex'"]
    pub type Buffer;
    #[wasm_bindgen(method, getter)]
    pub fn constructor(this: &Buffer) -> JsValue;
    #[wasm_bindgen(method, setter)]
    pub fn set_constructor(this: &Buffer, value: &JsValue);
    #[wasm_bindgen(constructor)]
    pub fn new_buffer(str: &str, encoding: Option<&BufferEncoding>) -> Buffer;
    #[wasm_bindgen(constructor)]
    pub fn new_buffer2(size: f64) -> Buffer;
    #[wasm_bindgen(constructor)]
    pub fn new_buffer3(array: &Uint8Array) -> Buffer;
    #[wasm_bindgen(constructor)]
    pub fn new_buffer4(array_buffer: &JsValue) -> Buffer;
    #[wasm_bindgen(constructor)]
    pub fn new_buffer5(array: &Array) -> Buffer;
    #[wasm_bindgen(constructor)]
    pub fn new_buffer6(buffer: &Buffer) -> Buffer;
    #[wasm_bindgen(method)]
    pub fn from(
        this: &Buffer,
        array_buffer: &JsValue,
        byte_offset: Option<f64>,
        length: Option<f64>,
    ) -> Buffer;
    #[wasm_bindgen(method, setter)]
    pub fn set_from(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = from ) ]
    pub fn from2(this: &Buffer, data: &Array) -> Buffer;
    # [ wasm_bindgen ( method , setter , js_name = from ) ]
    pub fn set_from2(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = from ) ]
    pub fn from3(this: &Buffer, data: &Uint8Array) -> Buffer;
    # [ wasm_bindgen ( method , setter , js_name = from ) ]
    pub fn set_from3(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = from ) ]
    pub fn from4(
        this: &Buffer,
        obj: &JsValue,
        byte_offset: Option<f64>,
        length: Option<f64>,
    ) -> Buffer;
    # [ wasm_bindgen ( method , setter , js_name = from ) ]
    pub fn set_from4(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = from ) ]
    pub fn from5(this: &Buffer, str: &str, encoding: Option<&BufferEncoding>) -> Buffer;
    # [ wasm_bindgen ( method , setter , js_name = from ) ]
    pub fn set_from5(this: &Buffer, value: &Function);
    #[wasm_bindgen(method)]
    pub fn of(this: &Buffer, items: &Array) -> Buffer;
    #[wasm_bindgen(method, setter)]
    pub fn set_of(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = isBuffer ) ]
    pub fn is_buffer(this: &Buffer, obj: &JsValue) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = isBuffer ) ]
    pub fn set_is_buffer(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = isEncoding ) ]
    pub fn is_encoding(this: &Buffer, encoding: &str) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = isEncoding ) ]
    pub fn set_is_encoding(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = byteLength ) ]
    pub fn byte_length(this: &Buffer, string: &JsValue, encoding: Option<&BufferEncoding>) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = byteLength ) ]
    pub fn set_byte_length(this: &Buffer, value: &Function);
    #[wasm_bindgen(method)]
    pub fn concat(this: &Buffer, list: &Array, total_length: Option<f64>) -> Buffer;
    #[wasm_bindgen(method, setter)]
    pub fn set_concat(this: &Buffer, value: &Function);
    #[wasm_bindgen(method)]
    pub fn compare(this: &Buffer, buf1: &Uint8Array, buf2: &Uint8Array) -> f64;
    #[wasm_bindgen(method, setter)]
    pub fn set_compare(this: &Buffer, value: &Function);
    #[wasm_bindgen(method)]
    pub fn alloc(
        this: &Buffer,
        size: f64,
        fill: &JsValue,
        encoding: Option<&BufferEncoding>,
    ) -> Buffer;
    #[wasm_bindgen(method, setter)]
    pub fn set_alloc(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = allocUnsafe ) ]
    pub fn alloc_unsafe(this: &Buffer, size: f64) -> Buffer;
    # [ wasm_bindgen ( method , setter , js_name = allocUnsafe ) ]
    pub fn set_alloc_unsafe(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = allocUnsafeSlow ) ]
    pub fn alloc_unsafe_slow(this: &Buffer, size: f64) -> Buffer;
    # [ wasm_bindgen ( method , setter , js_name = allocUnsafeSlow ) ]
    pub fn set_alloc_unsafe_slow(this: &Buffer, value: &Function);
    #[doc = "This is the number of bytes used to determine the size of pre-allocated, internal Buffer instances used for pooling. This value may be modified."]
    # [ wasm_bindgen ( method , getter , js_name = poolSize ) ]
    pub fn pool_size(this: &Buffer) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = poolSize ) ]
    pub fn set_pool_size(this: &Buffer, value: f64);
    #[wasm_bindgen(method)]
    pub fn write(this: &Buffer, string: &str, encoding: Option<&BufferEncoding>) -> f64;
    #[wasm_bindgen(method, setter)]
    pub fn set_write(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = write ) ]
    pub fn write2(
        this: &Buffer,
        string: &str,
        offset: f64,
        encoding: Option<&BufferEncoding>,
    ) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = write ) ]
    pub fn set_write2(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = write ) ]
    pub fn write3(
        this: &Buffer,
        string: &str,
        offset: f64,
        length: f64,
        encoding: Option<&BufferEncoding>,
    ) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = write ) ]
    pub fn set_write3(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = toString ) ]
    pub fn to_string(
        this: &Buffer,
        encoding: Option<&str>,
        start: Option<f64>,
        end: Option<f64>,
    ) -> String;
    # [ wasm_bindgen ( method , setter , js_name = toString ) ]
    pub fn set_to_string(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = toJSON ) ]
    pub fn to_json(this: &Buffer) -> JsValue;
    # [ wasm_bindgen ( method , setter , js_name = toJSON ) ]
    pub fn set_to_json(this: &Buffer, value: &Function);
    #[wasm_bindgen(method)]
    pub fn equals(this: &Buffer, other_buffer: &Uint8Array) -> bool;
    #[wasm_bindgen(method, setter)]
    pub fn set_equals(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = compare ) ]
    pub fn compare2(
        this: &Buffer,
        other_buffer: &Uint8Array,
        target_start: Option<f64>,
        target_end: Option<f64>,
        source_start: Option<f64>,
        source_end: Option<f64>,
    ) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = compare ) ]
    pub fn set_compare2(this: &Buffer, value: &Function);
    #[wasm_bindgen(method)]
    pub fn copy(
        this: &Buffer,
        target_buffer: &Uint8Array,
        target_start: Option<f64>,
        source_start: Option<f64>,
        source_end: Option<f64>,
    ) -> f64;
    #[wasm_bindgen(method, setter)]
    pub fn set_copy(this: &Buffer, value: &Function);
    #[wasm_bindgen(method)]
    pub fn slice(this: &Buffer, begin: Option<f64>, end: Option<f64>) -> Buffer;
    #[wasm_bindgen(method, setter)]
    pub fn set_slice(this: &Buffer, value: &Function);
    #[wasm_bindgen(method)]
    pub fn subarray(this: &Buffer, begin: Option<f64>, end: Option<f64>) -> Buffer;
    #[wasm_bindgen(method, setter)]
    pub fn set_subarray(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = writeUIntLE ) ]
    pub fn write_u_int_le(this: &Buffer, value: f64, offset: f64, byte_length: f64) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = writeUIntLE ) ]
    pub fn set_write_u_int_le(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = writeUIntBE ) ]
    pub fn write_u_int_be(this: &Buffer, value: f64, offset: f64, byte_length: f64) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = writeUIntBE ) ]
    pub fn set_write_u_int_be(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = writeIntLE ) ]
    pub fn write_int_le(this: &Buffer, value: f64, offset: f64, byte_length: f64) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = writeIntLE ) ]
    pub fn set_write_int_le(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = writeIntBE ) ]
    pub fn write_int_be(this: &Buffer, value: f64, offset: f64, byte_length: f64) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = writeIntBE ) ]
    pub fn set_write_int_be(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = readUIntLE ) ]
    pub fn read_u_int_le(this: &Buffer, offset: f64, byte_length: f64) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = readUIntLE ) ]
    pub fn set_read_u_int_le(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = readUIntBE ) ]
    pub fn read_u_int_be(this: &Buffer, offset: f64, byte_length: f64) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = readUIntBE ) ]
    pub fn set_read_u_int_be(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = readIntLE ) ]
    pub fn read_int_le(this: &Buffer, offset: f64, byte_length: f64) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = readIntLE ) ]
    pub fn set_read_int_le(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = readIntBE ) ]
    pub fn read_int_be(this: &Buffer, offset: f64, byte_length: f64) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = readIntBE ) ]
    pub fn set_read_int_be(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = readUInt8 ) ]
    pub fn read_u_int8(this: &Buffer, offset: f64) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = readUInt8 ) ]
    pub fn set_read_u_int8(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = readUInt16LE ) ]
    pub fn read_u_int16_le(this: &Buffer, offset: f64) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = readUInt16LE ) ]
    pub fn set_read_u_int16_le(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = readUInt16BE ) ]
    pub fn read_u_int16_be(this: &Buffer, offset: f64) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = readUInt16BE ) ]
    pub fn set_read_u_int16_be(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = readUInt32LE ) ]
    pub fn read_u_int32_le(this: &Buffer, offset: f64) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = readUInt32LE ) ]
    pub fn set_read_u_int32_le(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = readUInt32BE ) ]
    pub fn read_u_int32_be(this: &Buffer, offset: f64) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = readUInt32BE ) ]
    pub fn set_read_u_int32_be(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = readInt8 ) ]
    pub fn read_int8(this: &Buffer, offset: f64) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = readInt8 ) ]
    pub fn set_read_int8(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = readInt16LE ) ]
    pub fn read_int16_le(this: &Buffer, offset: f64) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = readInt16LE ) ]
    pub fn set_read_int16_le(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = readInt16BE ) ]
    pub fn read_int16_be(this: &Buffer, offset: f64) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = readInt16BE ) ]
    pub fn set_read_int16_be(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = readInt32LE ) ]
    pub fn read_int32_le(this: &Buffer, offset: f64) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = readInt32LE ) ]
    pub fn set_read_int32_le(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = readInt32BE ) ]
    pub fn read_int32_be(this: &Buffer, offset: f64) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = readInt32BE ) ]
    pub fn set_read_int32_be(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = readFloatLE ) ]
    pub fn read_float_le(this: &Buffer, offset: f64) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = readFloatLE ) ]
    pub fn set_read_float_le(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = readFloatBE ) ]
    pub fn read_float_be(this: &Buffer, offset: f64) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = readFloatBE ) ]
    pub fn set_read_float_be(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = readDoubleLE ) ]
    pub fn read_double_le(this: &Buffer, offset: f64) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = readDoubleLE ) ]
    pub fn set_read_double_le(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = readDoubleBE ) ]
    pub fn read_double_be(this: &Buffer, offset: f64) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = readDoubleBE ) ]
    pub fn set_read_double_be(this: &Buffer, value: &Function);
    #[wasm_bindgen(method)]
    pub fn reverse(this: &Buffer) -> Buffer;
    #[wasm_bindgen(method, setter)]
    pub fn set_reverse(this: &Buffer, value: &Function);
    #[wasm_bindgen(method)]
    pub fn swap16(this: &Buffer) -> Buffer;
    #[wasm_bindgen(method, setter)]
    pub fn set_swap16(this: &Buffer, value: &Function);
    #[wasm_bindgen(method)]
    pub fn swap32(this: &Buffer) -> Buffer;
    #[wasm_bindgen(method, setter)]
    pub fn set_swap32(this: &Buffer, value: &Function);
    #[wasm_bindgen(method)]
    pub fn swap64(this: &Buffer) -> Buffer;
    #[wasm_bindgen(method, setter)]
    pub fn set_swap64(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = writeUInt8 ) ]
    pub fn write_u_int8(this: &Buffer, value: f64, offset: f64) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = writeUInt8 ) ]
    pub fn set_write_u_int8(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = writeUInt16LE ) ]
    pub fn write_u_int16_le(this: &Buffer, value: f64, offset: f64) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = writeUInt16LE ) ]
    pub fn set_write_u_int16_le(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = writeUInt16BE ) ]
    pub fn write_u_int16_be(this: &Buffer, value: f64, offset: f64) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = writeUInt16BE ) ]
    pub fn set_write_u_int16_be(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = writeUInt32LE ) ]
    pub fn write_u_int32_le(this: &Buffer, value: f64, offset: f64) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = writeUInt32LE ) ]
    pub fn set_write_u_int32_le(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = writeUInt32BE ) ]
    pub fn write_u_int32_be(this: &Buffer, value: f64, offset: f64) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = writeUInt32BE ) ]
    pub fn set_write_u_int32_be(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = writeInt8 ) ]
    pub fn write_int8(this: &Buffer, value: f64, offset: f64) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = writeInt8 ) ]
    pub fn set_write_int8(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = writeInt16LE ) ]
    pub fn write_int16_le(this: &Buffer, value: f64, offset: f64) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = writeInt16LE ) ]
    pub fn set_write_int16_le(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = writeInt16BE ) ]
    pub fn write_int16_be(this: &Buffer, value: f64, offset: f64) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = writeInt16BE ) ]
    pub fn set_write_int16_be(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = writeInt32LE ) ]
    pub fn write_int32_le(this: &Buffer, value: f64, offset: f64) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = writeInt32LE ) ]
    pub fn set_write_int32_le(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = writeInt32BE ) ]
    pub fn write_int32_be(this: &Buffer, value: f64, offset: f64) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = writeInt32BE ) ]
    pub fn set_write_int32_be(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = writeFloatLE ) ]
    pub fn write_float_le(this: &Buffer, value: f64, offset: f64) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = writeFloatLE ) ]
    pub fn set_write_float_le(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = writeFloatBE ) ]
    pub fn write_float_be(this: &Buffer, value: f64, offset: f64) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = writeFloatBE ) ]
    pub fn set_write_float_be(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = writeDoubleLE ) ]
    pub fn write_double_le(this: &Buffer, value: f64, offset: f64) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = writeDoubleLE ) ]
    pub fn set_write_double_le(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = writeDoubleBE ) ]
    pub fn write_double_be(this: &Buffer, value: f64, offset: f64) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = writeDoubleBE ) ]
    pub fn set_write_double_be(this: &Buffer, value: &Function);
    #[wasm_bindgen(method)]
    pub fn fill(
        this: &Buffer,
        value: &JsValue,
        offset: Option<f64>,
        end: Option<f64>,
        encoding: Option<&BufferEncoding>,
    ) -> Buffer;
    #[wasm_bindgen(method, setter)]
    pub fn set_fill(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = indexOf ) ]
    pub fn index_of(
        this: &Buffer,
        value: &JsValue,
        byte_offset: Option<f64>,
        encoding: Option<&BufferEncoding>,
    ) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = indexOf ) ]
    pub fn set_index_of(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = lastIndexOf ) ]
    pub fn last_index_of(
        this: &Buffer,
        value: &JsValue,
        byte_offset: Option<f64>,
        encoding: Option<&BufferEncoding>,
    ) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = lastIndexOf ) ]
    pub fn set_last_index_of(this: &Buffer, value: &Function);
    #[wasm_bindgen(method)]
    pub fn entries(this: &Buffer) -> IterableIterator;
    #[wasm_bindgen(method, setter)]
    pub fn set_entries(this: &Buffer, value: &Function);
    #[wasm_bindgen(method)]
    pub fn includes(
        this: &Buffer,
        value: &JsValue,
        byte_offset: Option<f64>,
        encoding: Option<&BufferEncoding>,
    ) -> bool;
    #[wasm_bindgen(method, setter)]
    pub fn set_includes(this: &Buffer, value: &Function);
    #[wasm_bindgen(method)]
    pub fn keys(this: &Buffer) -> IterableIterator;
    #[wasm_bindgen(method, setter)]
    pub fn set_keys(this: &Buffer, value: &Function);
    #[wasm_bindgen(method)]
    pub fn values(this: &Buffer) -> IterableIterator;
    #[wasm_bindgen(method, setter)]
    pub fn set_values(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = readBigUInt64BE ) ]
    pub fn read_big_u_int64_be(this: &Buffer, offset: Option<f64>) -> JsValue;
    # [ wasm_bindgen ( method , setter , js_name = readBigUInt64BE ) ]
    pub fn set_read_big_u_int64_be(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = readBigUInt64LE ) ]
    pub fn read_big_u_int64_le(this: &Buffer, offset: Option<f64>) -> JsValue;
    # [ wasm_bindgen ( method , setter , js_name = readBigUInt64LE ) ]
    pub fn set_read_big_u_int64_le(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = readBigInt64BE ) ]
    pub fn read_big_int64_be(this: &Buffer, offset: Option<f64>) -> JsValue;
    # [ wasm_bindgen ( method , setter , js_name = readBigInt64BE ) ]
    pub fn set_read_big_int64_be(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = readBigInt64LE ) ]
    pub fn read_big_int64_le(this: &Buffer, offset: Option<f64>) -> JsValue;
    # [ wasm_bindgen ( method , setter , js_name = readBigInt64LE ) ]
    pub fn set_read_big_int64_le(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = writeBigInt64BE ) ]
    pub fn write_big_int64_be(this: &Buffer, value: &JsValue, offset: Option<f64>) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = writeBigInt64BE ) ]
    pub fn set_write_big_int64_be(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = writeBigInt64LE ) ]
    pub fn write_big_int64_le(this: &Buffer, value: &JsValue, offset: Option<f64>) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = writeBigInt64LE ) ]
    pub fn set_write_big_int64_le(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = writeBigUInt64BE ) ]
    pub fn write_big_u_int64_be(this: &Buffer, value: &JsValue, offset: Option<f64>) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = writeBigUInt64BE ) ]
    pub fn set_write_big_u_int64_be(this: &Buffer, value: &Function);
    # [ wasm_bindgen ( method , js_name = writeBigUInt64LE ) ]
    pub fn write_big_u_int64_le(this: &Buffer, value: &JsValue, offset: Option<f64>) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = writeBigUInt64LE ) ]
    pub fn set_write_big_u_int64_le(this: &Buffer, value: &Function);
    #[wasm_bindgen(js_name = "global")]
    pub static GLOBAL: JsValue;
}
