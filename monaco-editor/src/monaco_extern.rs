// generated by ts2rs 0.1.3
// https://ts2rs.ctaggart.com/

#[wasm_bindgen(module = "monaco")]
extern "C" {
    pub type Thenable;
    pub type Environment;
    # [ wasm_bindgen ( method , getter , js_name = baseUrl ) ]
    pub fn base_url(this: &Environment) -> Option<String>;
    # [ wasm_bindgen ( method , setter , js_name = baseUrl ) ]
    pub fn set_base_url(this: &Environment, value: Option<&str>);
    # [ wasm_bindgen ( method , js_name = getWorker ) ]
    pub fn get_worker(this: &Environment, worker_id: &str, label: &str) -> Worker;
    # [ wasm_bindgen ( method , setter , js_name = getWorker ) ]
    pub fn set_get_worker(this: &Environment, value: Option<&Function>);
    # [ wasm_bindgen ( method , js_name = getWorkerUrl ) ]
    pub fn get_worker_url(this: &Environment, worker_id: &str, label: &str) -> String;
    # [ wasm_bindgen ( method , setter , js_name = getWorkerUrl ) ]
    pub fn set_get_worker_url(this: &Environment, value: Option<&Function>);
    pub type IDisposable;
    #[wasm_bindgen(method)]
    pub fn dispose(this: &IDisposable);
    #[wasm_bindgen(method, setter)]
    pub fn set_dispose(this: &IDisposable, value: &Function);
    pub type IEvent;
    #[doc = "A helper that allows to emit and listen to typed events"]
    pub type Emitter;
    #[wasm_bindgen(constructor)]
    pub fn new_emitter() -> Emitter;
    #[wasm_bindgen(method, getter)]
    pub fn event(this: &Emitter) -> IEvent;
    #[wasm_bindgen(method)]
    pub fn fire(this: &Emitter, event: &JsValue);
    #[wasm_bindgen(method, setter)]
    pub fn set_fire(this: &Emitter, value: &Function);
    #[wasm_bindgen(method)]
    pub fn dispose(this: &Emitter);
    #[wasm_bindgen(method, setter)]
    pub fn set_dispose(this: &Emitter, value: &Function);
    pub type CancellationTokenSource;
    #[wasm_bindgen(constructor)]
    pub fn new_cancellation_token_source(
        parent: Option<&CancellationToken>,
    ) -> CancellationTokenSource;
    #[wasm_bindgen(method)]
    pub fn cancel(this: &CancellationTokenSource);
    #[wasm_bindgen(method, setter)]
    pub fn set_cancel(this: &CancellationTokenSource, value: &Function);
    #[wasm_bindgen(method)]
    pub fn dispose(this: &CancellationTokenSource, cancel: Option<bool>);
    #[wasm_bindgen(method, setter)]
    pub fn set_dispose(this: &CancellationTokenSource, value: &Function);
    pub type CancellationToken;
    # [ wasm_bindgen ( method , getter , js_name = isCancellationRequested ) ]
    pub fn is_cancellation_requested(this: &CancellationToken) -> bool;
    #[doc = "An event emitted when cancellation is requested"]
    # [ wasm_bindgen ( method , getter , js_name = onCancellationRequested ) ]
    pub fn on_cancellation_requested(this: &CancellationToken) -> IEvent;
    #[doc = "Uniform Resource Identifier (Uri) http://tools.ietf.org/html/rfc3986."]
    #[doc = "This class is a simple parser which creates the basic component parts"]
    #[doc = "(http://tools.ietf.org/html/rfc3986#section-3) with minimal validation"]
    #[doc = "and encoding."]
    #[doc = ""]
    #[doc = "       foo://example.com:8042/over/there?name=ferret#nose"]
    #[doc = "       \\_/   \\______________/\\_________/ \\_________/ \\__/"]
    #[doc = "        |           |            |            |        |"]
    #[doc = "     scheme     authority       path        query   fragment"]
    #[doc = "        |   _____________________|__"]
    #[doc = "       / \\ /                        \\"]
    #[doc = "       urn:example:animal:ferret:nose"]
    pub type Uri;
    # [ wasm_bindgen ( method , js_name = isUri ) ]
    pub fn is_uri(this: &Uri, thing: &JsValue) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = isUri ) ]
    pub fn set_is_uri(this: &Uri, value: &Function);
    #[doc = "scheme is the 'http' part of 'http://www.msft.com/some/path?query#fragment'."]
    #[doc = "The part before the first colon."]
    #[wasm_bindgen(method, getter)]
    pub fn scheme(this: &Uri) -> String;
    #[doc = "authority is the 'www.msft.com' part of 'http://www.msft.com/some/path?query#fragment'."]
    #[doc = "The part between the first double slashes and the next slash."]
    #[wasm_bindgen(method, getter)]
    pub fn authority(this: &Uri) -> String;
    #[doc = "path is the '/some/path' part of 'http://www.msft.com/some/path?query#fragment'."]
    #[wasm_bindgen(method, getter)]
    pub fn path(this: &Uri) -> String;
    #[doc = "query is the 'query' part of 'http://www.msft.com/some/path?query#fragment'."]
    #[wasm_bindgen(method, getter)]
    pub fn query(this: &Uri) -> String;
    #[doc = "fragment is the 'fragment' part of 'http://www.msft.com/some/path?query#fragment'."]
    #[wasm_bindgen(method, getter)]
    pub fn fragment(this: &Uri) -> String;
    #[wasm_bindgen(method)]
    pub fn with(this: &Uri, change: &JsValue) -> Uri;
    #[wasm_bindgen(method, setter)]
    pub fn set_with(this: &Uri, value: &Function);
    #[doc = "Creates a new Uri from a string, e.g. `http://www.msft.com/some/path`,"]
    #[doc = "`file:///usr/home`, or `scheme:with/path`."]
    #[wasm_bindgen(method)]
    pub fn parse(this: &Uri, value: &str, strict: Option<bool>) -> Uri;
    #[wasm_bindgen(method, setter)]
    pub fn set_parse(this: &Uri, value: &Function);
    #[doc = "Creates a new Uri from a file system path, e.g. `c:\\my\\files`,"]
    #[doc = "`/usr/home`, or `\\\\server\\share\\some\\path`."]
    #[doc = ""]
    #[doc = "The *difference* between `Uri#parse` and `Uri#file` is that the latter treats the argument"]
    #[doc = "as path, not as stringified-uri. E.g. `Uri.file(path)` is **not the same as**"]
    #[doc = "`Uri.parse('file://' + path)` because the path might contain characters that are"]
    #[doc = "interpreted (# and ?). See the following sample:"]
    #[doc = "```ts"]
    #[doc = "const good = Uri.file('/coding/c#/project1');"]
    #[doc = "good.scheme === 'file';"]
    #[doc = "good.path === '/coding/c#/project1';"]
    #[doc = "good.fragment === '';"]
    #[doc = "const bad = Uri.parse('file://' + '/coding/c#/project1');"]
    #[doc = "bad.scheme === 'file';"]
    #[doc = "bad.path === '/coding/c'; // path is now broken"]
    #[doc = "bad.fragment === '/project1';"]
    #[doc = "```"]
    #[wasm_bindgen(method)]
    pub fn file(this: &Uri, path: &str) -> Uri;
    #[wasm_bindgen(method, setter)]
    pub fn set_file(this: &Uri, value: &Function);
    #[wasm_bindgen(method)]
    pub fn from(this: &Uri, components: &JsValue) -> Uri;
    #[wasm_bindgen(method, setter)]
    pub fn set_from(this: &Uri, value: &Function);
    #[doc = "Creates a string representation for this Uri. It's guaranteed that calling"]
    #[doc = "`Uri.parse` with the result of this function creates an Uri which is equal"]
    #[doc = "to this Uri."]
    #[doc = ""]
    #[doc = "* The result shall *not* be used for display purposes but for externalization or transport."]
    #[doc = "* The result will be encoded using the percentage encoding and encoding happens mostly"]
    #[doc = "ignore the scheme-specific encoding rules."]
    # [ wasm_bindgen ( method , js_name = toString ) ]
    pub fn to_string(this: &Uri, skip_encoding: Option<bool>) -> String;
    # [ wasm_bindgen ( method , setter , js_name = toString ) ]
    pub fn set_to_string(this: &Uri, value: &Function);
    # [ wasm_bindgen ( method , js_name = toJSON ) ]
    pub fn to_json(this: &Uri) -> UriComponents;
    # [ wasm_bindgen ( method , setter , js_name = toJSON ) ]
    pub fn set_to_json(this: &Uri, value: &Function);
    #[wasm_bindgen(method)]
    pub fn revive(this: &Uri, data: &JsValue) -> Uri;
    #[wasm_bindgen(method, setter)]
    pub fn set_revive(this: &Uri, value: &Function);
    # [ wasm_bindgen ( method , js_name = revive ) ]
    pub fn revive2(this: &Uri, data: &JsValue) -> Option<Uri>;
    # [ wasm_bindgen ( method , setter , js_name = revive ) ]
    pub fn set_revive2(this: &Uri, value: &Function);
    # [ wasm_bindgen ( method , js_name = revive ) ]
    pub fn revive3(this: &Uri, data: &JsValue) -> JsValue;
    # [ wasm_bindgen ( method , setter , js_name = revive ) ]
    pub fn set_revive3(this: &Uri, value: &Function);
    # [ wasm_bindgen ( method , js_name = revive ) ]
    pub fn revive4(this: &Uri, data: &JsValue) -> JsValue;
    # [ wasm_bindgen ( method , setter , js_name = revive ) ]
    pub fn set_revive4(this: &Uri, value: &Function);
    pub type UriComponents;
    #[wasm_bindgen(method, getter)]
    pub fn scheme(this: &UriComponents) -> String;
    #[wasm_bindgen(method, setter)]
    pub fn set_scheme(this: &UriComponents, value: &str);
    #[wasm_bindgen(method, getter)]
    pub fn authority(this: &UriComponents) -> String;
    #[wasm_bindgen(method, setter)]
    pub fn set_authority(this: &UriComponents, value: &str);
    #[wasm_bindgen(method, getter)]
    pub fn path(this: &UriComponents) -> String;
    #[wasm_bindgen(method, setter)]
    pub fn set_path(this: &UriComponents, value: &str);
    #[wasm_bindgen(method, getter)]
    pub fn query(this: &UriComponents) -> String;
    #[wasm_bindgen(method, setter)]
    pub fn set_query(this: &UriComponents, value: &str);
    #[wasm_bindgen(method, getter)]
    pub fn fragment(this: &UriComponents) -> String;
    #[wasm_bindgen(method, setter)]
    pub fn set_fragment(this: &UriComponents, value: &str);
    pub type KeyMod;
    # [ wasm_bindgen ( method , getter , js_name = CtrlCmd ) ]
    pub fn ctrl_cmd(this: &KeyMod) -> f64;
    # [ wasm_bindgen ( method , getter , js_name = Shift ) ]
    pub fn shift(this: &KeyMod) -> f64;
    # [ wasm_bindgen ( method , getter , js_name = Alt ) ]
    pub fn alt(this: &KeyMod) -> f64;
    # [ wasm_bindgen ( method , getter , js_name = WinCtrl ) ]
    pub fn win_ctrl(this: &KeyMod) -> f64;
    #[wasm_bindgen(method)]
    pub fn chord(this: &KeyMod, first_part: f64, second_part: f64) -> f64;
    #[wasm_bindgen(method, setter)]
    pub fn set_chord(this: &KeyMod, value: &Function);
    pub type IMarkdownString;
    #[wasm_bindgen(method, getter)]
    pub fn value(this: &IMarkdownString) -> String;
    # [ wasm_bindgen ( method , getter , js_name = isTrusted ) ]
    pub fn is_trusted(this: &IMarkdownString) -> Option<bool>;
    # [ wasm_bindgen ( method , getter , js_name = supportThemeIcons ) ]
    pub fn support_theme_icons(this: &IMarkdownString) -> Option<bool>;
    #[wasm_bindgen(method, getter)]
    pub fn uris(this: &IMarkdownString) -> JsValue;
    #[wasm_bindgen(method, setter)]
    pub fn set_uris(this: &IMarkdownString, value: &JsValue);
    pub type IKeyboardEvent;
    # [ wasm_bindgen ( method , getter , js_name = _standardKeyboardEventBrand ) ]
    pub fn standard_keyboard_event_brand(this: &IKeyboardEvent) -> JsValue;
    # [ wasm_bindgen ( method , getter , js_name = browserEvent ) ]
    pub fn browser_event(this: &IKeyboardEvent) -> KeyboardEvent;
    #[wasm_bindgen(method, getter)]
    pub fn target(this: &IKeyboardEvent) -> HTMLElement;
    # [ wasm_bindgen ( method , getter , js_name = ctrlKey ) ]
    pub fn ctrl_key(this: &IKeyboardEvent) -> bool;
    # [ wasm_bindgen ( method , getter , js_name = shiftKey ) ]
    pub fn shift_key(this: &IKeyboardEvent) -> bool;
    # [ wasm_bindgen ( method , getter , js_name = altKey ) ]
    pub fn alt_key(this: &IKeyboardEvent) -> bool;
    # [ wasm_bindgen ( method , getter , js_name = metaKey ) ]
    pub fn meta_key(this: &IKeyboardEvent) -> bool;
    # [ wasm_bindgen ( method , getter , js_name = keyCode ) ]
    pub fn key_code(this: &IKeyboardEvent) -> KeyCode;
    #[wasm_bindgen(method, getter)]
    pub fn code(this: &IKeyboardEvent) -> String;
    #[wasm_bindgen(method)]
    pub fn equals(this: &IKeyboardEvent, keybinding: f64) -> bool;
    #[wasm_bindgen(method, setter)]
    pub fn set_equals(this: &IKeyboardEvent, value: &Function);
    # [ wasm_bindgen ( method , js_name = preventDefault ) ]
    pub fn prevent_default(this: &IKeyboardEvent);
    # [ wasm_bindgen ( method , setter , js_name = preventDefault ) ]
    pub fn set_prevent_default(this: &IKeyboardEvent, value: &Function);
    # [ wasm_bindgen ( method , js_name = stopPropagation ) ]
    pub fn stop_propagation(this: &IKeyboardEvent);
    # [ wasm_bindgen ( method , setter , js_name = stopPropagation ) ]
    pub fn set_stop_propagation(this: &IKeyboardEvent, value: &Function);
    pub type IMouseEvent;
    # [ wasm_bindgen ( method , getter , js_name = browserEvent ) ]
    pub fn browser_event(this: &IMouseEvent) -> MouseEvent;
    # [ wasm_bindgen ( method , getter , js_name = leftButton ) ]
    pub fn left_button(this: &IMouseEvent) -> bool;
    # [ wasm_bindgen ( method , getter , js_name = middleButton ) ]
    pub fn middle_button(this: &IMouseEvent) -> bool;
    # [ wasm_bindgen ( method , getter , js_name = rightButton ) ]
    pub fn right_button(this: &IMouseEvent) -> bool;
    #[wasm_bindgen(method, getter)]
    pub fn buttons(this: &IMouseEvent) -> f64;
    #[wasm_bindgen(method, getter)]
    pub fn target(this: &IMouseEvent) -> HTMLElement;
    #[wasm_bindgen(method, getter)]
    pub fn detail(this: &IMouseEvent) -> f64;
    #[wasm_bindgen(method, getter)]
    pub fn posx(this: &IMouseEvent) -> f64;
    #[wasm_bindgen(method, getter)]
    pub fn posy(this: &IMouseEvent) -> f64;
    # [ wasm_bindgen ( method , getter , js_name = ctrlKey ) ]
    pub fn ctrl_key(this: &IMouseEvent) -> bool;
    # [ wasm_bindgen ( method , getter , js_name = shiftKey ) ]
    pub fn shift_key(this: &IMouseEvent) -> bool;
    # [ wasm_bindgen ( method , getter , js_name = altKey ) ]
    pub fn alt_key(this: &IMouseEvent) -> bool;
    # [ wasm_bindgen ( method , getter , js_name = metaKey ) ]
    pub fn meta_key(this: &IMouseEvent) -> bool;
    #[wasm_bindgen(method, getter)]
    pub fn timestamp(this: &IMouseEvent) -> f64;
    # [ wasm_bindgen ( method , js_name = preventDefault ) ]
    pub fn prevent_default(this: &IMouseEvent);
    # [ wasm_bindgen ( method , setter , js_name = preventDefault ) ]
    pub fn set_prevent_default(this: &IMouseEvent, value: &Function);
    # [ wasm_bindgen ( method , js_name = stopPropagation ) ]
    pub fn stop_propagation(this: &IMouseEvent);
    # [ wasm_bindgen ( method , setter , js_name = stopPropagation ) ]
    pub fn set_stop_propagation(this: &IMouseEvent, value: &Function);
    pub type IScrollEvent;
    # [ wasm_bindgen ( method , getter , js_name = scrollTop ) ]
    pub fn scroll_top(this: &IScrollEvent) -> f64;
    # [ wasm_bindgen ( method , getter , js_name = scrollLeft ) ]
    pub fn scroll_left(this: &IScrollEvent) -> f64;
    # [ wasm_bindgen ( method , getter , js_name = scrollWidth ) ]
    pub fn scroll_width(this: &IScrollEvent) -> f64;
    # [ wasm_bindgen ( method , getter , js_name = scrollHeight ) ]
    pub fn scroll_height(this: &IScrollEvent) -> f64;
    # [ wasm_bindgen ( method , getter , js_name = scrollTopChanged ) ]
    pub fn scroll_top_changed(this: &IScrollEvent) -> bool;
    # [ wasm_bindgen ( method , getter , js_name = scrollLeftChanged ) ]
    pub fn scroll_left_changed(this: &IScrollEvent) -> bool;
    # [ wasm_bindgen ( method , getter , js_name = scrollWidthChanged ) ]
    pub fn scroll_width_changed(this: &IScrollEvent) -> bool;
    # [ wasm_bindgen ( method , getter , js_name = scrollHeightChanged ) ]
    pub fn scroll_height_changed(this: &IScrollEvent) -> bool;
    #[doc = "A position in the editor. This interface is suitable for serialization."]
    pub type IPosition;
    #[doc = "line number (starts at 1)"]
    # [ wasm_bindgen ( method , getter , js_name = lineNumber ) ]
    pub fn line_number(this: &IPosition) -> f64;
    #[doc = "column (the first character in a line is between column 1 and column 2)"]
    #[wasm_bindgen(method, getter)]
    pub fn column(this: &IPosition) -> f64;
    #[doc = "A position in the editor."]
    pub type Position;
    #[doc = "line number (starts at 1)"]
    # [ wasm_bindgen ( method , getter , js_name = lineNumber ) ]
    pub fn line_number(this: &Position) -> f64;
    #[doc = "column (the first character in a line is between column 1 and column 2)"]
    #[wasm_bindgen(method, getter)]
    pub fn column(this: &Position) -> f64;
    #[wasm_bindgen(constructor)]
    pub fn new_position(line_number: f64, column: f64) -> Position;
    #[doc = "Create a new position from this position."]
    #[wasm_bindgen(method)]
    pub fn with(this: &Position, new_line_number: Option<f64>, new_column: Option<f64>)
    -> Position;
    #[wasm_bindgen(method, setter)]
    pub fn set_with(this: &Position, value: &Function);
    #[doc = "Derive a new position from this position."]
    #[wasm_bindgen(method)]
    pub fn delta(
        this: &Position,
        delta_line_number: Option<f64>,
        delta_column: Option<f64>,
    ) -> Position;
    #[wasm_bindgen(method, setter)]
    pub fn set_delta(this: &Position, value: &Function);
    #[doc = "Test if this position equals other position"]
    #[wasm_bindgen(method)]
    pub fn equals(this: &Position, other: &IPosition) -> bool;
    #[wasm_bindgen(method, setter)]
    pub fn set_equals(this: &Position, value: &Function);
    #[doc = "Test if position `a` equals position `b`"]
    # [ wasm_bindgen ( method , js_name = equals ) ]
    pub fn equals2(this: &Position, a: &JsValue, b: &JsValue) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = equals ) ]
    pub fn set_equals2(this: &Position, value: &Function);
    #[doc = "Test if this position is before other position."]
    #[doc = "If the two positions are equal, the result will be false."]
    # [ wasm_bindgen ( method , js_name = isBefore ) ]
    pub fn is_before(this: &Position, other: &IPosition) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = isBefore ) ]
    pub fn set_is_before(this: &Position, value: &Function);
    #[doc = "Test if position `a` is before position `b`."]
    #[doc = "If the two positions are equal, the result will be false."]
    # [ wasm_bindgen ( method , js_name = isBefore ) ]
    pub fn is_before2(this: &Position, a: &IPosition, b: &IPosition) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = isBefore ) ]
    pub fn set_is_before2(this: &Position, value: &Function);
    #[doc = "Test if this position is before other position."]
    #[doc = "If the two positions are equal, the result will be true."]
    # [ wasm_bindgen ( method , js_name = isBeforeOrEqual ) ]
    pub fn is_before_or_equal(this: &Position, other: &IPosition) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = isBeforeOrEqual ) ]
    pub fn set_is_before_or_equal(this: &Position, value: &Function);
    #[doc = "Test if position `a` is before position `b`."]
    #[doc = "If the two positions are equal, the result will be true."]
    # [ wasm_bindgen ( method , js_name = isBeforeOrEqual ) ]
    pub fn is_before_or_equal2(this: &Position, a: &IPosition, b: &IPosition) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = isBeforeOrEqual ) ]
    pub fn set_is_before_or_equal2(this: &Position, value: &Function);
    #[doc = "A function that compares positions, useful for sorting"]
    #[wasm_bindgen(method)]
    pub fn compare(this: &Position, a: &IPosition, b: &IPosition) -> f64;
    #[wasm_bindgen(method, setter)]
    pub fn set_compare(this: &Position, value: &Function);
    #[doc = "Clone this position."]
    #[wasm_bindgen(method)]
    pub fn clone(this: &Position) -> Position;
    #[wasm_bindgen(method, setter)]
    pub fn set_clone(this: &Position, value: &Function);
    #[doc = "Convert to a human-readable representation."]
    # [ wasm_bindgen ( method , js_name = toString ) ]
    pub fn to_string(this: &Position) -> String;
    # [ wasm_bindgen ( method , setter , js_name = toString ) ]
    pub fn set_to_string(this: &Position, value: &Function);
    #[doc = "Create a `Position` from an `IPosition`."]
    #[wasm_bindgen(method)]
    pub fn lift(this: &Position, pos: &IPosition) -> Position;
    #[wasm_bindgen(method, setter)]
    pub fn set_lift(this: &Position, value: &Function);
    #[doc = "Test if `obj` is an `IPosition`."]
    # [ wasm_bindgen ( method , js_name = isIPosition ) ]
    pub fn is_i_position(this: &Position, obj: &JsValue) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = isIPosition ) ]
    pub fn set_is_i_position(this: &Position, value: &Function);
    #[doc = "A range in the editor. This interface is suitable for serialization."]
    pub type IRange;
    #[doc = "Line number on which the range starts (starts at 1)."]
    # [ wasm_bindgen ( method , getter , js_name = startLineNumber ) ]
    pub fn start_line_number(this: &IRange) -> f64;
    #[doc = "Column on which the range starts in line `startLineNumber` (starts at 1)."]
    # [ wasm_bindgen ( method , getter , js_name = startColumn ) ]
    pub fn start_column(this: &IRange) -> f64;
    #[doc = "Line number on which the range ends."]
    # [ wasm_bindgen ( method , getter , js_name = endLineNumber ) ]
    pub fn end_line_number(this: &IRange) -> f64;
    #[doc = "Column on which the range ends in line `endLineNumber`."]
    # [ wasm_bindgen ( method , getter , js_name = endColumn ) ]
    pub fn end_column(this: &IRange) -> f64;
    #[doc = "A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)"]
    pub type Range;
    #[doc = "Line number on which the range starts (starts at 1)."]
    # [ wasm_bindgen ( method , getter , js_name = startLineNumber ) ]
    pub fn start_line_number(this: &Range) -> f64;
    #[doc = "Column on which the range starts in line `startLineNumber` (starts at 1)."]
    # [ wasm_bindgen ( method , getter , js_name = startColumn ) ]
    pub fn start_column(this: &Range) -> f64;
    #[doc = "Line number on which the range ends."]
    # [ wasm_bindgen ( method , getter , js_name = endLineNumber ) ]
    pub fn end_line_number(this: &Range) -> f64;
    #[doc = "Column on which the range ends in line `endLineNumber`."]
    # [ wasm_bindgen ( method , getter , js_name = endColumn ) ]
    pub fn end_column(this: &Range) -> f64;
    #[wasm_bindgen(constructor)]
    pub fn new_range(
        start_line_number: f64,
        start_column: f64,
        end_line_number: f64,
        end_column: f64,
    ) -> Range;
    #[doc = "Test if this range is empty."]
    # [ wasm_bindgen ( method , js_name = isEmpty ) ]
    pub fn is_empty(this: &Range) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = isEmpty ) ]
    pub fn set_is_empty(this: &Range, value: &Function);
    #[doc = "Test if `range` is empty."]
    # [ wasm_bindgen ( method , js_name = isEmpty ) ]
    pub fn is_empty2(this: &Range, range: &IRange) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = isEmpty ) ]
    pub fn set_is_empty2(this: &Range, value: &Function);
    #[doc = "Test if position is in this range. If the position is at the edges, will return true."]
    # [ wasm_bindgen ( method , js_name = containsPosition ) ]
    pub fn contains_position(this: &Range, position: &IPosition) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = containsPosition ) ]
    pub fn set_contains_position(this: &Range, value: &Function);
    #[doc = "Test if `position` is in `range`. If the position is at the edges, will return true."]
    # [ wasm_bindgen ( method , js_name = containsPosition ) ]
    pub fn contains_position2(this: &Range, range: &IRange, position: &IPosition) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = containsPosition ) ]
    pub fn set_contains_position2(this: &Range, value: &Function);
    #[doc = "Test if range is in this range. If the range is equal to this range, will return true."]
    # [ wasm_bindgen ( method , js_name = containsRange ) ]
    pub fn contains_range(this: &Range, range: &IRange) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = containsRange ) ]
    pub fn set_contains_range(this: &Range, value: &Function);
    #[doc = "Test if `otherRange` is in `range`. If the ranges are equal, will return true."]
    # [ wasm_bindgen ( method , js_name = containsRange ) ]
    pub fn contains_range2(this: &Range, range: &IRange, other_range: &IRange) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = containsRange ) ]
    pub fn set_contains_range2(this: &Range, value: &Function);
    #[doc = "Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true."]
    # [ wasm_bindgen ( method , js_name = strictContainsRange ) ]
    pub fn strict_contains_range(this: &Range, range: &IRange) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = strictContainsRange ) ]
    pub fn set_strict_contains_range(this: &Range, value: &Function);
    #[doc = "Test if `otherRange` is strinctly in `range` (must start after, and end before). If the ranges are equal, will return false."]
    # [ wasm_bindgen ( method , js_name = strictContainsRange ) ]
    pub fn strict_contains_range2(this: &Range, range: &IRange, other_range: &IRange) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = strictContainsRange ) ]
    pub fn set_strict_contains_range2(this: &Range, value: &Function);
    #[doc = "A reunion of the two ranges."]
    #[doc = "The smallest position will be used as the start point, and the largest one as the end point."]
    # [ wasm_bindgen ( method , js_name = plusRange ) ]
    pub fn plus_range(this: &Range, range: &IRange) -> Range;
    # [ wasm_bindgen ( method , setter , js_name = plusRange ) ]
    pub fn set_plus_range(this: &Range, value: &Function);
    #[doc = "A reunion of the two ranges."]
    #[doc = "The smallest position will be used as the start point, and the largest one as the end point."]
    # [ wasm_bindgen ( method , js_name = plusRange ) ]
    pub fn plus_range2(this: &Range, a: &IRange, b: &IRange) -> Range;
    # [ wasm_bindgen ( method , setter , js_name = plusRange ) ]
    pub fn set_plus_range2(this: &Range, value: &Function);
    #[doc = "A intersection of the two ranges."]
    # [ wasm_bindgen ( method , js_name = intersectRanges ) ]
    pub fn intersect_ranges(this: &Range, range: &IRange) -> JsValue;
    # [ wasm_bindgen ( method , setter , js_name = intersectRanges ) ]
    pub fn set_intersect_ranges(this: &Range, value: &Function);
    #[doc = "A intersection of the two ranges."]
    # [ wasm_bindgen ( method , js_name = intersectRanges ) ]
    pub fn intersect_ranges2(this: &Range, a: &IRange, b: &IRange) -> JsValue;
    # [ wasm_bindgen ( method , setter , js_name = intersectRanges ) ]
    pub fn set_intersect_ranges2(this: &Range, value: &Function);
    #[doc = "Test if this range equals other."]
    # [ wasm_bindgen ( method , js_name = equalsRange ) ]
    pub fn equals_range(this: &Range, other: &JsValue) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = equalsRange ) ]
    pub fn set_equals_range(this: &Range, value: &Function);
    #[doc = "Test if range `a` equals `b`."]
    # [ wasm_bindgen ( method , js_name = equalsRange ) ]
    pub fn equals_range2(this: &Range, a: &JsValue, b: &JsValue) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = equalsRange ) ]
    pub fn set_equals_range2(this: &Range, value: &Function);
    #[doc = "Return the end position (which will be after or equal to the start position)"]
    # [ wasm_bindgen ( method , js_name = getEndPosition ) ]
    pub fn get_end_position(this: &Range) -> Position;
    # [ wasm_bindgen ( method , setter , js_name = getEndPosition ) ]
    pub fn set_get_end_position(this: &Range, value: &Function);
    #[doc = "Return the start position (which will be before or equal to the end position)"]
    # [ wasm_bindgen ( method , js_name = getStartPosition ) ]
    pub fn get_start_position(this: &Range) -> Position;
    # [ wasm_bindgen ( method , setter , js_name = getStartPosition ) ]
    pub fn set_get_start_position(this: &Range, value: &Function);
    #[doc = "Transform to a user presentable string representation."]
    # [ wasm_bindgen ( method , js_name = toString ) ]
    pub fn to_string(this: &Range) -> String;
    # [ wasm_bindgen ( method , setter , js_name = toString ) ]
    pub fn set_to_string(this: &Range, value: &Function);
    #[doc = "Create a new range using this range's start position, and using endLineNumber and endColumn as the end position."]
    # [ wasm_bindgen ( method , js_name = setEndPosition ) ]
    pub fn set_end_position(this: &Range, end_line_number: f64, end_column: f64) -> Range;
    # [ wasm_bindgen ( method , setter , js_name = setEndPosition ) ]
    pub fn set_set_end_position(this: &Range, value: &Function);
    #[doc = "Create a new range using this range's end position, and using startLineNumber and startColumn as the start position."]
    # [ wasm_bindgen ( method , js_name = setStartPosition ) ]
    pub fn set_start_position(this: &Range, start_line_number: f64, start_column: f64) -> Range;
    # [ wasm_bindgen ( method , setter , js_name = setStartPosition ) ]
    pub fn set_set_start_position(this: &Range, value: &Function);
    #[doc = "Create a new empty range using this range's start position."]
    # [ wasm_bindgen ( method , js_name = collapseToStart ) ]
    pub fn collapse_to_start(this: &Range) -> Range;
    # [ wasm_bindgen ( method , setter , js_name = collapseToStart ) ]
    pub fn set_collapse_to_start(this: &Range, value: &Function);
    #[doc = "Create a new empty range using this range's start position."]
    # [ wasm_bindgen ( method , js_name = collapseToStart ) ]
    pub fn collapse_to_start2(this: &Range, range: &IRange) -> Range;
    # [ wasm_bindgen ( method , setter , js_name = collapseToStart ) ]
    pub fn set_collapse_to_start2(this: &Range, value: &Function);
    # [ wasm_bindgen ( method , js_name = fromPositions ) ]
    pub fn from_positions(this: &Range, start: &IPosition, end: Option<&IPosition>) -> Range;
    # [ wasm_bindgen ( method , setter , js_name = fromPositions ) ]
    pub fn set_from_positions(this: &Range, value: &Function);
    #[doc = "Create a `Range` from an `IRange`."]
    #[wasm_bindgen(method)]
    pub fn lift(this: &Range, range: &JsValue);
    #[wasm_bindgen(method, setter)]
    pub fn set_lift(this: &Range, value: &Function);
    #[doc = "Create a `Range` from an `IRange`."]
    # [ wasm_bindgen ( method , js_name = lift ) ]
    pub fn lift2(this: &Range, range: &IRange) -> Range;
    # [ wasm_bindgen ( method , setter , js_name = lift ) ]
    pub fn set_lift2(this: &Range, value: &Function);
    #[doc = "Test if `obj` is an `IRange`."]
    # [ wasm_bindgen ( method , js_name = isIRange ) ]
    pub fn is_i_range(this: &Range, obj: &JsValue) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = isIRange ) ]
    pub fn set_is_i_range(this: &Range, value: &Function);
    #[doc = "Test if the two ranges are touching in any way."]
    # [ wasm_bindgen ( method , js_name = areIntersectingOrTouching ) ]
    pub fn are_intersecting_or_touching(this: &Range, a: &IRange, b: &IRange) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = areIntersectingOrTouching ) ]
    pub fn set_are_intersecting_or_touching(this: &Range, value: &Function);
    #[doc = "Test if the two ranges are intersecting. If the ranges are touching it returns true."]
    # [ wasm_bindgen ( method , js_name = areIntersecting ) ]
    pub fn are_intersecting(this: &Range, a: &IRange, b: &IRange) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = areIntersecting ) ]
    pub fn set_are_intersecting(this: &Range, value: &Function);
    #[doc = "A function that compares ranges, useful for sorting ranges"]
    #[doc = "It will first compare ranges on the startPosition and then on the endPosition"]
    # [ wasm_bindgen ( method , js_name = compareRangesUsingStarts ) ]
    pub fn compare_ranges_using_starts(this: &Range, a: &JsValue, b: &JsValue) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = compareRangesUsingStarts ) ]
    pub fn set_compare_ranges_using_starts(this: &Range, value: &Function);
    #[doc = "A function that compares ranges, useful for sorting ranges"]
    #[doc = "It will first compare ranges on the endPosition and then on the startPosition"]
    # [ wasm_bindgen ( method , js_name = compareRangesUsingEnds ) ]
    pub fn compare_ranges_using_ends(this: &Range, a: &IRange, b: &IRange) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = compareRangesUsingEnds ) ]
    pub fn set_compare_ranges_using_ends(this: &Range, value: &Function);
    #[doc = "Test if the range spans multiple lines."]
    # [ wasm_bindgen ( method , js_name = spansMultipleLines ) ]
    pub fn spans_multiple_lines(this: &Range, range: &IRange) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = spansMultipleLines ) ]
    pub fn set_spans_multiple_lines(this: &Range, value: &Function);
    #[doc = "A selection in the editor."]
    #[doc = "The selection is a range that has an orientation."]
    pub type ISelection;
    #[doc = "The line number on which the selection has started."]
    # [ wasm_bindgen ( method , getter , js_name = selectionStartLineNumber ) ]
    pub fn selection_start_line_number(this: &ISelection) -> f64;
    #[doc = "The column on `selectionStartLineNumber` where the selection has started."]
    # [ wasm_bindgen ( method , getter , js_name = selectionStartColumn ) ]
    pub fn selection_start_column(this: &ISelection) -> f64;
    #[doc = "The line number on which the selection has ended."]
    # [ wasm_bindgen ( method , getter , js_name = positionLineNumber ) ]
    pub fn position_line_number(this: &ISelection) -> f64;
    #[doc = "The column on `positionLineNumber` where the selection has ended."]
    # [ wasm_bindgen ( method , getter , js_name = positionColumn ) ]
    pub fn position_column(this: &ISelection) -> f64;
    #[doc = "A selection in the editor."]
    #[doc = "The selection is a range that has an orientation."]
    pub type Selection;
    #[doc = "The line number on which the selection has started."]
    # [ wasm_bindgen ( method , getter , js_name = selectionStartLineNumber ) ]
    pub fn selection_start_line_number(this: &Selection) -> f64;
    #[doc = "The column on `selectionStartLineNumber` where the selection has started."]
    # [ wasm_bindgen ( method , getter , js_name = selectionStartColumn ) ]
    pub fn selection_start_column(this: &Selection) -> f64;
    #[doc = "The line number on which the selection has ended."]
    # [ wasm_bindgen ( method , getter , js_name = positionLineNumber ) ]
    pub fn position_line_number(this: &Selection) -> f64;
    #[doc = "The column on `positionLineNumber` where the selection has ended."]
    # [ wasm_bindgen ( method , getter , js_name = positionColumn ) ]
    pub fn position_column(this: &Selection) -> f64;
    #[wasm_bindgen(constructor)]
    pub fn new_selection(
        selection_start_line_number: f64,
        selection_start_column: f64,
        position_line_number: f64,
        position_column: f64,
    ) -> Selection;
    #[doc = "Transform to a human-readable representation."]
    # [ wasm_bindgen ( method , js_name = toString ) ]
    pub fn to_string(this: &Selection) -> String;
    # [ wasm_bindgen ( method , setter , js_name = toString ) ]
    pub fn set_to_string(this: &Selection, value: &Function);
    #[doc = "Test if equals other selection."]
    # [ wasm_bindgen ( method , js_name = equalsSelection ) ]
    pub fn equals_selection(this: &Selection, other: &ISelection) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = equalsSelection ) ]
    pub fn set_equals_selection(this: &Selection, value: &Function);
    #[doc = "Test if the two selections are equal."]
    # [ wasm_bindgen ( method , js_name = selectionsEqual ) ]
    pub fn selections_equal(this: &Selection, a: &ISelection, b: &ISelection) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = selectionsEqual ) ]
    pub fn set_selections_equal(this: &Selection, value: &Function);
    #[doc = "Get directions (LTR or RTL)."]
    # [ wasm_bindgen ( method , js_name = getDirection ) ]
    pub fn get_direction(this: &Selection) -> SelectionDirection;
    # [ wasm_bindgen ( method , setter , js_name = getDirection ) ]
    pub fn set_get_direction(this: &Selection, value: &Function);
    #[doc = "Create a new selection with a different `positionLineNumber` and `positionColumn`."]
    # [ wasm_bindgen ( method , js_name = setEndPosition ) ]
    pub fn set_end_position(this: &Selection, end_line_number: f64, end_column: f64) -> Selection;
    # [ wasm_bindgen ( method , setter , js_name = setEndPosition ) ]
    pub fn set_set_end_position(this: &Selection, value: &Function);
    #[doc = "Get the position at `positionLineNumber` and `positionColumn`."]
    # [ wasm_bindgen ( method , js_name = getPosition ) ]
    pub fn get_position(this: &Selection) -> Position;
    # [ wasm_bindgen ( method , setter , js_name = getPosition ) ]
    pub fn set_get_position(this: &Selection, value: &Function);
    #[doc = "Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`."]
    # [ wasm_bindgen ( method , js_name = setStartPosition ) ]
    pub fn set_start_position(
        this: &Selection,
        start_line_number: f64,
        start_column: f64,
    ) -> Selection;
    # [ wasm_bindgen ( method , setter , js_name = setStartPosition ) ]
    pub fn set_set_start_position(this: &Selection, value: &Function);
    #[doc = "Create a `Selection` from one or two positions"]
    # [ wasm_bindgen ( method , js_name = fromPositions ) ]
    pub fn from_positions(
        this: &Selection,
        start: &IPosition,
        end: Option<&IPosition>,
    ) -> Selection;
    # [ wasm_bindgen ( method , setter , js_name = fromPositions ) ]
    pub fn set_from_positions(this: &Selection, value: &Function);
    #[doc = "Create a `Selection` from an `ISelection`."]
    # [ wasm_bindgen ( method , js_name = liftSelection ) ]
    pub fn lift_selection(this: &Selection, sel: &ISelection) -> Selection;
    # [ wasm_bindgen ( method , setter , js_name = liftSelection ) ]
    pub fn set_lift_selection(this: &Selection, value: &Function);
    #[doc = "`a` equals `b`."]
    # [ wasm_bindgen ( method , js_name = selectionsArrEqual ) ]
    pub fn selections_arr_equal(this: &Selection, a: &Array, b: &Array) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = selectionsArrEqual ) ]
    pub fn set_selections_arr_equal(this: &Selection, value: &Function);
    #[doc = "Test if `obj` is an `ISelection`."]
    # [ wasm_bindgen ( method , js_name = isISelection ) ]
    pub fn is_i_selection(this: &Selection, obj: &JsValue) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = isISelection ) ]
    pub fn set_is_i_selection(this: &Selection, value: &Function);
    #[doc = "Create with a direction."]
    # [ wasm_bindgen ( method , js_name = createWithDirection ) ]
    pub fn create_with_direction(
        this: &Selection,
        start_line_number: f64,
        start_column: f64,
        end_line_number: f64,
        end_column: f64,
        direction: SelectionDirectionRef,
    ) -> Selection;
    # [ wasm_bindgen ( method , setter , js_name = createWithDirection ) ]
    pub fn set_create_with_direction(this: &Selection, value: &Function);
    pub type Token;
    #[wasm_bindgen(method, getter)]
    pub fn offset(this: &Token) -> f64;
    # [ wasm_bindgen ( method , getter , js_name = type ) ]
    pub fn type_(this: &Token) -> String;
    #[wasm_bindgen(method, getter)]
    pub fn language(this: &Token) -> String;
    #[wasm_bindgen(constructor)]
    pub fn new_token(offset: f64, type_: &str, language: &str) -> Token;
    # [ wasm_bindgen ( method , js_name = toString ) ]
    pub fn to_string(this: &Token) -> String;
    # [ wasm_bindgen ( method , setter , js_name = toString ) ]
    pub fn set_to_string(this: &Token, value: &Function);
}
