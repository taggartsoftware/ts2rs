// generated by ts2rs 0.1.2
// https://ts2rs.ctaggart.com/

#[wasm_bindgen(module = "monaco")]
extern "C" {
    pub type T; // TODO
    pub type Thenable;
    pub type Environment;
    # [ wasm_bindgen ( method , getter , js_name = baseUrl ) ]
    pub fn base_url(this: &Environment) -> Option<String>;
    # [ wasm_bindgen ( method , setter , js_name = baseUrl ) ]
    pub fn set_base_url(this: &Environment, value: Option<&str>);
    # [ wasm_bindgen ( method , js_name = getWorker ) ]
    pub fn get_worker(this: &Environment, worker_id: &str, label: &str) -> Worker;
    # [ wasm_bindgen ( method , setter , js_name = getWorker ) ]
    pub fn set_get_worker(this: &Environment, value: Option<&Function>);
    # [ wasm_bindgen ( method , js_name = getWorkerUrl ) ]
    pub fn get_worker_url(this: &Environment, worker_id: &str, label: &str) -> String;
    # [ wasm_bindgen ( method , setter , js_name = getWorkerUrl ) ]
    pub fn set_get_worker_url(this: &Environment, value: Option<&Function>);
    pub type IDisposable;
    #[wasm_bindgen(method)]
    pub fn dispose(this: &IDisposable);
    #[wasm_bindgen(method, setter)]
    pub fn set_dispose(this: &IDisposable, value: &Function);
    pub type IEvent;
    #[doc = "A helper that allows to emit and listen to typed events"]
    pub type Emitter;
    #[wasm_bindgen(constructor)]
    pub fn new_emitter() -> Emitter;
    #[wasm_bindgen(method, getter)]
    pub fn event(this: &Emitter) -> IEvent;
    #[wasm_bindgen(method)]
    pub fn fire(this: &Emitter, event: &T);
    #[wasm_bindgen(method, setter)]
    pub fn set_fire(this: &Emitter, value: &Function);
    #[wasm_bindgen(method)]
    pub fn dispose(this: &Emitter);
    #[wasm_bindgen(method, setter)]
    pub fn set_dispose(this: &Emitter, value: &Function);
    pub type CancellationTokenSource;
    #[wasm_bindgen(constructor)]
    pub fn new_cancellation_token_source(
        parent: Option<&CancellationToken>,
    ) -> CancellationTokenSource;
    #[wasm_bindgen(method)]
    pub fn cancel(this: &CancellationTokenSource);
    #[wasm_bindgen(method, setter)]
    pub fn set_cancel(this: &CancellationTokenSource, value: &Function);
    #[wasm_bindgen(method)]
    pub fn dispose(this: &CancellationTokenSource, cancel: Option<bool>);
    #[wasm_bindgen(method, setter)]
    pub fn set_dispose(this: &CancellationTokenSource, value: &Function);
    pub type CancellationToken;
    # [ wasm_bindgen ( method , getter , js_name = isCancellationRequested ) ]
    pub fn is_cancellation_requested(this: &CancellationToken) -> bool;
    # [ wasm_bindgen ( method , getter , js_name = onCancellationRequested ) ]
    pub fn on_cancellation_requested(this: &CancellationToken) -> IEvent;
    #[doc = "Uniform Resource Identifier (Uri) http://tools.ietf.org/html/rfc3986."]
    #[doc = "This class is a simple parser which creates the basic component parts"]
    #[doc = "(http://tools.ietf.org/html/rfc3986#section-3) with minimal validation"]
    #[doc = "and encoding."]
    #[doc = ""]
    #[doc = "       foo://example.com:8042/over/there?name=ferret#nose"]
    #[doc = "       \\_/   \\______________/\\_________/ \\_________/ \\__/"]
    #[doc = "        |           |            |            |        |"]
    #[doc = "     scheme     authority       path        query   fragment"]
    #[doc = "        |   _____________________|__"]
    #[doc = "       / \\ /                        \\"]
    #[doc = "       urn:example:animal:ferret:nose"]
    pub type Uri;
    # [ wasm_bindgen ( method , js_name = isUri ) ]
    pub fn is_uri(this: &Uri, thing: &JsValue) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = isUri ) ]
    pub fn set_is_uri(this: &Uri, value: &Function);
    #[wasm_bindgen(method, getter)]
    pub fn scheme(this: &Uri) -> String;
    #[wasm_bindgen(method, getter)]
    pub fn authority(this: &Uri) -> String;
    #[wasm_bindgen(method, getter)]
    pub fn path(this: &Uri) -> String;
    #[wasm_bindgen(method, getter)]
    pub fn query(this: &Uri) -> String;
    #[wasm_bindgen(method, getter)]
    pub fn fragment(this: &Uri) -> String;
    #[wasm_bindgen(method)]
    pub fn with(this: &Uri, change: &JsValue) -> Uri;
    #[wasm_bindgen(method, setter)]
    pub fn set_with(this: &Uri, value: &Function);
    #[wasm_bindgen(method)]
    pub fn parse(this: &Uri, value: &str, strict: Option<bool>) -> Uri;
    #[wasm_bindgen(method, setter)]
    pub fn set_parse(this: &Uri, value: &Function);
    #[wasm_bindgen(method)]
    pub fn file(this: &Uri, path: &str) -> Uri;
    #[wasm_bindgen(method, setter)]
    pub fn set_file(this: &Uri, value: &Function);
    #[wasm_bindgen(method)]
    pub fn from(this: &Uri, components: &JsValue) -> Uri;
    #[wasm_bindgen(method, setter)]
    pub fn set_from(this: &Uri, value: &Function);
    # [ wasm_bindgen ( method , js_name = toString ) ]
    pub fn to_string(this: &Uri, skip_encoding: Option<bool>) -> String;
    # [ wasm_bindgen ( method , setter , js_name = toString ) ]
    pub fn set_to_string(this: &Uri, value: &Function);
    # [ wasm_bindgen ( method , js_name = toJSON ) ]
    pub fn to_json(this: &Uri) -> UriComponents;
    # [ wasm_bindgen ( method , setter , js_name = toJSON ) ]
    pub fn set_to_json(this: &Uri, value: &Function);
    #[wasm_bindgen(method)]
    pub fn revive(this: &Uri, data: &JsValue) -> Uri;
    #[wasm_bindgen(method, setter)]
    pub fn set_revive(this: &Uri, value: &Function);
    # [ wasm_bindgen ( method , js_name = revive ) ]
    pub fn revive2(this: &Uri, data: &JsValue) -> Option<Uri>;
    # [ wasm_bindgen ( method , setter , js_name = revive ) ]
    pub fn set_revive2(this: &Uri, value: &Function);
    # [ wasm_bindgen ( method , js_name = revive ) ]
    pub fn revive3(this: &Uri, data: &JsValue) -> JsValue;
    # [ wasm_bindgen ( method , setter , js_name = revive ) ]
    pub fn set_revive3(this: &Uri, value: &Function);
    # [ wasm_bindgen ( method , js_name = revive ) ]
    pub fn revive4(this: &Uri, data: &JsValue) -> JsValue;
    # [ wasm_bindgen ( method , setter , js_name = revive ) ]
    pub fn set_revive4(this: &Uri, value: &Function);
    pub type UriComponents;
    #[wasm_bindgen(method, getter)]
    pub fn scheme(this: &UriComponents) -> String;
    #[wasm_bindgen(method, setter)]
    pub fn set_scheme(this: &UriComponents, value: &str);
    #[wasm_bindgen(method, getter)]
    pub fn authority(this: &UriComponents) -> String;
    #[wasm_bindgen(method, setter)]
    pub fn set_authority(this: &UriComponents, value: &str);
    #[wasm_bindgen(method, getter)]
    pub fn path(this: &UriComponents) -> String;
    #[wasm_bindgen(method, setter)]
    pub fn set_path(this: &UriComponents, value: &str);
    #[wasm_bindgen(method, getter)]
    pub fn query(this: &UriComponents) -> String;
    #[wasm_bindgen(method, setter)]
    pub fn set_query(this: &UriComponents, value: &str);
    #[wasm_bindgen(method, getter)]
    pub fn fragment(this: &UriComponents) -> String;
    #[wasm_bindgen(method, setter)]
    pub fn set_fragment(this: &UriComponents, value: &str);
    pub type KeyMod;
    # [ wasm_bindgen ( method , getter , js_name = CtrlCmd ) ]
    pub fn ctrl_cmd(this: &KeyMod) -> f64;
    # [ wasm_bindgen ( method , getter , js_name = Shift ) ]
    pub fn shift(this: &KeyMod) -> f64;
    # [ wasm_bindgen ( method , getter , js_name = Alt ) ]
    pub fn alt(this: &KeyMod) -> f64;
    # [ wasm_bindgen ( method , getter , js_name = WinCtrl ) ]
    pub fn win_ctrl(this: &KeyMod) -> f64;
    #[wasm_bindgen(method)]
    pub fn chord(this: &KeyMod, first_part: f64, second_part: f64) -> f64;
    #[wasm_bindgen(method, setter)]
    pub fn set_chord(this: &KeyMod, value: &Function);
    pub type IMarkdownString;
    #[wasm_bindgen(method, getter)]
    pub fn value(this: &IMarkdownString) -> String;
    # [ wasm_bindgen ( method , getter , js_name = isTrusted ) ]
    pub fn is_trusted(this: &IMarkdownString) -> Option<bool>;
    # [ wasm_bindgen ( method , getter , js_name = supportThemeIcons ) ]
    pub fn support_theme_icons(this: &IMarkdownString) -> Option<bool>;
    #[wasm_bindgen(method, getter)]
    pub fn uris(this: &IMarkdownString) -> JsValue;
    #[wasm_bindgen(method, setter)]
    pub fn set_uris(this: &IMarkdownString, value: &JsValue);
    pub type IKeyboardEvent;
    # [ wasm_bindgen ( method , getter , js_name = _standardKeyboardEventBrand ) ]
    pub fn standard_keyboard_event_brand(this: &IKeyboardEvent) -> JsValue;
    # [ wasm_bindgen ( method , getter , js_name = browserEvent ) ]
    pub fn browser_event(this: &IKeyboardEvent) -> KeyboardEvent;
    #[wasm_bindgen(method, getter)]
    pub fn target(this: &IKeyboardEvent) -> HTMLElement;
    # [ wasm_bindgen ( method , getter , js_name = ctrlKey ) ]
    pub fn ctrl_key(this: &IKeyboardEvent) -> bool;
    # [ wasm_bindgen ( method , getter , js_name = shiftKey ) ]
    pub fn shift_key(this: &IKeyboardEvent) -> bool;
    # [ wasm_bindgen ( method , getter , js_name = altKey ) ]
    pub fn alt_key(this: &IKeyboardEvent) -> bool;
    # [ wasm_bindgen ( method , getter , js_name = metaKey ) ]
    pub fn meta_key(this: &IKeyboardEvent) -> bool;
    # [ wasm_bindgen ( method , getter , js_name = keyCode ) ]
    pub fn key_code(this: &IKeyboardEvent) -> KeyCode;
    #[wasm_bindgen(method, getter)]
    pub fn code(this: &IKeyboardEvent) -> String;
    #[wasm_bindgen(method)]
    pub fn equals(this: &IKeyboardEvent, keybinding: f64) -> bool;
    #[wasm_bindgen(method, setter)]
    pub fn set_equals(this: &IKeyboardEvent, value: &Function);
    # [ wasm_bindgen ( method , js_name = preventDefault ) ]
    pub fn prevent_default(this: &IKeyboardEvent);
    # [ wasm_bindgen ( method , setter , js_name = preventDefault ) ]
    pub fn set_prevent_default(this: &IKeyboardEvent, value: &Function);
    # [ wasm_bindgen ( method , js_name = stopPropagation ) ]
    pub fn stop_propagation(this: &IKeyboardEvent);
    # [ wasm_bindgen ( method , setter , js_name = stopPropagation ) ]
    pub fn set_stop_propagation(this: &IKeyboardEvent, value: &Function);
    pub type IMouseEvent;
    # [ wasm_bindgen ( method , getter , js_name = browserEvent ) ]
    pub fn browser_event(this: &IMouseEvent) -> MouseEvent;
    # [ wasm_bindgen ( method , getter , js_name = leftButton ) ]
    pub fn left_button(this: &IMouseEvent) -> bool;
    # [ wasm_bindgen ( method , getter , js_name = middleButton ) ]
    pub fn middle_button(this: &IMouseEvent) -> bool;
    # [ wasm_bindgen ( method , getter , js_name = rightButton ) ]
    pub fn right_button(this: &IMouseEvent) -> bool;
    #[wasm_bindgen(method, getter)]
    pub fn buttons(this: &IMouseEvent) -> f64;
    #[wasm_bindgen(method, getter)]
    pub fn target(this: &IMouseEvent) -> HTMLElement;
    #[wasm_bindgen(method, getter)]
    pub fn detail(this: &IMouseEvent) -> f64;
    #[wasm_bindgen(method, getter)]
    pub fn posx(this: &IMouseEvent) -> f64;
    #[wasm_bindgen(method, getter)]
    pub fn posy(this: &IMouseEvent) -> f64;
    # [ wasm_bindgen ( method , getter , js_name = ctrlKey ) ]
    pub fn ctrl_key(this: &IMouseEvent) -> bool;
    # [ wasm_bindgen ( method , getter , js_name = shiftKey ) ]
    pub fn shift_key(this: &IMouseEvent) -> bool;
    # [ wasm_bindgen ( method , getter , js_name = altKey ) ]
    pub fn alt_key(this: &IMouseEvent) -> bool;
    # [ wasm_bindgen ( method , getter , js_name = metaKey ) ]
    pub fn meta_key(this: &IMouseEvent) -> bool;
    #[wasm_bindgen(method, getter)]
    pub fn timestamp(this: &IMouseEvent) -> f64;
    # [ wasm_bindgen ( method , js_name = preventDefault ) ]
    pub fn prevent_default(this: &IMouseEvent);
    # [ wasm_bindgen ( method , setter , js_name = preventDefault ) ]
    pub fn set_prevent_default(this: &IMouseEvent, value: &Function);
    # [ wasm_bindgen ( method , js_name = stopPropagation ) ]
    pub fn stop_propagation(this: &IMouseEvent);
    # [ wasm_bindgen ( method , setter , js_name = stopPropagation ) ]
    pub fn set_stop_propagation(this: &IMouseEvent, value: &Function);
    pub type IScrollEvent;
    # [ wasm_bindgen ( method , getter , js_name = scrollTop ) ]
    pub fn scroll_top(this: &IScrollEvent) -> f64;
    # [ wasm_bindgen ( method , getter , js_name = scrollLeft ) ]
    pub fn scroll_left(this: &IScrollEvent) -> f64;
    # [ wasm_bindgen ( method , getter , js_name = scrollWidth ) ]
    pub fn scroll_width(this: &IScrollEvent) -> f64;
    # [ wasm_bindgen ( method , getter , js_name = scrollHeight ) ]
    pub fn scroll_height(this: &IScrollEvent) -> f64;
    # [ wasm_bindgen ( method , getter , js_name = scrollTopChanged ) ]
    pub fn scroll_top_changed(this: &IScrollEvent) -> bool;
    # [ wasm_bindgen ( method , getter , js_name = scrollLeftChanged ) ]
    pub fn scroll_left_changed(this: &IScrollEvent) -> bool;
    # [ wasm_bindgen ( method , getter , js_name = scrollWidthChanged ) ]
    pub fn scroll_width_changed(this: &IScrollEvent) -> bool;
    # [ wasm_bindgen ( method , getter , js_name = scrollHeightChanged ) ]
    pub fn scroll_height_changed(this: &IScrollEvent) -> bool;
    #[doc = "A position in the editor. This interface is suitable for serialization."]
    pub type IPosition;
    # [ wasm_bindgen ( method , getter , js_name = lineNumber ) ]
    pub fn line_number(this: &IPosition) -> f64;
    #[wasm_bindgen(method, getter)]
    pub fn column(this: &IPosition) -> f64;
    #[doc = "A position in the editor."]
    pub type Position;
    # [ wasm_bindgen ( method , getter , js_name = lineNumber ) ]
    pub fn line_number(this: &Position) -> f64;
    #[wasm_bindgen(method, getter)]
    pub fn column(this: &Position) -> f64;
    #[wasm_bindgen(constructor)]
    pub fn new_position(line_number: f64, column: f64) -> Position;
    #[wasm_bindgen(method)]
    pub fn with(this: &Position, new_line_number: Option<f64>, new_column: Option<f64>)
    -> Position;
    #[wasm_bindgen(method, setter)]
    pub fn set_with(this: &Position, value: &Function);
    #[wasm_bindgen(method)]
    pub fn delta(
        this: &Position,
        delta_line_number: Option<f64>,
        delta_column: Option<f64>,
    ) -> Position;
    #[wasm_bindgen(method, setter)]
    pub fn set_delta(this: &Position, value: &Function);
    #[wasm_bindgen(method)]
    pub fn equals(this: &Position, other: &IPosition) -> bool;
    #[wasm_bindgen(method, setter)]
    pub fn set_equals(this: &Position, value: &Function);
    # [ wasm_bindgen ( method , js_name = equals ) ]
    pub fn equals2(this: &Position, a: &JsValue, b: &JsValue) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = equals ) ]
    pub fn set_equals2(this: &Position, value: &Function);
    # [ wasm_bindgen ( method , js_name = isBefore ) ]
    pub fn is_before(this: &Position, other: &IPosition) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = isBefore ) ]
    pub fn set_is_before(this: &Position, value: &Function);
    # [ wasm_bindgen ( method , js_name = isBefore ) ]
    pub fn is_before2(this: &Position, a: &IPosition, b: &IPosition) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = isBefore ) ]
    pub fn set_is_before2(this: &Position, value: &Function);
    # [ wasm_bindgen ( method , js_name = isBeforeOrEqual ) ]
    pub fn is_before_or_equal(this: &Position, other: &IPosition) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = isBeforeOrEqual ) ]
    pub fn set_is_before_or_equal(this: &Position, value: &Function);
    # [ wasm_bindgen ( method , js_name = isBeforeOrEqual ) ]
    pub fn is_before_or_equal2(this: &Position, a: &IPosition, b: &IPosition) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = isBeforeOrEqual ) ]
    pub fn set_is_before_or_equal2(this: &Position, value: &Function);
    #[wasm_bindgen(method)]
    pub fn compare(this: &Position, a: &IPosition, b: &IPosition) -> f64;
    #[wasm_bindgen(method, setter)]
    pub fn set_compare(this: &Position, value: &Function);
    #[wasm_bindgen(method)]
    pub fn clone(this: &Position) -> Position;
    #[wasm_bindgen(method, setter)]
    pub fn set_clone(this: &Position, value: &Function);
    # [ wasm_bindgen ( method , js_name = toString ) ]
    pub fn to_string(this: &Position) -> String;
    # [ wasm_bindgen ( method , setter , js_name = toString ) ]
    pub fn set_to_string(this: &Position, value: &Function);
    #[wasm_bindgen(method)]
    pub fn lift(this: &Position, pos: &IPosition) -> Position;
    #[wasm_bindgen(method, setter)]
    pub fn set_lift(this: &Position, value: &Function);
    # [ wasm_bindgen ( method , js_name = isIPosition ) ]
    pub fn is_i_position(this: &Position, obj: &JsValue) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = isIPosition ) ]
    pub fn set_is_i_position(this: &Position, value: &Function);
    #[doc = "A range in the editor. This interface is suitable for serialization."]
    pub type IRange;
    # [ wasm_bindgen ( method , getter , js_name = startLineNumber ) ]
    pub fn start_line_number(this: &IRange) -> f64;
    # [ wasm_bindgen ( method , getter , js_name = startColumn ) ]
    pub fn start_column(this: &IRange) -> f64;
    # [ wasm_bindgen ( method , getter , js_name = endLineNumber ) ]
    pub fn end_line_number(this: &IRange) -> f64;
    # [ wasm_bindgen ( method , getter , js_name = endColumn ) ]
    pub fn end_column(this: &IRange) -> f64;
    #[doc = "A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)"]
    pub type Range;
    # [ wasm_bindgen ( method , getter , js_name = startLineNumber ) ]
    pub fn start_line_number(this: &Range) -> f64;
    # [ wasm_bindgen ( method , getter , js_name = startColumn ) ]
    pub fn start_column(this: &Range) -> f64;
    # [ wasm_bindgen ( method , getter , js_name = endLineNumber ) ]
    pub fn end_line_number(this: &Range) -> f64;
    # [ wasm_bindgen ( method , getter , js_name = endColumn ) ]
    pub fn end_column(this: &Range) -> f64;
    #[wasm_bindgen(constructor)]
    pub fn new_range(
        start_line_number: f64,
        start_column: f64,
        end_line_number: f64,
        end_column: f64,
    ) -> Range;
    # [ wasm_bindgen ( method , js_name = isEmpty ) ]
    pub fn is_empty(this: &Range) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = isEmpty ) ]
    pub fn set_is_empty(this: &Range, value: &Function);
    # [ wasm_bindgen ( method , js_name = isEmpty ) ]
    pub fn is_empty2(this: &Range, range: &IRange) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = isEmpty ) ]
    pub fn set_is_empty2(this: &Range, value: &Function);
    # [ wasm_bindgen ( method , js_name = containsPosition ) ]
    pub fn contains_position(this: &Range, position: &IPosition) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = containsPosition ) ]
    pub fn set_contains_position(this: &Range, value: &Function);
    # [ wasm_bindgen ( method , js_name = containsPosition ) ]
    pub fn contains_position2(this: &Range, range: &IRange, position: &IPosition) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = containsPosition ) ]
    pub fn set_contains_position2(this: &Range, value: &Function);
    # [ wasm_bindgen ( method , js_name = containsRange ) ]
    pub fn contains_range(this: &Range, range: &IRange) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = containsRange ) ]
    pub fn set_contains_range(this: &Range, value: &Function);
    # [ wasm_bindgen ( method , js_name = containsRange ) ]
    pub fn contains_range2(this: &Range, range: &IRange, other_range: &IRange) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = containsRange ) ]
    pub fn set_contains_range2(this: &Range, value: &Function);
    # [ wasm_bindgen ( method , js_name = strictContainsRange ) ]
    pub fn strict_contains_range(this: &Range, range: &IRange) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = strictContainsRange ) ]
    pub fn set_strict_contains_range(this: &Range, value: &Function);
    # [ wasm_bindgen ( method , js_name = strictContainsRange ) ]
    pub fn strict_contains_range2(this: &Range, range: &IRange, other_range: &IRange) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = strictContainsRange ) ]
    pub fn set_strict_contains_range2(this: &Range, value: &Function);
    # [ wasm_bindgen ( method , js_name = plusRange ) ]
    pub fn plus_range(this: &Range, range: &IRange) -> Range;
    # [ wasm_bindgen ( method , setter , js_name = plusRange ) ]
    pub fn set_plus_range(this: &Range, value: &Function);
    # [ wasm_bindgen ( method , js_name = plusRange ) ]
    pub fn plus_range2(this: &Range, a: &IRange, b: &IRange) -> Range;
    # [ wasm_bindgen ( method , setter , js_name = plusRange ) ]
    pub fn set_plus_range2(this: &Range, value: &Function);
    # [ wasm_bindgen ( method , js_name = intersectRanges ) ]
    pub fn intersect_ranges(this: &Range, range: &IRange) -> JsValue;
    # [ wasm_bindgen ( method , setter , js_name = intersectRanges ) ]
    pub fn set_intersect_ranges(this: &Range, value: &Function);
    # [ wasm_bindgen ( method , js_name = intersectRanges ) ]
    pub fn intersect_ranges2(this: &Range, a: &IRange, b: &IRange) -> JsValue;
    # [ wasm_bindgen ( method , setter , js_name = intersectRanges ) ]
    pub fn set_intersect_ranges2(this: &Range, value: &Function);
    # [ wasm_bindgen ( method , js_name = equalsRange ) ]
    pub fn equals_range(this: &Range, other: &JsValue) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = equalsRange ) ]
    pub fn set_equals_range(this: &Range, value: &Function);
    # [ wasm_bindgen ( method , js_name = equalsRange ) ]
    pub fn equals_range2(this: &Range, a: &JsValue, b: &JsValue) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = equalsRange ) ]
    pub fn set_equals_range2(this: &Range, value: &Function);
    # [ wasm_bindgen ( method , js_name = getEndPosition ) ]
    pub fn get_end_position(this: &Range) -> Position;
    # [ wasm_bindgen ( method , setter , js_name = getEndPosition ) ]
    pub fn set_get_end_position(this: &Range, value: &Function);
    # [ wasm_bindgen ( method , js_name = getStartPosition ) ]
    pub fn get_start_position(this: &Range) -> Position;
    # [ wasm_bindgen ( method , setter , js_name = getStartPosition ) ]
    pub fn set_get_start_position(this: &Range, value: &Function);
    # [ wasm_bindgen ( method , js_name = toString ) ]
    pub fn to_string(this: &Range) -> String;
    # [ wasm_bindgen ( method , setter , js_name = toString ) ]
    pub fn set_to_string(this: &Range, value: &Function);
    # [ wasm_bindgen ( method , js_name = setEndPosition ) ]
    pub fn set_end_position(this: &Range, end_line_number: f64, end_column: f64) -> Range;
    # [ wasm_bindgen ( method , setter , js_name = setEndPosition ) ]
    pub fn set_set_end_position(this: &Range, value: &Function);
    # [ wasm_bindgen ( method , js_name = setStartPosition ) ]
    pub fn set_start_position(this: &Range, start_line_number: f64, start_column: f64) -> Range;
    # [ wasm_bindgen ( method , setter , js_name = setStartPosition ) ]
    pub fn set_set_start_position(this: &Range, value: &Function);
    # [ wasm_bindgen ( method , js_name = collapseToStart ) ]
    pub fn collapse_to_start(this: &Range) -> Range;
    # [ wasm_bindgen ( method , setter , js_name = collapseToStart ) ]
    pub fn set_collapse_to_start(this: &Range, value: &Function);
    # [ wasm_bindgen ( method , js_name = collapseToStart ) ]
    pub fn collapse_to_start2(this: &Range, range: &IRange) -> Range;
    # [ wasm_bindgen ( method , setter , js_name = collapseToStart ) ]
    pub fn set_collapse_to_start2(this: &Range, value: &Function);
    # [ wasm_bindgen ( method , js_name = fromPositions ) ]
    pub fn from_positions(this: &Range, start: &IPosition, end: Option<&IPosition>) -> Range;
    # [ wasm_bindgen ( method , setter , js_name = fromPositions ) ]
    pub fn set_from_positions(this: &Range, value: &Function);
    #[wasm_bindgen(method)]
    pub fn lift(this: &Range, range: &JsValue);
    #[wasm_bindgen(method, setter)]
    pub fn set_lift(this: &Range, value: &Function);
    # [ wasm_bindgen ( method , js_name = lift ) ]
    pub fn lift2(this: &Range, range: &IRange) -> Range;
    # [ wasm_bindgen ( method , setter , js_name = lift ) ]
    pub fn set_lift2(this: &Range, value: &Function);
    # [ wasm_bindgen ( method , js_name = isIRange ) ]
    pub fn is_i_range(this: &Range, obj: &JsValue) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = isIRange ) ]
    pub fn set_is_i_range(this: &Range, value: &Function);
    # [ wasm_bindgen ( method , js_name = areIntersectingOrTouching ) ]
    pub fn are_intersecting_or_touching(this: &Range, a: &IRange, b: &IRange) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = areIntersectingOrTouching ) ]
    pub fn set_are_intersecting_or_touching(this: &Range, value: &Function);
    # [ wasm_bindgen ( method , js_name = areIntersecting ) ]
    pub fn are_intersecting(this: &Range, a: &IRange, b: &IRange) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = areIntersecting ) ]
    pub fn set_are_intersecting(this: &Range, value: &Function);
    # [ wasm_bindgen ( method , js_name = compareRangesUsingStarts ) ]
    pub fn compare_ranges_using_starts(this: &Range, a: &JsValue, b: &JsValue) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = compareRangesUsingStarts ) ]
    pub fn set_compare_ranges_using_starts(this: &Range, value: &Function);
    # [ wasm_bindgen ( method , js_name = compareRangesUsingEnds ) ]
    pub fn compare_ranges_using_ends(this: &Range, a: &IRange, b: &IRange) -> f64;
    # [ wasm_bindgen ( method , setter , js_name = compareRangesUsingEnds ) ]
    pub fn set_compare_ranges_using_ends(this: &Range, value: &Function);
    # [ wasm_bindgen ( method , js_name = spansMultipleLines ) ]
    pub fn spans_multiple_lines(this: &Range, range: &IRange) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = spansMultipleLines ) ]
    pub fn set_spans_multiple_lines(this: &Range, value: &Function);
    #[doc = "A selection in the editor."]
    #[doc = "The selection is a range that has an orientation."]
    pub type ISelection;
    # [ wasm_bindgen ( method , getter , js_name = selectionStartLineNumber ) ]
    pub fn selection_start_line_number(this: &ISelection) -> f64;
    # [ wasm_bindgen ( method , getter , js_name = selectionStartColumn ) ]
    pub fn selection_start_column(this: &ISelection) -> f64;
    # [ wasm_bindgen ( method , getter , js_name = positionLineNumber ) ]
    pub fn position_line_number(this: &ISelection) -> f64;
    # [ wasm_bindgen ( method , getter , js_name = positionColumn ) ]
    pub fn position_column(this: &ISelection) -> f64;
    #[doc = "A selection in the editor."]
    #[doc = "The selection is a range that has an orientation."]
    pub type Selection;
    # [ wasm_bindgen ( method , getter , js_name = selectionStartLineNumber ) ]
    pub fn selection_start_line_number(this: &Selection) -> f64;
    # [ wasm_bindgen ( method , getter , js_name = selectionStartColumn ) ]
    pub fn selection_start_column(this: &Selection) -> f64;
    # [ wasm_bindgen ( method , getter , js_name = positionLineNumber ) ]
    pub fn position_line_number(this: &Selection) -> f64;
    # [ wasm_bindgen ( method , getter , js_name = positionColumn ) ]
    pub fn position_column(this: &Selection) -> f64;
    #[wasm_bindgen(constructor)]
    pub fn new_selection(
        selection_start_line_number: f64,
        selection_start_column: f64,
        position_line_number: f64,
        position_column: f64,
    ) -> Selection;
    # [ wasm_bindgen ( method , js_name = toString ) ]
    pub fn to_string(this: &Selection) -> String;
    # [ wasm_bindgen ( method , setter , js_name = toString ) ]
    pub fn set_to_string(this: &Selection, value: &Function);
    # [ wasm_bindgen ( method , js_name = equalsSelection ) ]
    pub fn equals_selection(this: &Selection, other: &ISelection) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = equalsSelection ) ]
    pub fn set_equals_selection(this: &Selection, value: &Function);
    # [ wasm_bindgen ( method , js_name = selectionsEqual ) ]
    pub fn selections_equal(this: &Selection, a: &ISelection, b: &ISelection) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = selectionsEqual ) ]
    pub fn set_selections_equal(this: &Selection, value: &Function);
    # [ wasm_bindgen ( method , js_name = getDirection ) ]
    pub fn get_direction(this: &Selection) -> SelectionDirection;
    # [ wasm_bindgen ( method , setter , js_name = getDirection ) ]
    pub fn set_get_direction(this: &Selection, value: &Function);
    # [ wasm_bindgen ( method , js_name = setEndPosition ) ]
    pub fn set_end_position(this: &Selection, end_line_number: f64, end_column: f64) -> Selection;
    # [ wasm_bindgen ( method , setter , js_name = setEndPosition ) ]
    pub fn set_set_end_position(this: &Selection, value: &Function);
    # [ wasm_bindgen ( method , js_name = getPosition ) ]
    pub fn get_position(this: &Selection) -> Position;
    # [ wasm_bindgen ( method , setter , js_name = getPosition ) ]
    pub fn set_get_position(this: &Selection, value: &Function);
    # [ wasm_bindgen ( method , js_name = setStartPosition ) ]
    pub fn set_start_position(
        this: &Selection,
        start_line_number: f64,
        start_column: f64,
    ) -> Selection;
    # [ wasm_bindgen ( method , setter , js_name = setStartPosition ) ]
    pub fn set_set_start_position(this: &Selection, value: &Function);
    # [ wasm_bindgen ( method , js_name = fromPositions ) ]
    pub fn from_positions(
        this: &Selection,
        start: &IPosition,
        end: Option<&IPosition>,
    ) -> Selection;
    # [ wasm_bindgen ( method , setter , js_name = fromPositions ) ]
    pub fn set_from_positions(this: &Selection, value: &Function);
    # [ wasm_bindgen ( method , js_name = liftSelection ) ]
    pub fn lift_selection(this: &Selection, sel: &ISelection) -> Selection;
    # [ wasm_bindgen ( method , setter , js_name = liftSelection ) ]
    pub fn set_lift_selection(this: &Selection, value: &Function);
    # [ wasm_bindgen ( method , js_name = selectionsArrEqual ) ]
    pub fn selections_arr_equal(this: &Selection, a: &Array, b: &Array) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = selectionsArrEqual ) ]
    pub fn set_selections_arr_equal(this: &Selection, value: &Function);
    # [ wasm_bindgen ( method , js_name = isISelection ) ]
    pub fn is_i_selection(this: &Selection, obj: &JsValue) -> bool;
    # [ wasm_bindgen ( method , setter , js_name = isISelection ) ]
    pub fn set_is_i_selection(this: &Selection, value: &Function);
    # [ wasm_bindgen ( method , js_name = createWithDirection ) ]
    pub fn create_with_direction(
        this: &Selection,
        start_line_number: f64,
        start_column: f64,
        end_line_number: f64,
        end_column: f64,
        direction: SelectionDirectionRef,
    ) -> Selection;
    # [ wasm_bindgen ( method , setter , js_name = createWithDirection ) ]
    pub fn set_create_with_direction(this: &Selection, value: &Function);
    pub type Token;
    #[wasm_bindgen(method, getter)]
    pub fn offset(this: &Token) -> f64;
    # [ wasm_bindgen ( method , getter , js_name = type ) ]
    pub fn type_(this: &Token) -> String;
    #[wasm_bindgen(method, getter)]
    pub fn language(this: &Token) -> String;
    #[wasm_bindgen(constructor)]
    pub fn new_token(offset: f64, type_: &str, language: &str) -> Token;
    # [ wasm_bindgen ( method , js_name = toString ) ]
    pub fn to_string(this: &Token) -> String;
    # [ wasm_bindgen ( method , setter , js_name = toString ) ]
    pub fn set_to_string(this: &Token, value: &Function);
}
